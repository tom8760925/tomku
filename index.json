[{"content":"符號 這篇是golang的筆記第04篇\n記錄 \u0026hellip; 和 _ 的用法\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a, b, _ := notes04_1() //忽略回傳值 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;------\u0026#34;) var c = [...]int{1, 2} //忽略大小 fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;------\u0026#34;) notes04_2(1, 2) notes04_2(1, 2, 3, 4) } func notes04_1() (int, string, bool) { return 1, \u0026#34;A\u0026#34;, false } func notes04_2(n ...int) { //可變的input fmt.Println(\u0026#34;p:\u0026#34;, n) } 結果\np: 1 p: A ------ p: [1 2] ------ p: [1 2] p: [1 2 3 4] ","permalink":"https://tom8760925.github.io/tomku/golang/notes/04/","summary":"這篇是golang的筆記第04篇","title":"golang語言的筆記-符號"},{"content":"errors 這篇是golang的練習筆記第10篇\ngolang沒有try，但能使用errors實現。\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { no10_1() } func no10_1() { err := errors.New(\u0026#34;p:err\u0026#34;) if err != nil { fmt.Println(err) } } 結果\np:err 函數的應用\nfunc no10_2() { if n, err := no10_2r(0); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;p:\u0026#34;, n) } if n, err := no10_2r(1); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;p:\u0026#34;, n) } } func no10_2r(n int) (int, error) { if n == 0 { return n, fmt.Errorf(\u0026#34;p:err\u0026#34;) } return n, nil } 結果\np:err p: 1 結構的應用\ntype a struct { n int i int } func no10_3() { if n, err := no10_3r(1, 2); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;p:\u0026#34;, n) } if n, err := no10_3r(1, 0); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;p:\u0026#34;, n) } } func no10_3r(n, i int) (int, error) { if n \u0026lt;= 0 || i \u0026lt;= 0 { return 0, \u0026amp;a{n: n, i: i} } return n + i, nil } func (e *a) Error() string { if e.n \u0026lt;= 0 { return \u0026#34;err(n=\u0026#34; + fmt.Sprint(e.n) + \u0026#34;)\u0026#34; } else if e.i \u0026lt;= 0 { return \u0026#34;err(i=\u0026#34; + fmt.Sprint(e.i) + \u0026#34;)\u0026#34; } else { return \u0026#34;p:err\u0026#34; } } 結果\np: 3 err(i=0) ","permalink":"https://tom8760925.github.io/tomku/golang/no/10/","summary":"這篇是golang的練習筆記第10篇","title":"golang語言的練習-errors"},{"content":"interfaces 這篇是golang的筆記第03篇\npackage main import \u0026#34;fmt\u0026#34; type a interface { is() } type b interface { isi(int) } type c interface { isir(int) string } type d interface { is2() } type e interface { is() isi(int) isir(int) string is2() } type nint struct { n int } type nstring struct { n string } func (n nint) is() { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(int)\u0026#34;) } func (n nstring) is() { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(string)\u0026#34;) } func (n nint) isi(i int) { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(int)\u0026#34;, i) } func (n nstring) isi(i int) { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(string)\u0026#34;, i) } func (n nint) isir(i int) string { return \u0026#34;P:\u0026#34; + fmt.Sprint(n.n) + \u0026#34;(int)\u0026#34; + fmt.Sprint(i) } func (n nstring) isir(i int) string { return \u0026#34;P:\u0026#34; + n.n + \u0026#34;(string)\u0026#34; + fmt.Sprint(i) } func (n *nint) is2() { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(int)\u0026#34;) } func (n *nstring) is2() { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(string)\u0026#34;) } func is(n e) { n.is() n.is2() } func is2(n e, i int) string { return n.isir(i) } func main() { var aa a var bb b var cc c var dd d aa = nint{n: 1} aa.is() fmt.Println(\u0026#34;------\u0026#34;) aa = nstring{n: \u0026#34;A\u0026#34;} aa.is() fmt.Println(\u0026#34;======\u0026#34;) bb = nint{n: 2} bb.isi(1) fmt.Println(\u0026#34;------\u0026#34;) bb = nstring{n: \u0026#34;B\u0026#34;} bb.isi(1) fmt.Println(\u0026#34;======\u0026#34;) cc = nint{n: 3} fmt.Println(cc.isir(1)) fmt.Println(\u0026#34;------\u0026#34;) cc = nstring{n: \u0026#34;C\u0026#34;} fmt.Println(cc.isir(1)) fmt.Println(\u0026#34;=====\u0026#34;) dd = \u0026amp;nint{n: 4} dd.is2() fmt.Println(\u0026#34;------\u0026#34;) dd = \u0026amp;nstring{n: \u0026#34;D\u0026#34;} dd.is2() fmt.Println(\u0026#34;======\u0026#34;) ee := nint{n: 5} ee.is() fmt.Println(\u0026#34;------\u0026#34;) ee2 := nstring{n: \u0026#34;E\u0026#34;} ee2.is() fmt.Println(\u0026#34;=====\u0026#34;) ff := nint{n: 6} is(\u0026amp;ff) fmt.Println(\u0026#34;------\u0026#34;) ff2 := nstring{n: \u0026#34;F\u0026#34;} is(\u0026amp;ff2) fmt.Println(\u0026#34;=====\u0026#34;) gg := nint{n: 7} fmt.Println(is2(\u0026amp;gg, 1)) fmt.Println(\u0026#34;------\u0026#34;) gg2 := nstring{n: \u0026#34;G\u0026#34;} fmt.Println(is2(\u0026amp;gg2, 1)) } 結果\nP: 1 (int) ------ P: A (string) ====== P: 2 (int) 1 ------ P: B (string) 1 ====== P:3(int)1 ------ P:C(string)1 ===== P: 4 (int) ------ P: D (string) ====== P: 5 (int) ------ P: E (string) ===== P: 6 (int) P: 6 (int) ------ P: F (string) P: F (string) ===== P:7(int)1 ------ P:G(string)1 ","permalink":"https://tom8760925.github.io/tomku/golang/notes/03/","summary":"這篇是golang的筆記第03篇","title":"golang語言的筆記-interfaces"},{"content":"type 這篇是golang的筆記第02篇\npackage main import \u0026#34;fmt\u0026#34; func main() { type a int var b a = 1 fmt.Println(\u0026#34;p:\u0026#34;, b) } 結果\np: 1 ","permalink":"https://tom8760925.github.io/tomku/golang/notes/02/","summary":"這篇是golang的筆記第02篇","title":"golang語言的筆記-type"},{"content":"結構 這篇是golang的練習筆記第09篇\npackage main import \u0026#34;fmt\u0026#34; func main() { no09_1() } type no09 struct { i int n string } type no092 struct { a struct { b int c string } d bool } type no093 struct { no no09 d bool } type no094 struct { no09 //隱藏 d bool } func no09_1() { a := no09{i: 1, n: \u0026#34;A\u0026#34;} var b no09 = no09{2, \u0026#34;B\u0026#34;} fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, a.i) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;p:\u0026#34;, b.i) fmt.Println(\u0026#34;-----\u0026#34;) c := no09_1r(a) fmt.Println(\u0026#34;p:\u0026#34;, c.i) fmt.Println(\u0026#34;p:\u0026#34;, c.n) fmt.Println(\u0026#34;-----\u0026#34;) d := no092{} d.a.b = 3 d.a.c = \u0026#34;C\u0026#34; d.d = true fmt.Println(\u0026#34;p:\u0026#34;, d.a) fmt.Println(\u0026#34;p:\u0026#34;, d.a.b) fmt.Println(\u0026#34;p:\u0026#34;, d.a.c) fmt.Println(\u0026#34;p:\u0026#34;, d.d) fmt.Println(\u0026#34;-----\u0026#34;) e := no093{no09{4, \u0026#34;D\u0026#34;}, false} fmt.Println(\u0026#34;p:\u0026#34;, e.no) fmt.Println(\u0026#34;p:\u0026#34;, e.no.i) fmt.Println(\u0026#34;p:\u0026#34;, e.no.n) fmt.Println(\u0026#34;p:\u0026#34;, e.d) fmt.Println(\u0026#34;-----\u0026#34;) f := no094{no09{4, \u0026#34;D\u0026#34;}, false} fmt.Println(\u0026#34;p:\u0026#34;, f) fmt.Println(\u0026#34;p:\u0026#34;, f.i) fmt.Println(\u0026#34;p:\u0026#34;, f.n) fmt.Println(\u0026#34;p:\u0026#34;, f.d) } func no09_1r(no no09) no09 { no.i += 2 no.n = \u0026#34;c\u0026#34; return no } 結果\np: {1 A} p: 1 ----- p: {2 B} p: 2 ----- p: 3 p: c ----- p: {3 C} p: 3 p: C p: true ----- p: {4 D} p: 4 p: D p: false ----- p: {{4 D} false} p: 4 p: D p: false ","permalink":"https://tom8760925.github.io/tomku/golang/no/09/","summary":"這篇是golang的練習筆記第09篇","title":"golang語言的練習-結構"},{"content":"map 這篇是golang的筆記第01篇\ngolang有像python的字典的常數\npackage main import \u0026#34;fmt\u0026#34; func main() { a := map[string]int{ \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2, \u0026#34;C\u0026#34;: 3, } b := make(map[string]int) c := a fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, a[\u0026#34;A\u0026#34;]) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) b[\u0026#34;A\u0026#34;] = 1 //新增 fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, len(a)) fmt.Println(\u0026#34;-----\u0026#34;) delete(a, \u0026#34;C\u0026#34;) //刪除 fmt.Println(\u0026#34;p:\u0026#34;, a) } 結果\np: map[A:1 B:2 C:3] p: 1 ----- p: map[] p: map[A:1] ----- p: map[A:1 B:2 C:3] ----- p: 3 ----- p: map[A:1 B:2] ","permalink":"https://tom8760925.github.io/tomku/golang/notes/01/","summary":"這篇是golang的筆記第01篇","title":"golang語言的筆記-map"},{"content":"指標 這篇是golang的練習筆記第08篇\npackage main import \u0026#34;fmt\u0026#34; func main() { no08_1() } func no08_1() { var a int = 1 var b *int var c **int var d [1]*int b = \u0026amp;a c = \u0026amp;b d[0] = \u0026amp;a fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;p:\u0026#34;, *b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, *c) fmt.Println(\u0026#34;p:\u0026#34;, **c) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, d[0]) fmt.Println(\u0026#34;p:\u0026#34;, *d[0]) } 結果\np: 0x14000110018 p: 1 ----- p: 0x14000110018 p: 1 ----- p: 0x14000110018 p: 1 ","permalink":"https://tom8760925.github.io/tomku/golang/no/08/","summary":"這篇是golang的練習筆記第08篇","title":"golang語言的練習-指標"},{"content":"陣列 這篇是golang的練習筆記第07篇\ngolang有陣列和slice，差別在陣列長度不可改變，slice可以改變\n宣告 一元 package main import \u0026#34;fmt\u0026#34; func main() { no07_1() } func no07_1() { var a [3]int = [3]int{1, 2, 3} var b []int = []int{1, 2, 3, 4, 5, 6} var c []int = make([]int, 5) //宣告5個長度 var d []int = make([]int, 5, 10) //宣告5個長度，預留10個長度 var e []int f := [3]int{1, 2, 3} var g []int = a[0:3] fmt.Println(\u0026#34;p:\u0026#34;, a[0]) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, d) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, e) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, f) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, g) } 結果\np: 1 ----- p: [1 2 3 4 5 6] ----- p: [0 0 0 0 0] ----- p: [0 0 0 0 0] ----- p: [] ----- p: [1 2 3] ----- p: [1 2 3] 二元 func no07_2() { var a [3][3]int = [3][3]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} var b [][]int = [][]int{{1, 2, 3}, {4, 5, 6}} var c [][]int = [][]int{make([]int, 3), make([]int, 3)} var d [][]int = make([][]int, 2) for i := range d { d[i] = make([]int, 3) } var e [][]int f := [2][3]int{} fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, d) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, e) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, f) } 結果\np: [[1 2 3] [4 5 6] [7 8 9]] ----- p: [[1 2 3] [4 5 6]] ----- p: [[0 0 0] [0 0 0]] ----- p: [[0 0 0] [0 0 0]] ----- p: [] ----- p: [[0 0 0] [0 0 0]] 新增 func no07_3() { var a []int = []int{1, 2, 3} var b []int var c [][]int = [][]int{{1, 2, 3}, {4, 5, 6}} var d []int = make([]int, 3) b = append(b, 1, 2, 3, 4) c[0] = append(c[0], 4) copy(d, a) //複製進去的容量要足夠才能複製 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) } 結果\np: [1 2 3] ----- p: [1 2 3 4] ----- p: [[1 2 3 4] [4 5 6]] 大小 func no07_4() { var a []int = []int{1, 2, 3} var b [][]int = [][]int{{1, 2, 3}, {4, 5, 6}} fmt.Println(\u0026#34;p:\u0026#34;, len(a)) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, len(b)) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, len(b[0])) } 結果\np: 3 ----- p: 2 ----- p: 3 顯示 func no07_5() { var a []int = []int{1, 2, 3} for i := range a { //顯示key fmt.Println(\u0026#34;p:\u0026#34;, i) } fmt.Println(\u0026#34;-----\u0026#34;) for _, i := range a { //顯示值 fmt.Println(\u0026#34;p:\u0026#34;, i) } } 結果\np: 0 p: 1 p: 2 ----- p: 1 p: 2 p: 3 參考資料:\n連結：底層為陣列的 slice | openhome.cc網址：https://openhome.cc/Gossip/Go/Slice.html\n連結：Go 语言切片(Slice) | 菜鸟教程網址：https://www.runoob.com/go/go-slice.html\n連結：[Golang] 程式設計教學：使用陣列 (Array) 和切片 (Slice) | 開源技術教學網址：https://opensourcedoc.com/golang-programming/array-slice/\n","permalink":"https://tom8760925.github.io/tomku/golang/no/07/","summary":"這篇是golang的練習筆記第07篇","title":"golang語言的練習-陣列"},{"content":"迴圈 這篇是golang的練習筆記第06篇\n宣告 package main import \u0026#34;fmt\u0026#34; func main() { no06_2() } func no06_1() { var a int = 1 for i := 1; i \u0026lt; 3; i++ { fmt.Println(\u0026#34;p:\u0026#34;, i) } fmt.Println(\u0026#34;----\u0026#34;) for a \u0026lt; 3 { fmt.Println(\u0026#34;p:\u0026#34;, a) a++ } } 結果\np: 1 p: 2 ---- p: 1 p: 2 其他 func no06_2() { for i := 1; i \u0026lt; 4; i++ { if i == 2 { continue } fmt.Println(\u0026#34;p:\u0026#34;, i) } fmt.Println(\u0026#34;----\u0026#34;) for i := 1; i \u0026lt; 4; i++ { if i == 2 { break } fmt.Println(\u0026#34;p:\u0026#34;, i) } fmt.Println(\u0026#34;----\u0026#34;) var a int = 1 test: //從這裡重新開始 for a \u0026lt; 4 { if a == 2 { a++ goto test //會返到test } fmt.Println(\u0026#34;p:\u0026#34;, a) a++ } } 結果\np: 1 p: 3 ---- p: 1 ---- p: 1 p: 3 參考資料:\n連結：Go 语言 goto 语句 | 菜鸟教程網址：https://www.runoob.com/go/go-goto-statement.html\n","permalink":"https://tom8760925.github.io/tomku/golang/no/06/","summary":"這篇是golang的練習筆記第06篇","title":"golang語言的練習-迴圈"},{"content":"if 這篇是golang的練習筆記第05篇\npackage main import \u0026#34;fmt\u0026#34; func main() { no05_1() } func no05_1() { var a int = 1 var b string = \u0026#34;Apple\u0026#34; if a == 1 { fmt.Println(\u0026#34;p:\u0026#34;, a) } else if a == 2 { fmt.Println(\u0026#34;p:\u0026#34;, a) } else { fmt.Println(\u0026#34;p:\u0026#34;, a) } fmt.Println(\u0026#34;-----\u0026#34;) switch b { case \u0026#34;Apple\u0026#34;: fmt.Println(\u0026#34;p:\u0026#34;, b) case \u0026#34;banana\u0026#34;: fmt.Println(\u0026#34;p:\u0026#34;, b) default: fmt.Println(\u0026#34;p:\u0026#34;, b) } } 結果\np: 1 ----- p: Apple ","permalink":"https://tom8760925.github.io/tomku/golang/no/05/","summary":"這篇是golang的練習筆記第05篇","title":"golang語言的練習-if"},{"content":"函數 這篇是golang的練習筆記第04篇\npackage main import \u0026#34;fmt\u0026#34; func main() { no04_1() } func no04_1() { a := no04_1r fmt.Println(\u0026#34;p:\u0026#34;, no04_1r(2, \u0026#34;A\u0026#34;)) fmt.Println(\u0026#34;------\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, a(2, \u0026#34;B\u0026#34;)) } func no04_1r(n int, i string) int { fmt.Println(\u0026#34;p:\u0026#34;, i) fmt.Println(\u0026#34;p:\u0026#34;, n) fmt.Println(\u0026#34;------\u0026#34;) return n } 結果\np: A p: 2 ------ p: 2 ------ p: B p: 2 ------ p: 2 回傳複數的值\nfunc no04_2() { a, b := no04_2r(1, \u0026#34;A\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;------\u0026#34;) var c int var d string c, d = no04_2r2(2, \u0026#34;B\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;p:\u0026#34;, d) } func no04_2r(n int, i string) (int, string) { return n, i } func no04_2r2(n int, i string) (rn int, ri string) { rn = n ri = i return } 結果\np: 1 p: A ------ p: 2 p: B 參考資料:\n連結：函式入門 | openhome.cc網址：https://openhome.cc/Gossip/Go/Function.html\n連結：一級函式 | openhome.cc網址：https://openhome.cc/Gossip/Go/FirstClassFunction.html\n連結：Go 语言函数 | 菜鸟教程網址：https://www.runoob.com/go/go-functions.html\n","permalink":"https://tom8760925.github.io/tomku/golang/no/04/","summary":"這篇是golang的練習筆記第04篇","title":"golang語言的練習-函數"},{"content":"print和scan 這篇是golang的練習筆記第03篇\nprint package main import \u0026#34;fmt\u0026#34; func main() { no03_1() } func no03_1() { var a int = 1 fmt.Print(\u0026#34;p:\u0026#34;, a, \u0026#34;\\n\u0026#34;) //單純顯示 fmt.Printf(\u0026#34;p:%d\\n\u0026#34;, a) //使用參數 fmt.Println(\u0026#34;p:\u0026#34;, a) //自動換行 } 結果\np:1 p:1 p: 1 scan func no03_2() { var a, b int = 0, 0 fmt.Print(\u0026#34;s:\u0026#34;) fmt.Scan(\u0026amp;a, \u0026amp;b) //可以連續讀取，並可以用空白符號間隔兩個變數的輸入 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-------\u0026#34;) fmt.Print(\u0026#34;s:\u0026#34;) fmt.Scanf(\u0026#34;%d-%d\u0026#34;, \u0026amp;a, \u0026amp;b) //可以使用參數，並可以自行設定符號作為間隔 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-------\u0026#34;) fmt.Print(\u0026#34;s:\u0026#34;) fmt.Scanln(\u0026amp;a, \u0026amp;b) //只要到換行符號就停止 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) } 結果\ns:1 2 p: 1 p: 2 ------- s:3-4 p: 3 p: 4 ------- s:5 6 p: 5 p: 6 參考資料:\n連結：fmt package - fmt - Go Packages網址：https://pkg.go.dev/fmt\n","permalink":"https://tom8760925.github.io/tomku/golang/no/03/","summary":"這篇是golang的練習筆記第03篇","title":"golang語言的練習-print和scan"},{"content":"unordered_map 這篇是C++的筆記第06篇\nc++有像python的字典的常數\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; int main() { unordered_map\u0026lt;string, int\u0026gt; a = {{\u0026#34;a\u0026#34;, 1}, // 宣告 {\u0026#34;b\u0026#34;, 2}, {\u0026#34;c\u0026#34;, 3}, {\u0026#34;d\u0026#34;, 4}}; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a[\u0026#34;a\u0026#34;] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; if (a.insert(make_pair(\u0026#34;e\u0026#34;, 5)).second) // 新增，如果鍵值已經有就會新增失敗回傳false { cout \u0026lt;\u0026lt; \u0026#34;p:true\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a[\u0026#34;e\u0026#34;] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.count(\u0026#34;a\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 用鍵值找是否存在 cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.count(\u0026#34;f\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a.insert({\u0026#34;f\u0026#34;, 6}); cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.count(\u0026#34;f\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 大小 cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; a.erase(\u0026#34;e\u0026#34;); // 刪除 a.clear(); if (a.empty()) // 判斷是否為空 { cout \u0026lt;\u0026lt; \u0026#34;p:0\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } 結果\np:1 -------- p:true p:5 -------- p:1 p:0 p:1 -------- p:6 -------- p:0 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/06/","summary":"這篇是C++的筆記第06篇","title":"C++語言的筆記-unordered_map"},{"content":"型態 這篇是golang的練習筆記第02篇\ngolang的變數有８、１６、３２、６４的大小\n種類 名稱 8 16 32 64 數值 int 有 有 有 有 uint(無負號) 有 有 有 有 byte 有 沒有 沒有 沒有 rune 沒有 沒有 有 沒有 浮點數 float 沒有 沒有 有 有 字元 string 沒有 沒有 沒有 沒有 布林 bool 沒有 沒有 沒有 沒有 變數 func no02_1() { var a = 1 var a1 int = 2 var ( a2 int = 3 a3 string = \u0026#34;4\u0026#34; a4 bool ) var a5, a6 int = 5, 6 a7 := 7 //簡化寫法 fmt.Println(a) fmt.Println(a1) fmt.Println(a2) fmt.Println(a3) fmt.Println(a4) fmt.Println(a5) fmt.Println(a6) fmt.Println(a7) a5, a6 = a6, a5 //交換 fmt.Println(a5) fmt.Println(a6) } 結果\n1 2 3 4 false 5 6 7 6 5 常數 func no02_2() { const a = 1 const a1 int = 2 const ( a2 int = 3 a3 string = \u0026#34;4\u0026#34; ) const a4, a5 int = 5, 6 const ( //沒有宣告值會使用前一個值 a6 = 6 a7 ) fmt.Println(a) fmt.Println(a1) fmt.Println(a2) fmt.Println(a3) fmt.Println(a4) fmt.Println(a5) fmt.Println(a6) fmt.Println(a7) } 結果\n1 2 3 4 5 6 6 6 iota func no02_3() { const (//+1 a = iota a1 a2 ) const ( //二進位往左移 a3 = 1 \u0026lt;\u0026lt; iota //1 a4 //10 a5 //100 ) fmt.Println(a) fmt.Println(a1) fmt.Println(a2) fmt.Println(a3) fmt.Println(a4) fmt.Println(a5) } 結果\n0 1 2 1 2 4 ","permalink":"https://tom8760925.github.io/tomku/golang/no/02/","summary":"這篇是golang的練習筆記第02篇","title":"golang語言的練習-型態"},{"content":"環境設置 這篇是golang的練習筆記第01篇\n以下以mac的vscode進行操作\n安裝golang 去以下網址下載golang(mac要安裝arm64)\nhttps://go.dev/ 使用以下指令確認是否安裝成功。\ngo version 安裝VSCODE插建 安裝golang的插件\nhttps://marketplace.visualstudio.com/items?itemName=golang.Go 起始設定 在上面輸入指令更新插件\nGo: Install/Update tools 在終端機輸入\ngo mod init (資料夾名稱) 就會出現go.mod\n在偵錯按新增launch.json，然後在裡面加\n\u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; 啟動測試 新增.go檔案，裡面寫入程式進行測試，如果沒問題應該能執行。\npackage main func main() { } 參考資料:\n連結：設定 Visual Studio Code for Go 開發 - Go on Azure | Microsoft learn網址：https://learn.microsoft.com/zh-tw/azure/developer/go/configure-visual-studio-code\n","permalink":"https://tom8760925.github.io/tomku/golang/no/01/","summary":"這篇是golang的練習筆記第01篇","title":"golang語言的練習-環境設置"},{"content":" 這篇是C++的練習實作第03篇\n嘗試用visual studio 製作和理解win32 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c++/practice/03/","summary":"這篇是C++的練習實作第03篇","title":"C++語言的練習-練習實作win32"},{"content":"MFC設置 這篇是C++的練習筆記第10篇\n安裝visual studio\nhttps://visualstudio.microsoft.com/zh-hant/downloads/ 將使用c++的桌面開發裡面的mfc勾選。\n","permalink":"https://tom8760925.github.io/tomku/c++/no/10/","summary":"這篇是C++的練習筆記第10篇","title":"C++語言的練習-MFC設置"},{"content":" 這篇是C++的練習實作第02篇\n練習使用variant、例外、函數、命名空間、迴圈、陣列、結構、預處理、模板、輸入輸出、繼承。\n#include \u0026lt;stdio.h\u0026gt; //載入指令 #include \u0026lt;iostream\u0026gt; //載入指令 #include \u0026lt;string\u0026gt; //載入指令 #include \u0026lt;vector\u0026gt; //載入指令 #include \u0026lt;typeinfo\u0026gt; //載入指令 using namespace std; #ifndef MAX // 定義 #define MAX 2 #endif namespace student_input // 輸入 { class st_input_default // 輸入預設 { public: st_input_default(vector\u0026lt;string\u0026gt; sa) : sa(sa) {} ~st_input_default() { cout \u0026lt;\u0026lt; \u0026#34;輸入完成\u0026#34; \u0026lt;\u0026lt; endl; } void st_input_cout(int n) { cout \u0026lt;\u0026lt; \u0026#34;請輸入\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;sa[n] \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; } protected: vector\u0026lt;string\u0026gt; sa; // 輸入的欄位名稱 }; class st_input_add : public st_input_default // 新增 { public: using st_input_default::st_input_default; template \u0026lt;typename T\u0026gt; void st_input_cin(T *s, int n) // 輸入資料 { auto i = *s; st_input_cout(n); cin \u0026gt;\u0026gt; i; *s = i; cout \u0026lt;\u0026lt; this-\u0026gt;sa[n] \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } }; } namespace student_output // 輸出 { class st_output_default // 輸出預設 { public: st_output_default(vector\u0026lt;string\u0026gt; sa) : sa(sa) {} ~st_output_default() { cout \u0026lt;\u0026lt; \u0026#34;顯示完成\u0026#34; \u0026lt;\u0026lt; endl; } protected: vector\u0026lt;string\u0026gt; sa; // 輸出的欄位名稱 }; class st_output_show : public st_output_default // 顯示資料 { public: using st_output_default::st_output_default; template \u0026lt;typename T\u0026gt; void st_output_cout(T s, int n) // 顯示欄位資料 { cout \u0026lt;\u0026lt; this-\u0026gt;sa[n] \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } }; } struct student // 結構宣告 { int id; string name; int no, score; student() { id = 0; name = \u0026#34;\u0026#34;; no = 0; score = 0; } student(int id) : id(id) {} student(int id, string name, int no, int score) : id(id), name(name), no(no), score(score) {} }; struct visit_type // 判斷資料型態 { string type = \u0026#34;\u0026#34;; // 存放資料的型態 void operator()(const int *t) { type = \u0026#34;int*\u0026#34;; } void operator()(const int t) { type = \u0026#34;int\u0026#34;; } void operator()(const string *t) { type = \u0026#34;string*\u0026#34;; } void operator()(const string t) { type = \u0026#34;string\u0026#34;; } }; void st_input(int n); // 函數宣告 void st_list(int n); // 函數宣告 void st_sumscore(int n); // 函數宣告 vector\u0026lt;struct student\u0026gt; student_data; // 資料庫 int main() { string cin_if; int n = 0; bool cin_if_while = true; while (cin_if_while) { cout \u0026lt;\u0026lt; \u0026#34;輸入1輸入學生資料(最多輸入\u0026#34; \u0026lt;\u0026lt; MAX \u0026lt;\u0026lt; \u0026#34;筆資料，現在已經輸入\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;筆)\\n輸入2計算總成績\\n輸入3查看輸入的資料\\n輸入4離開\\n請輸入半形的1、2、3、4:\u0026#34;; cin \u0026gt;\u0026gt; cin_if; try { switch (stoi(cin_if)) { case 1: if (n \u0026lt; MAX) { st_input(n + 1); n++; } else { cout \u0026lt;\u0026lt; \u0026#34;已達輸入上限\u0026#34; \u0026lt;\u0026lt; endl; } break; case 2: if (n \u0026gt; 0) { st_sumscore(n); } else { cout \u0026lt;\u0026lt; \u0026#34;尚未輸入任何資料\u0026#34; \u0026lt;\u0026lt; endl; } break; case 3: if (n \u0026gt; 0) { st_list(n); } else { cout \u0026lt;\u0026lt; \u0026#34;尚未輸入任何資料\u0026#34; \u0026lt;\u0026lt; endl; } break; case 4: cin_if_while = false; cout \u0026lt;\u0026lt; \u0026#34;結束\u0026#34; \u0026lt;\u0026lt; endl; break; default: cout \u0026lt;\u0026lt; \u0026#34;輸入錯誤(請輸入半形的1-4)\u0026#34; \u0026lt;\u0026lt; endl; break; } } catch (const std::invalid_argument \u0026amp;e) // 輸入了數字以外的的例外 { cout \u0026lt;\u0026lt; \u0026#34;輸入錯誤(請輸入半形的1-4)\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } void st_input(int n) // 輸入資料 { using namespace student_input; vector\u0026lt;string\u0026gt; vector_string = {\u0026#34;姓名\u0026#34;, \u0026#34;學號\u0026#34;, \u0026#34;成績\u0026#34;}; // 欄位名稱 struct student stud(n); struct visit_type vt; vector\u0026lt;variant\u0026lt;int *, string *\u0026gt;\u0026gt; vector_student = {\u0026amp;stud.name, \u0026amp;stud.no, \u0026amp;stud.score}; // 資料型態 st_input_add st(vector_string); for (int i = 0; i \u0026lt; (int)vector_string.size(); i++) { visit(vt, vector_student[i]); // 判斷資料型態 if (vt.type == \u0026#34;int*\u0026#34;) { st.st_input_cin(get\u0026lt;int *\u0026gt;(vector_student[i]), i); // 資料型態為int } else if (vt.type == \u0026#34;string*\u0026#34;) { st.st_input_cin(get\u0026lt;string *\u0026gt;(vector_student[i]), i); // 資料型態為string } } student_data.push_back(stud); // 將資料存放到資料庫 } void st_list(int n) // 顯示資料 { using namespace student_output; vector\u0026lt;string\u0026gt; vector_string = {\u0026#34;編號\u0026#34;, \u0026#34;姓名\u0026#34;, \u0026#34;學號\u0026#34;, \u0026#34;成績\u0026#34;}; // 欄位名稱 st_output_show st(vector_string); struct visit_type vt; for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;variant\u0026lt;int, string\u0026gt;\u0026gt; vector_student = {student_data[i].id, student_data[i].name, student_data[i].no, student_data[i].score}; // 資料型態 for (int ii = 0; ii \u0026lt; (int)vector_string.size(); ii++) { visit(vt, vector_student[ii]); // 判斷資料型態 if (vt.type == \u0026#34;int\u0026#34;) { st.st_output_cout(get\u0026lt;int\u0026gt;(vector_student[ii]), ii); // 資料型態為int } else if (vt.type == \u0026#34;string\u0026#34;) { st.st_output_cout(get\u0026lt;string\u0026gt;(vector_student[ii]), ii); // 資料型態為string } } } } void st_sumscore(int n) // 計算總成績 { using namespace student_output; vector\u0026lt;string\u0026gt; vector_string = {\u0026#34;總成績\u0026#34;}; // 欄位名稱 st_output_show st(vector_string); int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += student_data[i].score; } st.st_output_cout(sum, 0); // 顯示總成績 } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c++/practice/02/","summary":"這篇是C++的練習實作第02篇","title":"C++語言的練習-練習實作02"},{"content":"lambda 這篇是C++的筆記第05篇\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 1; auto la = [](int n) -\u0026gt; int { return n; }; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; la(a) \u0026lt;\u0026lt; endl; return 0; } 結果\np:1 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/05/","summary":"這篇是C++的筆記第05篇","title":"C++語言的筆記-lambda"},{"content":"variant 這篇是C++的練習筆記第09篇\nc++有可以儲存多種型態的容器\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { variant\u0026lt;int, string\u0026gt; a, b;//宣告型態的種類和變數 a = 11; b = \u0026#34;AA\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; get\u0026lt;int\u0026gt;(a) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;//輸出值 cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; get\u0026lt;string\u0026gt;(b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;//輸出值 if (get_if\u0026lt;int\u0026gt;(\u0026amp;a) != nullptr)//判斷變數的型態是否正確，不正確就輸出nullptr，要記得加上\u0026amp;。 { cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; get\u0026lt;int\u0026gt;(a) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } 結果\np;11 p;AA p;11 visit 型態自動判斷\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct t { void operator()(const int \u0026amp;t) { cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator()(const string \u0026amp;t) { cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; struct tt { string a = \u0026#34;\u0026#34;; void operator()(const int \u0026amp;t) { a = \u0026#34;int\u0026#34;; } void operator()(const string \u0026amp;t) { a = \u0026#34;string\u0026#34;; } }; int main() { struct t tt; struct tt tt2; variant\u0026lt;int, string\u0026gt; a, b; // 宣告型態的種類和變數 a = 11; b = \u0026#34;AA\u0026#34;; visit([](auto \u0026amp;\u0026amp;arg) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; endl; }, a); visit(tt, a); visit(tt2, a); cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; tt2.a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } 結果\np:11 p;11 p;int 參考資料:\n連結：如何优雅的使用 std::variant 与 std::optional - 知乎網址：https://zhuanlan.zhihu.com/p/366537214\n連結：std::variant - cppreference.com網址：https://en.cppreference.com/w/cpp/utility/variant\n連結：C++17 更通用的 union：variant - Heresy's Space網址：https://kheresy.wordpress.com/2017/10/16/cpp17-variant/\n","permalink":"https://tom8760925.github.io/tomku/c++/no/09/","summary":"這篇是C++的練習筆記第09篇","title":"C++語言的練習-variant"},{"content":"正規表達式 這篇是C++的筆記第04篇\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;regex\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void rim(string n); int main(){ string a=\u0026#34;AzxB\u0026#34;,b=\u0026#34;12456\u0026#34;; rim(a); cout\u0026lt;\u0026lt;\u0026#34;-----\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; rim(b); cout\u0026lt;\u0026lt;endl; return 0; } void rim(string n){ regex r(\u0026#34;[A-Za-z]*\u0026#34;); if(regex_match(n,r)){//與字串比對 cout\u0026lt;\u0026lt;\u0026#34;T\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else{ cout\u0026lt;\u0026lt;\u0026#34;F\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } 結果\nT ----- F ","permalink":"https://tom8760925.github.io/tomku/c++/notes/04/","summary":"這篇是C++的筆記第04篇","title":"C++語言的筆記-正規表達式"},{"content":"const 這篇是C++的筆記第03篇 加上const，就不能跟改值。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ const int a =1; cout \u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;//不能用a=2，改變值。 cout \u0026lt;\u0026lt;endl; return 0; } 結果\np:1 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/03/","summary":"這篇是C++的筆記第03篇","title":"C++語言的筆記-const"},{"content":"例外 這篇是C++的練習筆記第08篇\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ try { throw \u0026#34;1\u0026#34;;//發生例外 } catch(const exception\u0026amp; e)//根據例外顯示結果 { cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;endl; return 0; } 結果\nlibc++abi: terminating due to uncaught exception of type char Abort 例外可以顯示自定文字\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ try { throw \u0026#34;A\u0026#34;;//發生例外 } catch(const char * e)//根據例外顯示結果 { cerr \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:A ","permalink":"https://tom8760925.github.io/tomku/c++/no/08/","summary":"這篇是C++的練習筆記第08篇","title":"C++語言的練習-例外"},{"content":"命名空間 這篇是C++的練習筆記第07篇\n#include \u0026lt;iostream\u0026gt; using namespace std; namespace a { int r(int n){ return n; } namespace b { int r2(int n){ return n+1; } } } using namespace a; using namespace b;//指向b using namespace a::b;//指向b int main(){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;r(1)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;r2(1)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a::b::r2(1)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:1 p:2 p:2 參考資料:\n連結：類別和結構 (C++) | Microsoft Learn 網址：https://learn.microsoft.com/zh-tw/cpp/cpp/classes-and-structs-cpp?view=msvc-170\n","permalink":"https://tom8760925.github.io/tomku/c++/no/07/","summary":"這篇是C++的練習筆記第07篇","title":"C++語言的練習-命名空間"},{"content":"模板 這篇是C++的練習筆記第06篇\n#include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; void a(T n); int main(){ a(1); a(\u0026#39;A\u0026#39;); cout\u0026lt;\u0026lt;endl; return 0; } template \u0026lt;typename T\u0026gt; void a(T n){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } 結果\np:1 p:A ","permalink":"https://tom8760925.github.io/tomku/c++/no/06/","summary":"這篇是C++的練習筆記第06篇","title":"C++語言的練習-模板"},{"content":"繼承 這篇是C++的練習筆記第05篇\n創建 #include \u0026lt;iostream\u0026gt; using namespace std; class a { public: int pca(){ return 1; } }; class b:public a { public: int pcb(){ return 2; } }; int main(){ a ca; b cb; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;ca.pca()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;cb.pca()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;cb.pcb()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 結果\np:1 p:1 p:2 控制 繼承有3個控制\n#include \u0026lt;iostream\u0026gt; using namespace std; class a { public: void pca(){ cout\u0026lt;\u0026lt;\u0026#34;--pca--\\n\u0026#34;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;pda()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;pea()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } protected: int pda(){ return 2; } private: int pea(){ return 3; } }; class b : public a { public: void pcb(){ pca(); cout\u0026lt;\u0026lt;\u0026#34;--pcb--\\n\u0026#34;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;pda()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } }; class c : protected b { public: void pcc(){ pcb(); } }; class d : private c { public: void pcd(){ pcc(); } }; int main(){ a ca; b cb; c cc; d cd; cout\u0026lt;\u0026lt;\u0026#34;--ca--\\n\u0026#34;; ca.pca(); cout\u0026lt;\u0026lt;\u0026#34;--cb--\\n\u0026#34;; cb.pcb(); cb.pca(); cout\u0026lt;\u0026lt;\u0026#34;--cc--\\n\u0026#34;; cc.pcc();//因為控制權限所以不能使用pca cout\u0026lt;\u0026lt;\u0026#34;--cd--\\n\u0026#34;; cd.pcd();//因為控制權限所以不能使用pca cout\u0026lt;\u0026lt;endl; return 0; } 結果\n--ca-- --pca-- p:2 p:3 --cb-- --pca-- p:2 p:3 --pcb-- p:2 --pca-- p:2 p:3 --cc-- --pca-- p:2 p:3 --pcb-- p:2 --cd-- --pca-- p:2 p:3 --pcb-- p:2 宣告 constructor是建構宣告\n#include \u0026lt;iostream\u0026gt; using namespace std; class a { public: a()=default;//設定預設 a(int n):n(n){} a(int n1,int n2){ this-\u0026gt;n=n1+n2; } a(const a\u0026amp;)=delete;//將這個宣告禁止，例ca1=ca2不能用。 void pca(){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;this-\u0026gt;n\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } private: int n=0; }; int main(){ a ca1; ca1.pca(); a ca2(1); ca2.pca(); a ca3(1,2); ca3.pca(); cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:0 p:1 p:3 繼承 #include \u0026lt;iostream\u0026gt; using namespace std; class a { public: a(int n):n(n){} void pca(){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;this-\u0026gt;n\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } private: int n=0; }; class b :public a { public: using a::a;//直接繼承宣告 void pcb(){ a::pca();//直接繼承函式 } }; class c :public a { using ca=a;//將繼承修改 public: using ca::a; void pcc(){ ca::pca(); } }; int main(){ b cb(1); cb.pcb(); cout\u0026lt;\u0026lt;\u0026#34;----\\n\u0026#34;; c cc(2); cc.pcc(); cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:1 ---- p:2 參考資料:\n連結：類別和結構 (C++) | Microsoft Learn網址：https://learn.microsoft.com/zh-tw/cpp/cpp/classes-and-structs-cpp?view=msvc-170\n連結：C++ 继承 | 菜鸟教程網址：https://www.runoob.com/cplusplus/cpp-inheritance.html\n連結：C繼承共同行為網址：https://openhome.cc/Gossip/CppGossip/Inheritance.html\n連結：遮蔽父類方法網址：https://openhome.cc/Gossip/CppGossip/HideMemberFunction.html\n","permalink":"https://tom8760925.github.io/tomku/c++/no/05/","summary":"這篇是C++的練習筆記第05篇","title":"C++語言的練習-繼承"},{"content":"執行問題 這篇是C++的筆記第02篇\n在mac上使用vscode，如果使用到c++11的，可能會發生錯誤。\n將可能解決方法記錄。\n在延伸模組c/c++中的cpp standard和cpp standard設定c++17和c17。還有在seetting.json的\u0026quot;cpp\u0026quot;:裡面加入-std=c++17 -pthread 在延伸模組complie run configuration中cpp-flags裡面加入-std=c++17(有使用到C/C++ Compile Run，才需要使用) 將四個json設定欓刪掉重新創建。 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/02/","summary":"這篇是C++的筆記第02篇","title":"C++語言的筆記-執行問題"},{"content":"vector 這篇是C++的練習筆記第04篇\nc++有個動態調整的陣列，會預留陣列空間。\n宣告 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; b = {1,2,3}; vector\u0026lt;int\u0026gt; c {1,2,3}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; d {{1,2},{3}}; int e[]={4,5,6}; vector\u0026lt;int\u0026gt; f (e,e+3); vector\u0026lt;int\u0026gt; g (b.begin()+1,b.end()-1); for(int n=0 ;n\u0026lt;3;n++){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;b[n]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;\u0026#34;---\\n\u0026#34;; for(int n=0 ;n\u0026lt;3;n++){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;\u0026#34;---\\n\u0026#34;; for(auto \u0026amp;n:g){//簡易顯示方法 cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;\u0026#34;---\\n\u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; a.reserve(3);//預先配置記憶體大小 cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:1 p:2 p:3 --- p:4 p:5 p:6 --- p:2 --- p:0 p:3 新增 使用pop_back後，因為會預留空間，所以值還會在。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; a = {1,2,3}; a.push_back(4); cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a[3]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; a.pop_back(); cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a[3]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;//值還是在 cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:4 p:3 p:4 大小 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; a = {1,2,3,4,5}; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;//大小 cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.end()-a.begin()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;//記憶體大小 cout\u0026lt;\u0026lt;\u0026#34;---\\n\u0026#34;; a.push_back(6); cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; a.shrink_to_fit();//清多餘的記憶體大小 cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:5 p:5 p:5 --- p:6 p:10 p:6 p:6 參考資料:\n連結：C++ std::vector 用法與範例網址：https://shengyu7697.github.io/std-vector/\n連結：使用 vector網址：https://openhome.cc/Gossip/CppGossip/vector1.html\n","permalink":"https://tom8760925.github.io/tomku/c++/no/04/","summary":"這篇是C++的練習筆記第04篇","title":"C++語言的練習-vector"},{"content":"字串複製 這篇是C的筆記第06篇\nstrcpy 將字串複製到變數內，因為字串無法用a=\u0026ldquo;AA\u0026rdquo;，所以可以使用strcpy。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main(){ char a[50],b[50]; strcpy(a,\u0026#34;AA\u0026#34;); strcpy(b,a); printf(\u0026#34;p:%s\\n\u0026#34;,a); printf(\u0026#34;p:%s\\n\u0026#34;,b); return 0; } 結果\np:AA p:AA strdup strdup也是複製，只是是先用malloc創建才複製。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ char *a,b[]=\u0026#34;AA\u0026#34;; a=strdup(b); printf(\u0026#34;p:%s\\n\u0026#34;,a); printf(\u0026#34;p:%s\\n\u0026#34;,b); free(a); return 0; } 結果\np:AA p:AA ","permalink":"https://tom8760925.github.io/tomku/c/notes/06/","summary":"這篇是C的筆記第06篇","title":"C語言的筆記-字串複製"},{"content":"strlen 這篇是C的筆記第05篇\nc有陣列長度的方法strlen，需要宣告#include \u0026lt;string.h\u0026gt;，而他找的是有存資料的長度。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main(){ char a[50],b[50]=\u0026#34;AAA\u0026#34;; int c=0,d=0; c=strlen(a); d=strlen(b); printf(\u0026#34;p:%d\\n\u0026#34;,c); printf(\u0026#34;p:%d\\n\u0026#34;,d); return 0; } 結果\np:0 p:3 ","permalink":"https://tom8760925.github.io/tomku/c/notes/05/","summary":"這篇是C的筆記第05篇","title":"C語言的筆記-陣列長度"},{"content":"auto 這篇是C++的筆記第01篇\nc++有自動判斷型態，但不能兩種不同型態不能放在一起，像auto a=11,b=\u0026ldquo;AA\u0026rdquo;。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ auto a=11; auto b=\u0026#34;AA\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt;endl; return 0; } 結果\np:11 p:AA ","permalink":"https://tom8760925.github.io/tomku/c++/notes/01/","summary":"這篇是C++的筆記第01篇","title":"C++語言的筆記-auto"},{"content":" 這篇是C++的練習實作第01篇\n使用C語言的練習-練習實作01，改成C++練習使用函式宣告，輸入姓名、學號、成績，並顯示出來。\n#include \u0026lt;iostream\u0026gt; //載入指令 #include \u0026lt;string\u0026gt;//載入指令 using namespace std; void student_input();//函數宣告 int main(){ student_input();//呼叫函數 return 0; } void student_input(){ string name=\u0026#34;\u0026#34;; int no=0,score=0; cout \u0026lt;\u0026lt; \u0026#34;請輸入姓名:\u0026#34;;//顯示需要輸入的值 cin \u0026gt;\u0026gt; name;//輸入的值 cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;//顯示輸入的值 cout \u0026lt;\u0026lt; \u0026#34;請輸入學號:\u0026#34;;//顯示需要輸入的值 cin \u0026gt;\u0026gt; no;//輸入的值 cout \u0026lt;\u0026lt; \u0026#34;學號:\u0026#34; \u0026lt;\u0026lt; no \u0026lt;\u0026lt; endl;//顯示輸入的值 cout \u0026lt;\u0026lt; \u0026#34;請輸入成績:\u0026#34;;//顯示需要輸入的值 cin \u0026gt;\u0026gt; score;//輸入的值 cout \u0026lt;\u0026lt; \u0026#34;成績:\u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; endl;//顯示輸入的值 } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c++/practice/01/","summary":"這篇是C++的練習實作第01篇","title":"C++語言的練習-練習實作01"},{"content":"輸入輸出 這篇是C++的練習筆記第03篇\nC++的輸入輸出，可以使用C語言的練習-printf 和 scanf那篇的方法。\nC++有增加輸入輸出的方法\ncout 用來顯示\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int a=11,b=22; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; a; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;and\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;std::flush; return 0; } 結果\np：11 p：11 p：11 p：11and22 endl可以使用\\n替代，endl等於\u0026rsquo;\\n\u0026rsquo;\u0026laquo;std::flush，換行之後清暫存。\ncin 用來輸入 cin 可以同時輸入兩個，可以直接按enter後在輸入，或在中間加空格。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int a=0,b=0; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;; cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;; cin \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt;b; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt;b; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0; } 結果\np:1 p:2 p:1+2 p:1 2 p:1+2 p:1 2 p:1+2 cerr 是用來顯示錯誤訊息。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int a=0; cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 結果\n0 Clog 是用來顯示log訊息。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int a=0; clog \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 結果\n0 ","permalink":"https://tom8760925.github.io/tomku/c++/no/03/","summary":"這篇是C++的練習筆記第03篇","title":"C++語言的練習-輸入輸出"},{"content":"型態 這篇是C++的練習筆記第02篇\n記錄C++有哪些型態\n在型態前面加上unsigned，會變強制沒有負號\n在型態前面加上signed，會變強制有負號\n種類 名稱 記憶體空間 加unsigned 加signed 數值 int 4 Bytes 可 可 short 2 Bytes 可 可 long 8 Bytes 可 可 long long 8 Bytes 不可 不可 浮點數 float 4 Bytes 不可 不可 double 8 Bytes 不可 不可 long double 16 Bytes 不可 不可 字元 char 1 Bytes 可 可 無種類 void 不可 不可 布林 bool 1 Bytes 不可 不可 Unicode wchar_t 不可 不可 c++有string，可以使用但需要宣告，才能使用string。\n#include \u0026lt;string\u0026gt; using namespace std; 使用方式\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string d=\u0026#34;AAA\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 結果\np：AAA ","permalink":"https://tom8760925.github.io/tomku/c++/no/02/","summary":"這篇是C++的練習筆記第02篇","title":"C++語言的練習-型態"},{"content":"環境設置 這篇是C++的練習筆記第01篇\n以下跟Ｃ的環境設置大致相同，只有副檔名不相同，C++的副檔名其中一個是cpp。\n以下是在MAC進行操作執行\n安裝VSCODE 去以下網址下載VSCODE\nhttps://code.visualstudio.com/ 安裝VSCODE插建 安裝C的插件\nhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack 繁體插件\nhttps://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hant 起始設定 先在程式資料夾中新增檔案，名子隨意副檔名為.cpp 點選新增的.cpp檔案，再點選右上角齒輪\nC/C++:clang 建置及偵錯使用中的檔案 就會新增2個json欓 接著在收尋欄輸入\n\u0026gt;c/c++:Edit Configurations(JSON) 點選後會新增一個JSON檔案\n啟動測試 接著就能執行程式偵錯 有兩個方式可以偵錯\n1.直接點上方的執行-\u0026gt;進行偵錯 但這個方法在使用scanf，輸入時會有問題，可以在launch.json裡面修改參數externalConsole改成true，就會額外乎叫終端機視窗。 2.點右邊上三角形下拉選點單，選CompileRun : Compile with default flags \u0026amp; Run with default arguments，就能直接在vscode裡的終端機進行操作，使用scanf輸入也不會有問題。 沒問題就能直接執行.cpp檔案\n有問題可能是因為.cpp檔案內沒有程式，可以先寫個起始程式，應該就能執行。\nint main(){ return 0; } 參考資料:\n連結：Configure VS Code for Clang/LLVM on macOS網址：https://code.visualstudio.com/docs/cpp/config-clang-mac\n","permalink":"https://tom8760925.github.io/tomku/c++/no/01/","summary":"這篇是C++的練習筆記第01篇","title":"C++語言的練習-環境設置"},{"content":"restrict 這篇是C的筆記第04篇\nc有可以優化指標的讀取的方法。\n#include \u0026lt;stdio.h\u0026gt; int test1(int *a,int *b,int *restrict c); int main(){ int a = 1; int b = 2; int c = 3; printf(\u0026#34;p:%d\\n\u0026#34;,test1(\u0026amp;a,\u0026amp;b,\u0026amp;c)); return 0; } int test1(int *a,int *b,int *restrict c){ *a += *c; *b += *c; return *a + *b; } 結果\np:9 參考資料:\n連結：restrict- Wikipedia網址：https://en.wikipedia.org/wiki/Restrict\n連結：C/C++关键字之restrict網址：https://backendhouse.github.io/post/c-c++%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Brestrict/\n","permalink":"https://tom8760925.github.io/tomku/c/notes/04/","summary":"這篇是C的筆記第04篇","title":"C語言的筆記-restrict"},{"content":"typedef 這篇是C的筆記第03篇\ntypedef可以對資料類型取別名\n#include \u0026lt;stdio.h\u0026gt; struct a //第一種 { int aa; }; typedef struct a b; int main(){ b c; c.aa=1; printf(\u0026#34;p:%d\\n\u0026#34;,c.aa); return 0; } 結果\np:1 參考資料:\n連結：Typedef - 維基百科，自由的百科全書網址：https://zh.wikipedia.org/wiki/Typedef\n","permalink":"https://tom8760925.github.io/tomku/c/notes/03/","summary":"這篇是C的筆記第03篇","title":"C語言的筆記-typedef"},{"content":"student 這篇是C的練習實作第05篇\n將鏈結加入、新增顯示輸入的資料\n#include \u0026lt;stdio.h\u0026gt;//載入指令 #include \u0026lt;stdbool.h\u0026gt;//載入指令 #include \u0026lt;stdlib.h\u0026gt;//載入指令 #include \u0026lt;ctype.h\u0026gt;//載入指令 #include \u0026lt;string.h\u0026gt;//載入指令 #ifndef MAX //定義 #define MAX 2 #endif struct student //結構宣告 { struct student *Previous; int ID; char name[50]; int no,score; struct student *next; }; void student_input(int n);//資料輸入 int student_score();//總成績 void student_list();//顯示輸入的資料 void scanf_flush();//清input buffer void student_flush();//清鏈結 struct student *head,*prt,*last;//結構變數宣告 char *pr[]={\u0026#34;英文姓名\u0026#34;,\u0026#34;學號\u0026#34;,\u0026#34;成績\u0026#34;},*scanf_if[]={\u0026#34;char\u0026#34;,\u0026#34;int\u0026#34;,\u0026#34;int\u0026#34;};//宣告 int main(){ char scanf_in[]=\u0026#34;\u0026#34;;//宣告 int scanf_number=0;//宣告 bool bool_n = true;//宣告 head = (struct student *)malloc(sizeof(struct student));//創建鏈結 head-\u0026gt;Previous=NULL; head-\u0026gt;next=NULL; last=head; while (bool_n)//判斷是否結束迴圈 { printf(\u0026#34;輸入1輸入學生資料(最多輸入%d筆資料，現在已經輸入%d筆)\\n輸入2計算總成績\\n輸入3查看輸入的資料\\n輸入4離開\\n請輸入1、2、3、4:\u0026#34;,(int)MAX,scanf_number);//顯示需要輸入的值 scanf(\u0026#34;%[1-4]s\u0026#34;,scanf_in);//輸入的值 switch (atoi(\u0026amp;scanf_in[0]))//判斷輸入的值 { case 1: if(scanf_number\u0026lt;MAX){//判斷輸入筆數 printf(\u0026#34;現在輸入的是第%d筆\\n\u0026#34;,scanf_number+1);//顯示筆數 student_input(scanf_number);//呼叫函數 scanf_number++;//筆數+1 } else{ printf(\u0026#34;現在已經輸入%d筆，結束輸入\\n\u0026#34;,scanf_number);//超過筆數強制結束 bool_n=false; } break; case 2: if(scanf_number\u0026gt;0){ printf(\u0026#34;總成績:%d\\n\u0026#34;,student_score());//總成績 } else{ printf(\u0026#34;並未輸入任何成績\\n\u0026#34;); } break; case 3: if(scanf_number\u0026gt;0){ student_list();//顯示輸入的資料 } else{ printf(\u0026#34;並未輸入任何成績\\n\u0026#34;); } break; case 4: printf(\u0026#34;離開\\n\u0026#34;);//結束迴圈 bool_n=false; student_flush();//清鏈結 break; default: printf(\u0026#34;輸入錯誤\\n\u0026#34;);//輸入的值錯誤 break; } scanf_flush();//清input buffer } return 0; } void student_input(int n){ prt=(struct student *)malloc(sizeof(struct student));//創建鏈結 void *scanf_void[]={\u0026amp;prt-\u0026gt;name,\u0026amp;prt-\u0026gt;no,\u0026amp;prt-\u0026gt;score};//宣告記憶體位置 for(int i=0;i\u0026lt;(int)(sizeof(pr)/sizeof(pr[0]));i++){//跑迴圈 scanf_flush();//清input buffer printf(\u0026#34;請輸入%s:\u0026#34;,pr[i]);//顯示需要輸入的值 if(strcmp(scanf_if[i],\u0026#34;char\u0026#34;)==0)//判斷輸入為字串或數值 { scanf(\u0026#34;%s\u0026#34;,(char *)scanf_void[i]);//輸入字串 printf(\u0026#34;%s:%s\\n\u0026#34;,pr[i],(char *)scanf_void[i]);//顯示數入值 } else { scanf(\u0026#34;%d\u0026#34;,(int *)scanf_void[i]);//輸入數值 printf(\u0026#34;%s:%d\\n\u0026#34;,pr[i],*(int *)scanf_void[i]);//顯示數入值 } } prt-\u0026gt;ID=n+1;//輸入登入資料 prt-\u0026gt;Previous=last;//輸入上一個鏈結位置 prt-\u0026gt;next=NULL;//輸入下一個鏈結位置 last-\u0026gt;next=prt;//上一個鏈結輸入下一個鏈結位置 last=prt; } int student_score(){ int return_score=0;//宣告 struct student *current; current=head-\u0026gt;next; while (current != NULL) { return_score+=current-\u0026gt;score;//計算總和 current=current-\u0026gt;next; } return return_score; } void student_list(){ struct student *current; current=head-\u0026gt;next; printf(\u0026#34;------\\n\u0026#34;); while (current != NULL) { printf(\u0026#34;登入編號:%d\\n\u0026#34;,current-\u0026gt;ID); void *scanf_void[]={\u0026amp;current-\u0026gt;name,\u0026amp;current-\u0026gt;no,\u0026amp;current-\u0026gt;score};//宣告記憶體位置 for(int i=0;i\u0026lt;(int)(sizeof(pr)/sizeof(pr[0]));i++){//跑迴圈 if(strcmp(scanf_if[i],\u0026#34;char\u0026#34;)==0)//判斷輸入為字串或數值 { printf(\u0026#34;%s:%s\\n\u0026#34;,pr[i],(char *)scanf_void[i]);//顯示數入值 } else { printf(\u0026#34;%s:%d\\n\u0026#34;,pr[i],*(int *)scanf_void[i]);//顯示數入值 } } printf(\u0026#34;------\\n\u0026#34;); current=current-\u0026gt;next; } } void scanf_flush(){ while ( (getchar()) != \u0026#39;\\n\u0026#39; ); } void student_flush(){ struct student *current; void *flush; current=head-\u0026gt;next; while (current != NULL) { flush=current; current=current-\u0026gt;next; free(flush); } } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/05/","summary":"這篇是C的練習實作第05篇","title":"C語言的練習-練習實作05"},{"content":"鏈結 這篇是C的練習筆記第11篇\n建立 鏈結的建立\n第一個 在輸入next時要注意，要先使用malloc才能輸入next，不然會是NULL。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct node { int ID; struct node *next; }; void node_in(); void node_up(); struct node *head,*prt1,*prt2,*prt3; int main(){ node_in(); printf(\u0026#34;-----\\n\u0026#34;); node_up(); return 0; } void node_in(){ head = (struct node *)malloc(sizeof(struct node)); head-\u0026gt;next=NULL; prt1=(struct node *)malloc(sizeof(struct node)); prt1-\u0026gt;ID=1; head-\u0026gt;next=prt1; printf(\u0026#34;p:%d\\n\u0026#34;,prt1-\u0026gt;ID); prt2=(struct node *)malloc(sizeof(struct node)); prt2-\u0026gt;ID=2; prt1-\u0026gt;next=prt2; printf(\u0026#34;p:%d\\n\u0026#34;,prt2-\u0026gt;ID); prt3=(struct node *)malloc(sizeof(struct node)); prt3-\u0026gt;ID=3; prt2-\u0026gt;next=prt3; printf(\u0026#34;p:%d\\n\u0026#34;,prt3-\u0026gt;ID); prt3-\u0026gt;next=NULL; } void node_up(){ struct node *current; current=head-\u0026gt;next; while (current != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;next; } } 結果\np:1 p:2 p:3 ----- p:1 p:2 p:3 第二個 更改新增方法，增加暫存變數。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct node { int ID; struct node *next; }; void node_in(int n); void node_up(); struct node *head,*prt,*last; int main(){ head = (struct node *)malloc(sizeof(struct node)); head-\u0026gt;next=NULL; last=head; for(int n=1;n\u0026lt;=3;n++){ node_in(n); } printf(\u0026#34;----\\n\u0026#34;); node_up(); return 0; } void node_in(int n){ prt=(struct node *)malloc(sizeof(struct node)); prt-\u0026gt;ID=n; prt-\u0026gt;next=NULL; last-\u0026gt;next=prt; last=prt; printf(\u0026#34;p:%d\\n\u0026#34;,prt-\u0026gt;ID); } void node_up(){ struct node *current; current=head-\u0026gt;next; while (current != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;next; } } 結果\np:1 p:2 p:3 ---- p:1 p:2 p:3 第三個 以先進後出的鏈結。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct node { int ID; struct node *next; }; void node_in(int n); void node_up(); struct node *head,*prt; int main(){ head = (struct node *)malloc(sizeof(struct node)); head-\u0026gt;next=NULL; for(int n=1;n\u0026lt;=3;n++){ node_in(n); } printf(\u0026#34;----\\n\u0026#34;); node_up(); return 0; } void node_in(int n){ prt=(struct node *)malloc(sizeof(struct node)); prt-\u0026gt;ID=n; prt-\u0026gt;next=NULL; prt-\u0026gt;next=head-\u0026gt;next; head-\u0026gt;next=prt; printf(\u0026#34;p:%d\\n\u0026#34;,prt-\u0026gt;ID); } void node_up(){ struct node *current; current=head-\u0026gt;next; while (current != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;next; } } 結果\np:1 p:2 p:3 ---- p:3 p:2 p:1 第四個 改成雙向鏈結\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct node { struct node *Previous; int ID; struct node *next; }; void node_in(int n); void node_up(); struct node *head,*prt,*last; int main(){ head = (struct node *)malloc(sizeof(struct node)); head-\u0026gt;Previous=NULL; head-\u0026gt;next=NULL; last=head; for(int n=1;n\u0026lt;=3;n++){ node_in(n); } printf(\u0026#34;----\\n\u0026#34;); node_up(); return 0; } void node_in(int n){ prt=(struct node *)malloc(sizeof(struct node)); prt-\u0026gt;Previous=last; prt-\u0026gt;ID=n; prt-\u0026gt;next=NULL; last-\u0026gt;next=prt; last=prt; printf(\u0026#34;p:%d\\n\u0026#34;,prt-\u0026gt;ID); } void node_up(){ struct node *current; current=head-\u0026gt;next; while (current != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;next; } printf(\u0026#34;----\\n\u0026#34;); current=last; while (current-\u0026gt;Previous != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;Previous; } } 結果\np:1 p:2 p:3 ---- p:1 p:2 p:3 ---- p:3 p:2 p:1 ","permalink":"https://tom8760925.github.io/tomku/c/no/11/","summary":"這篇是C的練習筆記第11篇","title":"C語言的練習-鏈結"},{"content":"input buffer 這篇是C的筆記第02篇\n在寫C語言的練習-練習實作04時，在使用scanf時，發現會因為input buffer，造成問題所以需要清掉。\n但需要確認放的位置，不然可能會多一次輸入。\n#include \u0026lt;stdio.h\u0026gt; int main(){ while ( (getchar()) != \u0026#39;\\n\u0026#39; ); return 0; } 參考資料:\n連結：Clearing The Input Buffer In C/C++網址：https://www.geeksforgeeks.org/clearing-the-input-buffer-in-cc/\n","permalink":"https://tom8760925.github.io/tomku/c/notes/02/","summary":"這篇是C的筆記第02篇","title":"C語言的筆記-input buffer"},{"content":"記憶體位置 這篇是C的筆記第01篇\n在寫C語言的練習-練習實作04時，發現到記憶體位置會干擾到值。\n如果使用test1宣告int和char，在輸入1時不會引響，但在輸入12就會影響a。\n經過測試因該是記憶體位置有關，因為test1在b輸入超過1bytes時，a的值就問題，改成test2就解決這個問題。\n#include \u0026lt;stdio.h\u0026gt; void test1(); void test2(); int main(){ printf(\u0026#34;test1\\n\u0026#34;); test1(); printf(\u0026#34;test2\\n\u0026#34;); test2(); return 0; } void test1(){ int a=0; char b[]=\u0026#34;\u0026#34;; printf(\u0026#34;a:%d\\n\u0026#34;,\u0026amp;a); printf(\u0026#34;b:%d\\n\u0026#34;,\u0026amp;b); printf(\u0026#34;p:%d\\n\u0026#34;,a); scanf(\u0026#34;%s\u0026#34;,b); printf(\u0026#34;p:%d\\n\u0026#34;,a); scanf(\u0026#34;%s\u0026#34;,b); printf(\u0026#34;p:%d\\n\u0026#34;,a); } void test2(){ char b[]=\u0026#34;\u0026#34;; int a=0; printf(\u0026#34;b:%d\\n\u0026#34;,\u0026amp;b); printf(\u0026#34;a:%d\\n\u0026#34;,\u0026amp;a); printf(\u0026#34;p:%d\\n\u0026#34;,a); scanf(\u0026#34;%s\u0026#34;,b); printf(\u0026#34;p:%d\\n\u0026#34;,a); scanf(\u0026#34;%s\u0026#34;,b); printf(\u0026#34;p:%d\\n\u0026#34;,a); } 結果\ntest1 a:1798009612 b:1798009611 p:0 1 p:0 12 p:50 test2 b:1798009615 a:1798009608 p:0 1 p:0 12 p:0 ","permalink":"https://tom8760925.github.io/tomku/c/notes/01/","summary":"這篇是C的筆記第01篇","title":"C語言的筆記-記憶體位置"},{"content":"student 這篇是C的練習實作第04篇\n更改迴圈的判斷、更改資料輸入方式、新增總成績、新增清input buffer\n#include \u0026lt;stdio.h\u0026gt;//載入指令 #include \u0026lt;stdbool.h\u0026gt;//載入指令 #include \u0026lt;stdlib.h\u0026gt;//載入指令 #include \u0026lt;ctype.h\u0026gt;//載入指令 #include \u0026lt;string.h\u0026gt;//載入指令 #ifndef MAX //定義 #define MAX 2 #endif struct student //結構宣告 { char name[50]; int no,score; }; void student_input(int n);//資料輸入 int student_score(int n);//總成績 void scanf_flush();//清input buffer struct student struct_student[MAX];//結構變數宣告 int main(){ char scanf_in[]=\u0026#34;\u0026#34;;//宣告 int scanf_number=0;//宣告 bool bool_n = true;//宣告 while (bool_n)//判斷是否結束迴圈 { printf(\u0026#34;輸入1輸入學生資料(最多輸入%d筆資料，現在已經輸入%d筆)\\n輸入2計算總成績\\n輸入3離開\\n請輸入1、2、3:\u0026#34;,(int)MAX,scanf_number);//顯示需要輸入的值 scanf(\u0026#34;%[1-3]s\u0026#34;,scanf_in);//輸入的值 switch (atoi(\u0026amp;scanf_in[0]))//判斷輸入的值 { case 1: if(scanf_number\u0026lt;MAX){//判斷輸入筆數 printf(\u0026#34;現在輸入的是第%d筆\\n\u0026#34;,scanf_number+1);//顯示筆數 student_input(scanf_number);//呼叫函數 scanf_number++;//筆數+1 } else{ printf(\u0026#34;現在已經輸入%d筆，結束輸入\\n\u0026#34;,scanf_number);//超過筆數強制結束 bool_n=false; } break; case 2: if(scanf_number\u0026gt;0){ printf(\u0026#34;總成績:%d\\n\u0026#34;,student_score(scanf_number));//總成績 } else{ printf(\u0026#34;並未輸入任何成績\\n\u0026#34;); } break; case 3: printf(\u0026#34;離開\\n\u0026#34;);//結束迴圈 bool_n=false; break; default: printf(\u0026#34;輸入錯誤\\n\u0026#34;);//輸入的值錯誤 break; } scanf_flush();//清input buffer } return 0; } void student_input(int n){ char *pr[]={\u0026#34;英文姓名\u0026#34;,\u0026#34;學號\u0026#34;,\u0026#34;成績\u0026#34;},*scanf_if[]={\u0026#34;char\u0026#34;,\u0026#34;int\u0026#34;,\u0026#34;int\u0026#34;};//宣告 struct student struct_student_input;//結構變數宣告 void *scanf_void[]={\u0026amp;struct_student_input.name,\u0026amp;struct_student_input.no,\u0026amp;struct_student_input.score};//宣告記憶體位置 for(int i=0;i\u0026lt;(int)(sizeof(pr)/sizeof(pr[0]));i++){//跑迴圈 scanf_flush();//清input buffer printf(\u0026#34;請輸入%s:\u0026#34;,pr[i]);//顯示需要輸入的值 if(strcmp(scanf_if[i],\u0026#34;char\u0026#34;)==0)//判斷輸入為字串或數值 { scanf(\u0026#34;%s\u0026#34;,(char *)scanf_void[i]);//輸入字串 printf(\u0026#34;%s:%s\\n\u0026#34;,pr[i],(char *)scanf_void[i]);//顯示數入值 } else { scanf(\u0026#34;%d\u0026#34;,(int *)scanf_void[i]);//輸入數值 printf(\u0026#34;%s:%d\\n\u0026#34;,pr[i],*(int *)scanf_void[i]);//顯示數入值 } } struct_student[n]=struct_student_input;//輸入資料 } int student_score(int n){ int return_score=0;//宣告 for(int i=0;i\u0026lt;n;i++){//回圈 return_score+=struct_student[n-1].score;//計算總和 } return return_score; } void scanf_flush(){ while ( (getchar()) != \u0026#39;\\n\u0026#39; ) continue; } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/04/","summary":"這篇是C的練習實作第04篇","title":"C語言的練習-練習實作04"},{"content":"student 這篇是C的練習實作第03篇\n練習陣列、指標、結構、預處理\n#include \u0026lt;stdio.h\u0026gt;//載入指令 #include \u0026lt;stdbool.h\u0026gt;//載入指令 #ifndef MAX //定義 #define MAX 2 #endif struct student //結構宣告 { char name[50]; int no,phone; }; struct student student_input();//函數宣告 struct student prin[MAX];//結構變數宣告 int main(){ int n=0,stin=0;//宣告 while (n != 2)//判斷是否結束迴圈 { printf(\u0026#34;輸入1輸入學生資料(最多輸入%d筆資料)\\n輸入2離開\\n請輸入1或2:\u0026#34;,(int)MAX);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);//輸入的值 switch (n)//判斷輸入的值 { case 1: if(stin\u0026lt;MAX){//判斷輸入筆數 printf(\u0026#34;現在輸入的是第%d筆\\n\u0026#34;,stin+1);//結束迴圈 prin[stin] = student_input();//呼叫函數 stin++;//筆數+1 } else{ printf(\u0026#34;現在已經輸入%d筆，結束輸入\\n\u0026#34;,stin);//超過筆數強制結束 n=2; } break; case 2: printf(\u0026#34;離開\\n\u0026#34;);//結束迴圈 break; default: printf(\u0026#34;輸入錯誤\\n\u0026#34;);//輸入的值錯誤 break; } } return 0; } struct student student_input(){ struct student prf;//結構變數宣告 char *pr[]={\u0026#34;姓名\u0026#34;,\u0026#34;學號\u0026#34;,\u0026#34;電話\u0026#34;};//宣告 printf(\u0026#34;請輸入%s:\u0026#34;,pr[0]);//顯示需要輸入的值 scanf(\u0026#34;%s\u0026#34;,prf.name);//輸入的值 printf(\u0026#34;%s:%s\\n\u0026#34;,pr[0],prf.name);//顯示輸入的值 printf(\u0026#34;請輸入%s:\u0026#34;,pr[1]);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;prf.no);//輸入的值 printf(\u0026#34;%s:%d\\n\u0026#34;,pr[1],prf.no);//顯示輸入的值 printf(\u0026#34;請輸入%s:\u0026#34;,pr[2]);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;prf.phone);//輸入的值 printf(\u0026#34;%s:%d\\n\u0026#34;,pr[2],prf.phone);//顯示輸入的值 return prf; } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/03/","summary":"這篇是C的練習實作第03篇","title":"C語言的練習-練習實作03"},{"content":"預處理 這篇是C的練習筆記第10篇\n指令 c在執行程式有預處理\n#include \u0026lt;stdio.h\u0026gt; #define MAX 2 #ifndef MAX//如果同樣定義，就不執行 #define MAX 3 #endif #ifdef MAX//如果同樣定義，就執行 #define NMAX 1 #endif #if (NMAX==1)//判斷 #define IFMAX 3 #elif (NMAX==2) #define IFMAX 2 #else #define IFMAX 1 #endif #if defined(NMAX)//判斷是有定義 #define IFDMAX 4 #endif int main(){ printf(\u0026#34;p:%d\\n\u0026#34;,MAX); printf(\u0026#34;p:%d\\n\u0026#34;,NMAX); printf(\u0026#34;p:%d\\n\u0026#34;,IFMAX); printf(\u0026#34;p:%d\\n\u0026#34;,IFDMAX); return 0; } 結果\np:2 p:1 p:3 p:4 參考資料:\n連結：前置處理器指示詞網址：https://learn.microsoft.com/zh-tw/cpp/preprocessor/preprocessor-directives?view=msvc-170\n連結：C 预处理器 | 菜鸟教程網址：https://www.runoob.com/cprogramming/c-preprocessors.html\n連結：C語言雜談01---如何理解條件編譯網址：https://ithelp.ithome.com.tw/articles/10283174\n","permalink":"https://tom8760925.github.io/tomku/c/no/10/","summary":"這篇是C的練習筆記第10篇","title":"C語言的練習-預處理"},{"content":"結構 這篇是C的練習筆記第09篇\n結構宣告 c的結構宣告是\n#include \u0026lt;stdio.h\u0026gt; struct a //第一種 { int aa; }; struct b //第二種 { char bb; } bs;//直接宣告結構變數名稱 int main(){ struct c//第三種 { int *cc; }; struct d//第四種 { char *dd; } ds; struct e //第五種 { char ee,ef[3]; } es={\u0026#39;b\u0026#39;,{\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;}};//宣告結構變數和設定初值 struct a as ={1};//宣告結構變數和設定初值 struct c cs;//宣告結構變數 bs.bb=\u0026#39;a\u0026#39;;//設定值 cs.cc=\u0026amp;as.aa;//設定值 ds.dd=\u0026amp;bs.bb;//設定值 printf(\u0026#34;p:%d\\n\u0026#34;,as.aa); printf(\u0026#34;p:%c\\n\u0026#34;,bs.bb); printf(\u0026#34;p:%d\\n\u0026#34;,*cs.cc); printf(\u0026#34;p:%c\\n\u0026#34;,*ds.dd); printf(\u0026#34;p:%c\\n\u0026#34;,es.ee); printf(\u0026#34;p:%c\\n\u0026#34;,es.ef[0]); return 0; } 結果\np:1 p:a p:1 p:a p:b p:c 結構的使用方法 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct a { int aa; }; struct b { struct a aa; char bb; }; void ra(struct a *ar); void ra2(struct a ar); struct a ra3(struct a ar); int main(){ struct a as ={1};//使用方法1 struct a *as2=\u0026amp;as;//使用方法1 struct a as3;//使用方法2 struct a as4={.aa=4};//使用方法5 struct b bs={//使用方法6 .aa={.aa=5}, .bb=\u0026#39;A\u0026#39; }; struct a as5[]={{.aa=1},{.aa=2},{.aa=3},{.aa=4},{.aa=5}};//使用方法7 struct a *as6 = malloc(sizeof(struct a));//使用方法8 struct a *as7 = malloc(5*sizeof(struct a));//使用方法9 printf(\u0026#34;使用方法1\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,as2-\u0026gt;aa); printf(\u0026#34;p:%d\\n\u0026#34;,(*as2).aa); printf(\u0026#34;使用方法2\\n\u0026#34;); ra(\u0026amp;as3); printf(\u0026#34;p:%d\\n\u0026#34;,as3.aa); printf(\u0026#34;使用方法3\\n\u0026#34;); ra2(as); printf(\u0026#34;使用方法4\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,ra3(as).aa); printf(\u0026#34;使用方法5\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,as4.aa); printf(\u0026#34;使用方法6\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,bs.aa.aa); printf(\u0026#34;p:%c\\n\u0026#34;,bs.bb); printf(\u0026#34;使用方法7\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,as5[2].aa); printf(\u0026#34;使用方法8\\n\u0026#34;); (*as6).aa=1; printf(\u0026#34;p:%d\\n\u0026#34;,(*as6).aa); free(as6); printf(\u0026#34;使用方法9\\n\u0026#34;); as7[3].aa=3; printf(\u0026#34;p:%d\\n\u0026#34;,as7[3].aa); free(as7); return 0; } void ra(struct a *ar){//使用方法2 (*ar).aa=2; } void ra2(struct a ar){//使用方法3 printf(\u0026#34;p:%d\\n\u0026#34;,ar.aa); } struct a ra3(struct a ar){//使用方法4 struct a ar_n; ar_n.aa=ar.aa+2; return ar_n; } 結果\n使用方法1 p:1 p:1 使用方法2 p:2 使用方法3 p:1 使用方法4 p:3 使用方法5 p:4 使用方法6 p:5 p:A 使用方法7 p:3 使用方法8 p:1 使用方法9 p:3 ","permalink":"https://tom8760925.github.io/tomku/c/no/09/","summary":"這篇是C的練習筆記第09篇","title":"C語言的練習-結構"},{"content":"指標 這篇是C的練習筆記第08篇\n指標宣告 c的指標宣告有＊、＊＊，一個＊是數值或字串的指標、兩個＊＊是指標的指標。\nint main(){ int *a,**b; char *c,**d; void *e,**f; return 0; } 指標的使用 指標主要是儲存記憶體位址，一般的變數加上＆就會變成顯示記憶體位址，而指標在加上＊或＊＊就會顯示所儲存記憶體的儲存值。void只儲存記憶體位址，所以無法顯示所儲存記憶體的儲存值，需要先轉換數值或字串。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int **a,*b,c=1;//儲存數值的記憶體位址 char **d,*e,f=\u0026#39;A\u0026#39;;//儲存字串的記憶體位址 void **g,*h;//儲存任意的記憶體位址 //int b=\u0026amp;c;//b儲存c記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,*b); a=\u0026amp;b;//a儲存b記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,**a); //char e=\u0026amp;f;//e儲存f記憶體位址 printf(\u0026#34;p:%c\\n\u0026#34;,*e); d=\u0026amp;e;//d儲存e記憶體位址 printf(\u0026#34;p:%c\\n\u0026#34;,**d); //void h=\u0026amp;c;//h儲存c記憶體位址 g=\u0026amp;h;//g儲存h記憶體位址 h=\u0026amp;f;//h儲存f記憶體位址 g=\u0026amp;h;//g儲存h記憶體位址 return 0; } 指標的其他使用方式\n#include \u0026lt;stdio.h\u0026gt; int main(){ char a=\u0026#39;a\u0026#39;,b=\u0026#39;b\u0026#39;; int c[]={1,2,3,4,5}; printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;a); printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;b); printf(\u0026#34;p:%c\\n\u0026#34;,*(\u0026amp;b+1));//下一位的記憶體 printf(\u0026#34;p:%c\\n\u0026#34;,*(\u0026amp;a-1));//上一位的記憶體 printf(\u0026#34;p:%d\\n\u0026#34;,c);//陣列第一筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[0]);//第一筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[1]);//第二筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[2]);//第三筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[3]);//第四筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[4]);//第五筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,(\u0026amp;c+1));//陣列下一個的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,*(\u0026amp;c+1)-c); /*用陣列下一個的記憶體位址，減掉陣列第一筆的記憶體位址。 要加上＊不然會有錯誤錯誤為int (*)[5]\u0026#39; and \u0026#39;int *\u0026#39; are not pointers to compatible types。*/ return 0; } 結果\np:1830138555 p:1830138554 p:a p:b p:1830138560 p:1830138560 p:1830138564 p:1830138568 p:1830138572 p:1830138576 p:1830138580 p:5 ","permalink":"https://tom8760925.github.io/tomku/c/no/08/","summary":"這篇是C的練習筆記第08篇","title":"C語言的練習-指標和記憶體位址"},{"content":"陣列 這篇是C的練習筆記第07篇\n一維陣列 c的數值陣列宣告\n#include \u0026lt;stdlib.h\u0026gt; int main(){ int a[50];//創建大小為50陣列 int b[50]={1,2,3,4};//創建大小為50陣列，並輸入值 int c[]={1,2,3,4};//依照輸入值的大小創建陣列 int d[]={};//創建依照輸入值的大小創建的陣列 int *e = (int *)malloc(10*sizeof(int));//創建10個空值陣列 int *f = (int *)calloc(10,sizeof(int));//創建10個為0的陣列 int g[] = {[0] = 1,[1] = 2,[2] = 3,[3] = 4,[4] = 5};//指定收尋值 return 0; } c的字串陣列宣告\n#include \u0026lt;stdlib.h\u0026gt; int main(){ char a[50];//創建大小為50陣列 char b[50]=\u0026#34;AAA\u0026#34;;//創建大小為50陣列，並輸入值 char c[]=\u0026#34;AAA\u0026#34;;//依照輸入值的大小創建陣列 char d[]=\u0026#34;\u0026#34;;//創建依照輸入值的大小創建的陣列 char *e = (char *)malloc(10*sizeof(char));//創建10個空值陣列 char *f = (char *)calloc(10,sizeof(char));//創建10個為空的陣列 char g[] = {[0] = \u0026#39;A\u0026#39;,[1] = \u0026#39;B\u0026#39;,[2] = \u0026#39;C\u0026#39;,[3] = \u0026#39;D\u0026#39;,[4] = \u0026#39;E\u0026#39;};//指定收尋值 return 0; } c的陣列顯示\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a[]={1,5,10,15}; printf(\u0026#34;p:%d\\n\u0026#34;,*a); printf(\u0026#34;p:%d\\n\u0026#34;,a[0]); printf(\u0026#34;p:%d\\n\u0026#34;,*(a+1));//a[1] return 0; } 結果\np:1 p:1 p:5 二維陣列 c的數值陣列宣告\n#include \u0026lt;stdlib.h\u0026gt; int main(){ int a[10][10];//創建大小為50陣列 int b[10][10]={{1,2},{3,4},{5,6},{7,8}};//創建大小為10*10陣列，並輸入值 int **e = (int **)malloc(10*sizeof(int));//創建10*10個空值陣列 for(int n = 0;n\u0026lt;10;n++){ e[n] = (int *)malloc(10*sizeof(int)); } int (*f)[10][10] = malloc(sizeof(*f));//創建10*10個空值陣列 int (*g)[10] = malloc(10*sizeof(*g));//創建10*10個空值陣列 int **h = (int **)calloc(10,sizeof(int));//創建10*10個為0的陣列 for(int n = 0;n\u0026lt;10;n++){ h[n] = (int *)calloc(10,sizeof(int)); } return 0; } c的字串陣列宣告\n#include \u0026lt;stdlib.h\u0026gt; int main(){ char a[50][50];//創建大小為50*50陣列 char b[50][50]={\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;};//創建大小為50*50陣列，並輸入值 char *c[2]={\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;};//依照輸入值的大小創建陣列 char *d[]={\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;};//依照輸入值的大小創建陣列 char **e = (char **)malloc(10*sizeof(char));//創建10*10個空值陣列 for(int n = 0;n\u0026lt;10;n++){ e[n] = (char *)malloc(10*sizeof(char)); } char (*f)[10][10] = malloc(sizeof(*f));//創建10*10個空值陣列 char (*g)[10] = malloc(10*sizeof(*g));//創建10*10個空值陣列 char **h = (char **)calloc(10,sizeof(char));//創建10*10個為0的陣列 for(int n = 0;n\u0026lt;10;n++){ h[n] = (char *)calloc(10,sizeof(char)); } return 0; } c的陣列顯示\n#include \u0026lt;stdio.h\u0026gt; int main(){ char *a[2]={\u0026#34;apple\u0026#34;,\u0026#34;banana\u0026#34;}; printf(\u0026#34;p:%s\\n\u0026#34;,a[0]); printf(\u0026#34;p:%s\\n\u0026#34;,a[1]); printf(\u0026#34;p:%c\\n\u0026#34;,a[0][0]); printf(\u0026#34;p:%c\\n\u0026#34;,a[1][0]); printf(\u0026#34;p:%s\\n\u0026#34;,*a);//a[0] printf(\u0026#34;p:%s\\n\u0026#34;,*(a+1));//a[1] printf(\u0026#34;p:%c\\n\u0026#34;,*a[0]);//a[0][0] printf(\u0026#34;p:%c\\n\u0026#34;,**a);//a[0][0] printf(\u0026#34;p:%c\\n\u0026#34;,*a[1]);//a[1][0] printf(\u0026#34;p:%c\\n\u0026#34;,**(a+1));//[1]][0] printf(\u0026#34;提取第三個字p和n\\n\u0026#34;); printf(\u0026#34;p:%c\\n\u0026#34;,a[0][2]); printf(\u0026#34;p:%c\\n\u0026#34;,a[1][2]); printf(\u0026#34;p:%c\\n\u0026#34;,*(*a+2));//a[0][2] printf(\u0026#34;p:%c\\n\u0026#34;,*(*(a+1)+2));//a[1][2] return 0; } 結果\np:apple p:banana p:a p:b p:apple p:banana p:a p:a p:b p:b 提取第三個字p和n p:p p:n p:p p:n 陣列大小 c找陣列大小方法\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; int main(){ int a[]={1,2,3,4,5}; size_t sa = sizeof(a)/sizeof(int); int ia = sizeof(a)/sizeof(int); size_t sa2 = sizeof(a)/sizeof(a[0]); int ia2 = sizeof(a)/sizeof(a[0]); int length = *(\u0026amp;a + 1) - a; return 0; } 改陣列大小 c找改陣列大小方法\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; int main(){ int *a; a = (int *)malloc(10*sizeof(int));//創建10個空值陣列 int *b; b = realloc(a,sizeof(int)*20);//更改陣列大小 if(b == NULL){//檢查是否為NULL，也可以使用!b等同於b == NULL free(b); } else{ a=b; free(b); } return 0; } 釋放記憶體 c沒有像其他語言有Garbage collection，所以有些情況需要對記憶體進行釋放，使用malloc和calloc在結束時要使用free()釋放記憶體。\n#include \u0026lt;stdlib.h\u0026gt; int main(){ int *a = (int *)malloc(10*sizeof(int));//創建10個空值陣列 free(a);//釋放記憶體 return 0; } 參考資料:\n連結：Days 9: 動態記憶體分配：malloc()、calloc()、realloc()、free()，內存洩露網址：https://ithelp.ithome.com.tw/articles/10204463\n連結：malloc、free、calloc 與 realloc網址：https://openhome.cc/Gossip/CGossip/MallocFree.html\n","permalink":"https://tom8760925.github.io/tomku/c/no/07/","summary":"這篇是C的練習筆記第07篇","title":"C語言的練習-陣列"},{"content":"student 這篇是C的練習實作第02篇\n練習使用迴圈、判斷式。\n#include \u0026lt;stdio.h\u0026gt;//載入指令 #include \u0026lt;stdbool.h\u0026gt;//載入指令 void student_input();//函數宣告 int main(){ int n=0;//宣告 while (n != 2)//判斷是否結束迴圈 { printf(\u0026#34;輸入1輸入學生資料\\n輸入2離開\\n請輸入1或2:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);//輸入的值 switch (n)//判斷輸入的值 { case 1: student_input();//呼叫函數 break; case 2: printf(\u0026#34;離開\\n\u0026#34;);//結束迴圈 break; default: printf(\u0026#34;輸入錯誤\\n\u0026#34;);//輸入的值錯誤 break; } } return 0; } void student_input(){ char name[]=\u0026#34;\u0026#34;; int no=0,phone=0; printf(\u0026#34;請輸入姓名:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%s\u0026#34;,name);//輸入的值 printf(\u0026#34;姓名:%s\\n\u0026#34;,name);//顯示輸入的值 printf(\u0026#34;請輸入學號:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;no);//輸入的值 printf(\u0026#34;學號:%d\\n\u0026#34;,no);//顯示輸入的值 printf(\u0026#34;請輸入電話:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;phone);//輸入的值 printf(\u0026#34;電話:%d\\n\u0026#34;,phone);//顯示輸入的值 } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/02/","summary":"這篇是C的練習實作第02篇","title":"C語言的練習-練習實作02"},{"content":"迴圈 這篇是C的練習筆記第06篇\nfor C的for寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ for(int n = 0;n\u0026lt;5;n++) { printf(\u0026#34;p:%d\\n\u0026#34;,n); } return 0; } 結果\np:0 p:1 p:2 p:3 p:4 for的參數可以簡化\n#include \u0026lt;stdio.h\u0026gt; int main(){ int n = 0; for(;n\u0026lt;2;) { printf(\u0026#34;p:%d\\n\u0026#34;,n); n++; } return 0; } 結果\np:0 p:1 while C的while寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ int n = 0; while (n\u0026lt;5) { printf(\u0026#34;p:%d\\n\u0026#34;,n); n++; } return 0; } 結果\np:0 p:1 p:2 p:3 p:4 do while C的do while寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ int n = 0; do{ printf(\u0026#34;p:%d\\n\u0026#34;,n); } while (n != 0); return 0; } break C的break寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ for(int n = 0;n\u0026lt;5;n++) { if(n == 2){ break; } printf(\u0026#34;p:%d\\n\u0026#34;,n); } return 0; } 結果\np:0 p:1 continue C的continue寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ for(int n = 0;n\u0026lt;5;n++) { if(n == 2){ continue; } printf(\u0026#34;p:%d\\n\u0026#34;,n); } return 0; } 結果\np:0 p:1 p:3 p:4 for可以寫這樣\n#include \u0026lt;stdio.h\u0026gt; int main(){ for(int a = 1,b = 1;a\u0026lt;=9;a++,b++) { printf(\u0026#34;%d*%d=%d\\n\u0026#34;,a,b,a*b); } return 0; } 結果\n1*1=1 2*2=4 3*3=9 4*4=16 5*5=25 6*6=36 7*7=49 8*8=64 9*9=81 ","permalink":"https://tom8760925.github.io/tomku/c/no/06/","summary":"這篇是C的練習筆記第06篇","title":"C語言的練習-迴圈"},{"content":"student 這篇是C的練習實作第01篇\n練習使用函式宣告，輸入姓名、學號、電話，並顯示出來。\n#include \u0026lt;stdio.h\u0026gt;//載入指令 void student_input();//函數宣告 int main(){ student_input();//呼叫函數 return 0; } void student_input(){ char name[]=\u0026#34;\u0026#34;; int no=0,phone=0; printf(\u0026#34;請輸入姓名:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%s\u0026#34;,name);//輸入的值 printf(\u0026#34;姓名:%s\\n\u0026#34;,name);//顯示輸入的值 printf(\u0026#34;請輸入學號:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;no);//輸入的值 printf(\u0026#34;學號:%d\\n\u0026#34;,no);//顯示輸入的值 printf(\u0026#34;請輸入電話:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;phone);//輸入的值 printf(\u0026#34;電話:%d\\n\u0026#34;,phone);//顯示輸入的值 } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/01/","summary":"這篇是C的練習實作第01篇","title":"C語言的練習-練習實作01"},{"content":"if 這篇是C的練習筆記第05篇\nC的if寫法是\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(){ bool p = true; if(p){ printf(\u0026#34;p:%s\\n\u0026#34;,p?\u0026#34;true\u0026#34;:\u0026#34;fales\u0026#34;); } else{ printf(\u0026#34;p:%s\\n\u0026#34;,p?\u0026#34;true\u0026#34;:\u0026#34;fales\u0026#34;); } return 0; } 結果\np:true if也可以寫成這樣\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(){ bool p = false; p = (2\u0026gt;1)?true:false; printf(\u0026#34;p:%s\\n\u0026#34;,p?\u0026#34;true\u0026#34;:\u0026#34;fales\u0026#34;); return 0; } 結果\np:true 多條件if\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a=1,b=2; if(a\u0026lt;b){ printf(\u0026#34;p:%d\u0026lt;%d\\n\u0026#34;,a,b); } else if(a\u0026gt;b) { printf(\u0026#34;p:%d\u0026gt;%d\\n\u0026#34;,a,b); } else{ printf(\u0026#34;p:%d=%d\\n\u0026#34;,a,b); } return 0; } 結果\np:1\u0026lt;2 多條件還有\n#include \u0026lt;stdio.h\u0026gt; int main(){ char n=\u0026#39;a\u0026#39;; switch (n) { case \u0026#39;a\u0026#39;: printf(\u0026#34;p:apple\\n\u0026#34;); break; case \u0026#39;b\u0026#39;: printf(\u0026#34;p:banana\\n\u0026#34;); break; default: printf(\u0026#34;p:error\\n\u0026#34;); break; } return 0; } 結果\np:apple ","permalink":"https://tom8760925.github.io/tomku/c/no/05/","summary":"這篇是C的練習筆記第05篇","title":"C語言的練習-if"},{"content":"printf 和 scanf 這篇是C的練習筆記第04篇\nc的輸入和輸出分別為scanf 和 printf\n要使用需要加上最上面\n#include \u0026lt;stdio.h\u0026gt; printf c輸出是使用printf，要使用printf也需要設定資料型態和變數。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a=1; printf(\u0026#34;p:%d\\n\u0026#34;,a); return 0; } 結果\np:1 型態 在使用printf時，需要設定資料型態，而型態有好幾種。\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;十進位:%d\\n\u0026#34;,16); printf(\u0026#34;十進制無符號:%u\\n\u0026#34;,16); printf(\u0026#34;十進位浮點數:%f\\n\u0026#34;,16.16); printf(\u0026#34;八進位:%o\\n\u0026#34;,16); printf(\u0026#34;十六進位:%x\\n\u0026#34;,16); printf(\u0026#34;十六進位浮點數:%a\\n\u0026#34;,16.16); printf(\u0026#34;指數:%e\\n\u0026#34;,16.16); printf(\u0026#34;判斷使用%%f和%%e，哪個以較短較精簡能夠輸出:%g\\n\u0026#34;,16.16); printf(\u0026#34;單一字元:%c\\n\u0026#34;,\u0026#39;A\u0026#39;); printf(\u0026#34;字串:%s\\n\u0026#34;,\u0026#34;AA\u0026#34;); char a[] = \u0026#34;AA\u0026#34;; printf(\u0026#34;記憶體位置:%p\\n\u0026#34;,a); printf(\u0026#34;專門是unsigned long:%lu\\n\u0026#34;,(unsigned long)16); printf(\u0026#34;專門是unsigned long long:%llu\\n\u0026#34;,(unsigned long long)16); printf(\u0026#34;%%:%%A\\n\u0026#34;); return 0; } 結果\n十進位:16 十進制無符號:16 十進位浮點數:16.160000 八進位:20 十六進位:10 十六進位浮點數:0x1.028f5c28f5c29p+4 指數:1.616000e+01 判斷使用%f和%e，哪個以較短較精簡能夠輸出:16.16 單一字元:A 字串:AA 記憶體位置:0x16fdff048 專門是unsigned long:16 專門是unsigned long long:16 %:%A printf設定 printf可以設定如何顯示\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;加上.和要顯示第幾位，設定四捨五入:%.2f\\n\u0026#34;,16.1666); printf(\u0026#34;加上.和要顯示第幾位:%.2s\\n\u0026#34;,\u0026#34;AAA\u0026#34;); printf(\u0026#34;加上數字，預留字元有少就補空格:%3d\\n\u0026#34;,16);//預留３個字元 printf(\u0026#34;加上數字，預留字元有少就補空格:%10f\\n\u0026#34;,16.16);//預留10個字元 printf(\u0026#34;加上數字，預留字元有少就補空格:%2c\\n\u0026#34;,\u0026#39;A\u0026#39;);//預留2個字元 printf(\u0026#34;加上數字，預留字元有少就補空格:%3s\\n\u0026#34;,\u0026#34;AA\u0026#34;);//預留3個字元 printf(\u0026#34;加上0和數字，預留字元有少就補0:%03d\\n\u0026#34;,16); printf(\u0026#34;加上*，預留字元有少就補空格:%*d\\n\u0026#34;,3,16); printf(\u0026#34;加上*，預留字元有少就補空格:%*d|%*d\\n\u0026#34;,3,16,3,16); printf(\u0026#34;加上負號，在預留字元範圍內靠左對齊:%-3d\\n\u0026#34;,16); printf(\u0026#34;加上+，顯示正負號:%+3d\\n\u0026#34;,16); printf(\u0026#34;加上空格，在前面加上空格:% d\\n\u0026#34;,16); printf(\u0026#34;加上#，在x、o前面加上0x非0值情況時:%#x\\n\u0026#34;,16); return 0; } 結果\n加上.和要顯示第幾位，設定四捨五入:16.17 加上.和要顯示第幾位:AA 加上數字，預留字元有少就補空格: 16 加上數字，預留字元有少就補空格: 16.160000 加上數字，預留字元有少就補空格: A 加上數字，預留字元有少就補空格: AA 加上0和數字，預留字元有少就補0:016 加上*，預留字元有少就補空格: 16 加上*，預留字元有少就補空格: 16| 16 加上負號，在預留字元範圍內靠左對齊:16 加上+，顯示正負號:+16 加上空格，在前面加上空格: 16 加上#，在x、o前面加上0x非0值情況時:0x10 scenf c輸入是使用scenf，要使用scanf需要設定資料型態和變數記憶體位置。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a=0; printf(\u0026#34;s:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); printf(\u0026#34;s:%d\\n\u0026#34;,a); return 0; } 結果\ns:1 s:1 型態 在使用scanf時，需要設定資料型態，而型態有好幾種。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 0; unsigned int e = 0; float b = 0; double f = 0; char c = \u0026#39;A\u0026#39;; char d[] = \u0026#34;\u0026#34;; void *g = NULL; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a);//十進位 scanf(\u0026#34;%u\u0026#34;,\u0026amp;e);//十進制無符號 scanf(\u0026#34;%f\u0026#34;,\u0026amp;b);//十進位浮點數 scanf(\u0026#34;%lf\u0026#34;,\u0026amp;f);//十進位浮點數 scanf(\u0026#34;%o\u0026#34;,\u0026amp;a);//八進位 scanf(\u0026#34;%x\u0026#34;,\u0026amp;a);//十六進位 scanf(\u0026#34;%i\u0026#34;,\u0026amp;a);//十進位八進位十六進位 scanf(\u0026#34;%a\u0026#34;,\u0026amp;b);//浮點數 scanf(\u0026#34;%e\u0026#34;,\u0026amp;b);//指數 scanf(\u0026#34;%g\u0026#34;,\u0026amp;b);//判斷使用%%f和%%e，哪個比較短較精簡 scanf(\u0026#34;%c\u0026#34;,\u0026amp;c);//單一字元 scanf(\u0026#34;%s\u0026#34;,d);//字串 scanf(\u0026#34;%p\u0026#34;,\u0026amp;g);//記憶體位置 return 0; } scanf設定 scanf的輸入可以設定\n#include \u0026lt;stdio.h\u0026gt; int main(){ char a[] = \u0026#34;\u0026#34;,b[3],c,d; scanf(\u0026#34;%[1-5]\u0026#34;,a); //設定輸入範圍，這樣設定會限制只能輸入1到5，輸入136只接收13，但輸入1363只接收13 scanf(\u0026#34;%[^1-5]\u0026#34;,a); //加上^，改為排除 scanf(\u0026#34;%2s\u0026#34;,b);//限制輸入字元 scanf(\u0026#34;%c-%c\u0026#34;,c,d); //輸入多個值，需要設定字元中間的區隔，這裡使用-在輸入值時需要依照設定區隔，沒有設定也會自動區隔。 return 0; } 其他 除了使用scanf 和 printf，還有其他可以用\n#include \u0026lt;stdio.h\u0026gt; int main(){ char a[50]; getchar();//輸入字元並只傳出一個字元 fgets(a,sizeof(a),stdin);//輸入字串 putchar(\u0026#39;A\u0026#39;);//只能輸出字char putchar(65);//會轉換ASCII得到Ａ puts(\u0026#34;AAA\u0026#34;);//輸出字串 return 0; } 跳脫字元 #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;\\\\n:A\\n\u0026#34;);//換行 printf(\u0026#34;\\\\t:\\tA\\n\u0026#34;);//tab printf(\u0026#34;\\\\b:\\bA\\n\u0026#34;);//backspace printf(\u0026#34;\\\\r:\\rABC\\n\u0026#34;); printf(\u0026#34;\\\\f:\\fA\\n\u0026#34;);//跳到下一行 printf(\u0026#34;\\\\\u0026#39;:\\\u0026#39;A\\n\u0026#34;); printf(\u0026#34;\\\\\\\u0026#34;:\\\u0026#34;A\\n\u0026#34;); printf(\u0026#34;\\\\:\\\\A\\n\u0026#34;); return 0; } 結果\n\\n:A \\t:\tA \\bA ABC \\f: A \\\u0026#39;:\u0026#39;A \\\u0026#34;:\u0026#34;A \\:\\A 參考資料:\n連結：C 标准库 – | 菜鸟教程網址：https://www.runoob.com/cprogramming/c-standard-library-stdio-h.html\n","permalink":"https://tom8760925.github.io/tomku/c/no/04/","summary":"這篇是C的練習筆記第04篇","title":"C語言的練習-printf 和 scanf"},{"content":"第一個程式 這篇是C的練習筆記第03篇\n起始程式 C跟其他程式一樣都有起始程式\nint main(){ return 0; } 最前面是回傳的型態\n程式結束時需要回傳0代表程式正常結束\n函數 如果沒有要回傳函數，在回傳的型態使用void\n在使用函數前，C是需要在起始程式前加上函數宣告\n#include \u0026lt;stdio.h\u0026gt; int test(int n); int main(){ int a = 0; a = test(1); printf(\u0026#34;p:%d\\n\u0026#34;,a); return 0; } int test(int n){ return n; } 結果\np:1 這樣程式在執行程式就知道有test的函數\n遞迴 C也有遞迴，a會等於5\n#include \u0026lt;stdio.h\u0026gt; int test(int n); int main(){ int a = 0; a = test(0); printf(\u0026#34;p:%d\\n\u0026#34;,a); return 0; } int test(int n){ n++; if(n == 5){ return n; } else{ return test(n); } } 結果\np:5 ","permalink":"https://tom8760925.github.io/tomku/c/no/03/","summary":"這篇是C的練習筆記第03篇","title":"C語言的練習-第一個程式"},{"content":"型態 這篇是C的練習筆記第02篇 記錄C有哪些型態 在型態前面加上unsigned，會變強制沒有負號\n種類 名稱 記憶體空間 加unsigned 數值 int 4 Bytes 可 short 2 Bytes 可 long 4 Bytes 可 浮點數 float 4 Bytes 不可 double 8 Bytes 不可 字元 char 1 Bytes 可 C也有bool但要加上\n#include \u0026lt;stdbool.h\u0026gt; 才能使用bool\n但使用printf無法直接顯示ture 或 false，需要使用其他方法，而其中一個方法。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(){ bool p = true; printf(\u0026#34;p:%s\\n\u0026#34;,p?\u0026#34;true\u0026#34;:\u0026#34;fales\u0026#34;); return 0; } 結果\np:true c使用void其中一個方法是存放記憶體位置，p會存放a的記憶體位置。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 11; void *p; p = \u0026amp;a; printf(\u0026#34;p:%p\\n\u0026#34;,\u0026amp;a); printf(\u0026#34;p:%p\\n\u0026#34;,p); printf(\u0026#34;p:%p\\n\u0026#34;,\u0026amp;p); return 0; } 結果\np:0x16f37f2d8 p:0x16f37f2d8 p:0x16f37f2d0 ","permalink":"https://tom8760925.github.io/tomku/c/no/02/","summary":"這篇是C的練習筆記第02篇","title":"C語言的練習-型態"},{"content":"環境設置 這篇是C的練習筆記第01篇\n以下是在MAC進行操作執行\n安裝VSCODE 去以下網址下載VSCODE\nhttps://code.visualstudio.com/ 安裝VSCODE插建 安裝C的插件\nhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack 繁體插件\nhttps://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hant 起始設定 先在程式資料夾中新增檔案，名子隨意副檔名為.c\n點選新增的.C檔案，再點選右上角齒輪\nC/C++:clang 建置及偵錯使用中的檔案 就會新增2個json欓 接著在收尋欄輸入\n\u0026gt;c/c++:Edit Configurations(JSON) 點選後會新增一個JSON檔案\n啟動測試 接著就能執行程式偵錯 有兩個方式可以偵錯\n1.直接點上方的執行-\u0026gt;進行偵錯 但這個方法在使用scanf，輸入時會有問題，可以在launch.json裡面修改參數externalConsole改成true，就會額外乎叫終端機視窗。 2.點右邊上三角形下拉選點單，選CompileRun : Compile with default flags \u0026amp; Run with default arguments，就能直接在vscode裡的終端機進行操作，使用scanf輸入也不會有問題。 沒問題就能直接執行.C檔案\n有問題可能是因為.C檔案內沒有程式，可以先寫個起始程式，應該就能執行。\nint main(){ return 0; } 參考資料:\n連結：Configure VS Code for Clang/LLVM on macOS網址：https://code.visualstudio.com/docs/cpp/config-clang-mac\n","permalink":"https://tom8760925.github.io/tomku/c/no/01/","summary":"這篇是C的練習筆記第01篇","title":"C語言的練習-環境設置"}]