[{"content":"C++語言的練習-重點練習08 這篇是C++練習-重點練習07篇\nstrcpy 和 memcpy 的重點\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { const char *str1 = \u0026#34;abcde\\0f\u0026#34;; char str2[16]; char str3[16]; std::cout \u0026lt;\u0026lt; \u0026#34;str1:\u0026#34; \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;----------\\n\u0026#34;; // 只複製到\\0之前 strcpy(str2, str1); std::cout \u0026lt;\u0026lt; \u0026#34;str2:\u0026#34; \u0026lt;\u0026lt; str2[6] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;----------\\n\u0026#34;; // 全部都複製 memcpy(str3, str1, sizeof(str1)); std::cout \u0026lt;\u0026lt; \u0026#34;str2:\u0026#34; \u0026lt;\u0026lt; str3[6] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; return 0; } 結果\nstr1:abcde ---------- str2: ---------- str2:f ","permalink":"https://tom8760925.github.io/tomku/c++/practice/focus08/","summary":"這篇是C++練習-重點練習08篇","title":"C++語言的練習-重點練習08"},{"content":"C++語言的練習-重點練習07 這篇是C++練習-重點練習07篇\n++的重點\n#include \u0026lt;iostream\u0026gt; int main() { int i = 1; // 後做 std::cout \u0026lt;\u0026lt; \u0026#34;後做\\n\u0026#34;; // 會先執行cout\u0026lt;\u0026lt;i，後在執行i+1 std::cout \u0026lt;\u0026lt; \u0026#34;i:\u0026#34; \u0026lt;\u0026lt; i++ \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;i:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; // 前做 std::cout \u0026lt;\u0026lt; \u0026#34;前做\\n\u0026#34;; // 會先執行i+1，後執行cout\u0026lt;\u0026lt;i std::cout \u0026lt;\u0026lt; \u0026#34;i:\u0026#34; \u0026lt;\u0026lt; ++i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;i:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; return 0; } 結果\n後做 i:1 i:2 ------- 前做 i:3 i:3 ","permalink":"https://tom8760925.github.io/tomku/c++/practice/focus07/","summary":"這篇是C++練習-重點練習07篇","title":"C++語言的練習-重點練習07"},{"content":"C++語言的練習-重點練習06 這篇是C++練習-重點練習06篇\nvolatile和inline 的重點 跟編譯器有關\n#include \u0026lt;iostream\u0026gt; // 跟編譯器有關的 inline int func(int i) { return i + 1; } int main() { // 易變的 跟編譯器有關的 volatile int i = 1; int a = i; // 在編譯器可能會變成a=1，但如果用volatile，就會強制變成a=i; std::cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; // 在編譯器會調用函數，但如果用inline，會可能變成i + 1 std::cout \u0026lt;\u0026lt; \u0026#34;func:\u0026#34; \u0026lt;\u0026lt; func(i) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; return 0; } 結果\na:1 -------- func:2 ","permalink":"https://tom8760925.github.io/tomku/c++/practice/focus06/","summary":"這篇是C++練習-重點練習06篇","title":"C++語言的練習-重點練習06"},{"content":"C++語言的練習-重點練習05 這篇是C++練習-重點練習05篇\nstatic的重點\n#include \u0026lt;iostream\u0026gt; // 變數 void func1(int x) { static int xx = 0; xx += x; printf(\u0026#34;xx:%d\\n\u0026#34;, xx); } // static member variable class a { public: static void setax(int x) { ax += x; } static int getax() { return ax; } private: static int ax; }; int a::ax = 0; // class class b { public: void setbx(int x) { bx += x; } int getbx() { return bx; } private: int bx = 0; }; void func2(int x) { static b bb; bb.setbx(x); printf(\u0026#34;bx:%d\\n\u0026#34;, bb.getbx()); } int main() { printf(\u0026#34;變數\\n\u0026#34;); func1(1); func1(1); func1(1); printf(\u0026#34;----------\\n\u0026#34;); printf(\u0026#34;static member variable\\n\u0026#34;); a::setax(1); printf(\u0026#34;pa:%d\\n\u0026#34;, a::getax()); a::setax(1); printf(\u0026#34;pa:%d\\n\u0026#34;, a::getax()); a::setax(1); printf(\u0026#34;pa:%d\\n\u0026#34;, a::getax()); printf(\u0026#34;---------\\n\u0026#34;); printf(\u0026#34;class\\n\u0026#34;); func2(1); func2(1); func2(1); return 0; } 結果\n變數 xx:1 xx:2 xx:3 ---------- static member variable pa:1 pa:2 pa:3 --------- class bx:1 bx:2 bx:3 ","permalink":"https://tom8760925.github.io/tomku/c++/practice/focus05/","summary":"這篇是C++練習-重點練習05篇","title":"C++語言的練習-重點練習05"},{"content":"C++語言的練習-重點練習04 這篇是C++練習-重點練習04篇\ncall-by的重點\n#include \u0026lt;iostream\u0026gt; // call-by-value int func1(int a, int b) { a++; b++; return a + b; } // call-by-reference 指標 int func2(int *a, int *b) { *a = *a + 1; *b = *b + 1; return *a + *b; } // call-by-reference 參考 int func3(int \u0026amp;a, int \u0026amp;b) { a = a + 1; b = b + 1; return a + b; } int main() { int a = 1; int b = 1; std::cout \u0026lt;\u0026lt; \u0026#34;a、b:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;、\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;func1:\u0026#34; \u0026lt;\u0026lt; func1(a, b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;a、b:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;、\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;a、b:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;、\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;func1:\u0026#34; \u0026lt;\u0026lt; func2(\u0026amp;a, \u0026amp;b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;a、b:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;、\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;a、b:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;、\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;func1:\u0026#34; \u0026lt;\u0026lt; func3(a, b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;a、b:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;、\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 結果\na、b:1、1 func1:4 a、b:1、1 ------- a、b:1、1 func2:4 a、b:2、2 ------- a、b:2、2 func3:6 a、b:3、3 ","permalink":"https://tom8760925.github.io/tomku/c++/practice/focus04/","summary":"這篇是C++練習-重點練習04篇","title":"C++語言的練習-重點練習04"},{"content":"C++語言的練習-重點練習03 這篇是C++練習-重點練習03篇\n指標的重點\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // function 指標不輸出值 void func1(std::string s, int i) { std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void (*funcp1)(std::string, int); void (*funcp2)(std::string, int) = \u0026amp;func1; // function 指標輸出值 int func2(int i) { return i; } int (*funcp3)(int); int (*funcp4)(int) = \u0026amp;func2; // function array void func3(std::string s, int i) { std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void func4(std::string s, int i) { std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void func5(std::string s, int i) { std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void (*funca1[])(std::string s, int i) = {\u0026amp;func3, \u0026amp;func4, \u0026amp;func5}; int main() { int a = 1; int ar[10] = {1, 2, 3, 4}; // 指標 int *b = \u0026amp;a; // 指標的指標 int **c = \u0026amp;b; // 存儲10個指標的陣列 int *d[10]; // 存儲陣列指標 int(*e)[10]; std::cout \u0026lt;\u0026lt; \u0026#34;b:\u0026#34; \u0026lt;\u0026lt; *b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;c:\u0026#34; \u0026lt;\u0026lt; **c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; d[0] = \u0026amp;a; std::cout \u0026lt;\u0026lt; \u0026#34;d:\u0026#34; \u0026lt;\u0026lt; *d[0] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; e = \u0026amp;ar; std::cout \u0026lt;\u0026lt; \u0026#34;e:\u0026#34; \u0026lt;\u0026lt; **e \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;e:\u0026#34; \u0026lt;\u0026lt; *(*e + 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;e:\u0026#34; \u0026lt;\u0026lt; e[0][0] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;e:\u0026#34; \u0026lt;\u0026lt; e[0][1] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;function 指標不輸出值\\n\u0026#34;; func1(\u0026#34;func1\u0026#34;, 1); std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; funcp1 = \u0026amp;func1; funcp1(\u0026#34;funcp1\u0026#34;, 1); std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; funcp2(\u0026#34;funcp2\u0026#34;, 1); std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;function 指標輸出值\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;func2:\u0026#34; \u0026lt;\u0026lt; func2(1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; funcp3 = \u0026amp;func2; std::cout \u0026lt;\u0026lt; \u0026#34;funcp3:\u0026#34; \u0026lt;\u0026lt; funcp3(1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;funcp4:\u0026#34; \u0026lt;\u0026lt; funcp4(1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;function array\\n\u0026#34;; funca1[0](\u0026#34;func3\u0026#34;, 1); std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; funca1[1](\u0026#34;func4\u0026#34;, 1); std::cout \u0026lt;\u0026lt; \u0026#34;-------\\n\u0026#34;; funca1[2](\u0026#34;func5\u0026#34;, 1); std::cout \u0026lt;\u0026lt; std::endl; return 0; } 結果\nb:1 ------- c:1 ------- d:1 ------- e:1 e:2 e:1 e:2 ------- function 指標不輸出值 func1:1 ------- funcp1:1 ------- funcp2:1 function 指標輸出值 func2:1 ------- funcp3:1 ------- funcp4:1 function array func3:1 ------- func4:1 ------- func5:1 ","permalink":"https://tom8760925.github.io/tomku/c++/practice/focus03/","summary":"這篇是C++練習-重點練習03篇","title":"C++語言的練習-重點練習03"},{"content":"C++語言的練習-重點練習02 這篇是C++練習-重點練習02篇\nconst 的重點\nint main() { const int a = 1; // 值不能改 int const b = 2; // 值不能改 int aa = 1; const int *c = \u0026amp;aa; // 不能改值，能改指標 int *const d = \u0026amp;aa; // 能改值，不能改指標 const int *const e = \u0026amp;aa; // 不能改值，不能改指標 return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/practice/focus02/","summary":"這篇是C++練習-重點練習02篇","title":"C++語言的練習-重點練習02"},{"content":"C++語言的練習-重點練習01 這篇是C++練習-重點練習01篇\nclass 重點有繼承和建構函數和解構函式\n#include \u0026lt;iostream\u0026gt; class a { public: a() { std::cout \u0026lt;\u0026lt; \u0026#34;a\\n\u0026#34;; } a(int k, int v) { this-\u0026gt;k = k; this-\u0026gt;v = v; std::cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;k \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;v \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~a() { std::cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;k \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;v \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;k + this-\u0026gt;v \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } private: int k = 0; int v = 0; }; class b : public a { public: b() { std::cout \u0026lt;\u0026lt; \u0026#34;b\\n\u0026#34;; } b(int k, int v) { this-\u0026gt;k = k; this-\u0026gt;v = v; std::cout \u0026lt;\u0026lt; \u0026#34;b:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;k \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;v \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ~b() { std::cout \u0026lt;\u0026lt; \u0026#34;b:\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;k \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;v \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;k + this-\u0026gt;v \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } private: int k = 0; int v = 0; }; int main() { a *aa1 = new a; delete aa1; std::cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; a *aa2 = new a(1, 2); delete aa2; std::cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; a *aa3 = new b; delete aa3; std::cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; a *aa4 = new b; delete aa4; std::cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; b *bb1 = new b(); delete bb1; std::cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; b *bb2 = new b(1, 2); delete bb2; return 0; } 結果\na a:0+0=0 -------- a:1,2 a:1+2=3 -------- a b a:0+0=0 -------- a b a:0+0=0 -------- a b b:0+0=0 a:0+0=0 -------- a b:1,2 b:1+2=3 a:0+0=0 ","permalink":"https://tom8760925.github.io/tomku/c++/practice/focus01/","summary":"這篇是C++練習-重點練習01篇","title":"C++語言的練習-重點練習01"},{"content":"sys/un.h 這篇是C++的筆記第27篇\nlinux限定，使用Unix domain socket\n#include \u0026lt;sys/un.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int main() { // 宣告 sockaddr_un s; // 設定型態 s.sun_family = AF_UNIX; // Unix domain socket的路徑 // s.sun_path = ; return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/notes/27/","summary":"這篇是C++的筆記第27篇","title":"C++語言的筆記-sys/un.h"},{"content":"netinet/in.h 這篇是C++的筆記第26篇\n儲存網路資訊\n#include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { // 一般不使用 // 宣告 sockaddr s; // 設定型態ipv4 s.sa_family = AF_INET; // 設定長度 s.sa_len = NULL; // 設定ip+port+zero // s.sa_data = ; // 宣告ipv4 sockaddr_in s4; // 設定ip s4.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 設定型態ipv4 s4.sin_family = AF_INET; // 設定port號 s4.sin_port = htons(8080); // 保留不使用 // s4.sin_zero =; // 設定型態長度 s4.sin_len = NULL; return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/notes/26/","summary":"這篇是C++的筆記第26篇","title":"C++語言的筆記-netinet/in.h"},{"content":"建構函數和解構函式 這篇是C++的筆記第25篇\n有使用建構函數時，建構時會使用。\n#include \u0026lt;iostream\u0026gt; using namespace std; class a { public: // 建構函數 a() { cout \u0026lt;\u0026lt; \u0026#34;a\\n\u0026#34;; } }; class b : public a { public: // 建構函數 b() { cout \u0026lt;\u0026lt; \u0026#34;b\\n\u0026#34;; } }; int main() { // 建立函數 a *aa = new a; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; a *aaa = new b; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; // 不能是b *bb = new a; b *bb = new b; cout \u0026lt;\u0026lt; endl; return 0; } 結果\na -------- a b -------- a b 而解構韓式跟建構函數相反，解構時使用。\n#include \u0026lt;iostream\u0026gt; using namespace std; class a { public: // 建構函數 a() { cout \u0026lt;\u0026lt; \u0026#34;a\\n\u0026#34;; } // 解構函數 ~a() { cout \u0026lt;\u0026lt; \u0026#34;aa\\n\u0026#34;; } }; class b : public a { public: // 建構函數 b() { cout \u0026lt;\u0026lt; \u0026#34;b\\n\u0026#34;; } // 解構函數 ~b() { cout \u0026lt;\u0026lt; \u0026#34;bb\\n\u0026#34;; } }; int main() { // 建立函數 a *aa = new a; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; delete aa; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; a *aaa = new b; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; delete aaa; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; // 不能是b *bb = new a; b *bb = new b; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; delete bb; cout \u0026lt;\u0026lt; endl; return 0; } 結果\na -------- aa -------- a b -------- aa -------- a b -------- bb aa ","permalink":"https://tom8760925.github.io/tomku/c++/notes/25/","summary":"這篇是C++的筆記第25篇","title":"C++語言的筆記-建構函數和解構函式"},{"content":"minecraft mod GatherData新增資料檔案02 這篇是minecraft mod GatherData新增資料檔案02的筆記\n修改json格式\n1.宣告type package tom8760925.tomkumr.data.tomkumr; import java.util.ArrayList; public class tomkumrDataClass { private String[] life; private String[] flutter; private ArrayList\u0026lt;tomkumrDataClass\u0026gt; list; public tomkumrDataClass(String[] life, String[] flutter) { this.life = life; this.flutter = flutter; } public tomkumrDataClass(String[] life, String[] flutter, ArrayList\u0026lt;tomkumrDataClass\u0026gt; list) { this.life = life; this.flutter = flutter; this.list = list; } public String[] getLife() { return life; } public void setLife(String[] life) { this.life = life; } public String[] getFlutter() { return flutter; } public void setFlutter(String[] flutter) { this.flutter = flutter; } public ArrayList\u0026lt;tomkumrDataClass\u0026gt; getList() { return list; } public void setList(ArrayList\u0026lt;tomkumrDataClass\u0026gt; list) { this.list = list; } } 2.建立參考 package tom8760925.tomkumr.data.tomkumr; public enum tomkumrdatatype { Profession(\u0026#34;profession\u0026#34;); public String id; tomkumrdatatype(String id) { this.id = id; } } 3.資料提供 package tom8760925.tomkumr.data.tomkumr; import net.minecraft.data.PackOutput; import tom8760925.tomkumr.Modinfo; import java.util.ArrayList; import java.util.LinkedHashMap; public class tomkumrDataProvider extends tomkumrProvider { //宣告起始 public tomkumrDataProvider(PackOutput output, String modid, String locale,String finction) { super(output, modid, locale, finction); } //新增資料設定 @Override protected void addDataConffig() { //新增資料 this.add(\u0026#34;type\u0026#34;, Modinfo.MODID); this.add(tomkumrdatatype.Profession.id, new tomkumrDataClass(new String[]{\u0026#34;Farmer\u0026#34;}, new String[]{\u0026#34;x\u0026#34;})); ArrayList\u0026lt;tomkumrDataClass\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new tomkumrDataClass(new String[]{\u0026#34;aaa\u0026#34;}, new String[]{\u0026#34;bb\u0026#34;})); list.add(new tomkumrDataClass(new String[]{\u0026#34;bbb\u0026#34;}, new String[]{\u0026#34;cc\u0026#34;})); this.add(\u0026#34;Profession1\u0026#34;,list); } } 4.資料提供 package tom8760925.tomkumr.data.tomkumr; import com.google.gson.Gson; import com.google.gson.JsonObject; import net.minecraft.data.CachedOutput; import net.minecraft.data.DataProvider; import net.minecraft.data.PackOutput; import org.jetbrains.annotations.NotNull; import tom8760925.tomkumr.Modinfo; import java.nio.file.Path; import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.concurrent.CompletableFuture; public abstract class tomkumrProvider implements DataProvider { //宣告 private final LinkedHashMap\u0026lt;Object, Object\u0026gt; data = new LinkedHashMap\u0026lt;\u0026gt;(); private final PackOutput output; private final String modid; private final String locale; private final String finction; //宣告起始 public tomkumrProvider(PackOutput output, String modid, String locale,String finction) { this.output = output; this.modid = modid; this.locale = locale; this.finction = finction; } //宣告抽象函數 protected abstract void addDataConffig(); //使用 @Override public CompletableFuture\u0026lt;?\u0026gt; run(CachedOutput cache) { //使用抽象函數 addDataConffig(); //判斷data if (!data.isEmpty()) //呼叫函數 return save(cache, this.output.getOutputFolder(PackOutput.Target.DATA_PACK/*設定在data資料夾裡*/).resolve(this.modid).resolve(this.finction).resolve(this.locale + \u0026#34;.json\u0026#34;)); return CompletableFuture.allOf(); } //儲存的資料及位子 private CompletableFuture\u0026lt;?\u0026gt; save(CachedOutput cache, Path target) { Gson gson = new Gson(); //轉換json JsonObject json = gson.fromJson(gson.toJson(data), JsonObject.class); return DataProvider.saveStable(cache, json, target); } //名稱 @Override public @NotNull String getName() { return Modinfo.MODID +\u0026#34;: \u0026#34; + locale; } //新增資料 public void add(String key, String value) { if (data.put(key, value) != null) throw new IllegalStateException(\u0026#34;Duplicate translation key \u0026#34; + key); } public void add(String key, tomkumrDataClass value) { if (data.put(key, value) != null) throw new IllegalStateException(\u0026#34;Duplicate translation key \u0026#34; + key); } public void add(String key, ArrayList\u0026lt;tomkumrDataClass\u0026gt; value) { if (data.put(key, value) != null) throw new IllegalStateException(\u0026#34;Duplicate translation key \u0026#34; + key); } } 5.檔案 { \u0026#34;type\u0026#34;: \u0026#34;tomkumr\u0026#34;, \u0026#34;Profession1\u0026#34;: [ { \u0026#34;Flutter\u0026#34;: [ \u0026#34;bb\u0026#34; ], \u0026#34;life\u0026#34;: [ \u0026#34;aaa\u0026#34; ] }, { \u0026#34;Flutter\u0026#34;: [ \u0026#34;cc\u0026#34; ], \u0026#34;life\u0026#34;: [ \u0026#34;bbb\u0026#34; ] } ], \u0026#34;profession\u0026#34;: { \u0026#34;Flutter\u0026#34;: [ \u0026#34;x\u0026#34; ], \u0026#34;life\u0026#34;: [ \u0026#34;Farmer\u0026#34; ] } } ","permalink":"https://tom8760925.github.io/tomku/other/notes/minecraft06/","summary":"這篇是minecraft mod GatherData新增資料檔案02的筆記","title":"其他的筆記-minecraft mod GatherData新增資料檔案02"},{"content":"minecraft mod GatherData新增資料檔案 這篇是minecraft mod GatherData新增資料檔案的筆記\n1.增加提供 package tom8760925.tomkumr.data.tomkumr; import net.minecraft.data.DataProvider; import net.minecraftforge.common.data.ExistingFileHelper; import net.minecraftforge.data.event.GatherDataEvent; import net.minecraftforge.eventbus.api.SubscribeEvent; import net.minecraftforge.fml.common.Mod; import tom8760925.tomkumr.Modinfo; //註冊事件 @Mod.EventBusSubscriber(modid = Modinfo.MODID , bus = Mod.EventBusSubscriber.Bus.MOD) //模組職業 public class tomkumrProfession { //事件處理 @SubscribeEvent //職業資料 public static void ProfessionGatherData(GatherDataEvent event) { //增加提供 event.getGenerator().addProvider( event.includeClient(), //資料提供 (DataProvider.Factory\u0026lt;tomkumrDataProvider\u0026gt;) p -\u0026gt;new tomkumrDataProvider(p, Modinfo.MODID,\u0026#34;Profession\u0026#34;,\u0026#34;Life\u0026#34;) ); } } 2.資料提供 package tom8760925.tomkumr.data.tomkumr; import net.minecraft.data.PackOutput; public class tomkumrDataProvider extends tomkumrProvider { //宣告起始 public tomkumrDataProvider(PackOutput output, String modid, String locale,String finction) { super(output, modid, locale,finction); } //新增資料設定 @Override protected void addDataConffig() { //新增資料 this.add(\u0026#34;test\u0026#34;,\u0026#34;data\u0026#34;); } } 3.提供 package tom8760925.tomkumr.data.tomkumr; import com.google.gson.JsonObject; import net.minecraft.data.CachedOutput; import net.minecraft.data.DataProvider; import net.minecraft.data.PackOutput; import org.jetbrains.annotations.NotNull; import tom8760925.tomkumr.Modinfo; import java.nio.file.Path; import java.util.Map; import java.util.TreeMap; import java.util.concurrent.CompletableFuture; public abstract class tomkumrProvider implements DataProvider { //宣告 private final Map\u0026lt;String, String\u0026gt; data = new TreeMap\u0026lt;\u0026gt;(); private final PackOutput output; private final String modid; private final String locale; private final String finction; //宣告起始 public tomkumrProvider(PackOutput output, String modid, String locale,String finction) { this.output = output; this.modid = modid; this.locale = locale; this.finction = finction; } //宣告抽象函數 protected abstract void addDataConffig(); //使用 @Override public CompletableFuture\u0026lt;?\u0026gt; run(CachedOutput cache) { //使用抽象函數 addDataConffig(); //判斷data if (!data.isEmpty()) //呼叫函數 return save(cache, this.output.getOutputFolder(PackOutput.Target.DATA_PACK/*設定在data資料夾裡*/).resolve(this.modid).resolve(this.finction).resolve(this.locale + \u0026#34;.json\u0026#34;)); return CompletableFuture.allOf(); } //儲存的資料及位子 private CompletableFuture\u0026lt;?\u0026gt; save(CachedOutput cache, Path target) { //建立json JsonObject json = new JsonObject(); //轉成json this.data.forEach(json::addProperty); return DataProvider.saveStable(cache, json, target); } //名稱 @Override public @NotNull String getName() { return Modinfo.MODID +\u0026#34;: \u0026#34; + locale; } //新增資料 public void add(String key, String value) { if (data.put(key, value) != null) throw new IllegalStateException(\u0026#34;Duplicate translation key \u0026#34; + key); } } 4.檔案 在tomkumr/src/generated/resources/data/tomkumr/Life，裡面新增檔案Profession.json\n{ \u0026#34;test\u0026#34;: \u0026#34;data\u0026#34; } ","permalink":"https://tom8760925.github.io/tomku/other/notes/minecraft05/","summary":"這篇是minecraft mod GatherData新增資料檔案的筆記","title":"其他的筆記-minecraft mod GatherData新增資料檔案"},{"content":"minecraft mod 新增能力 這篇是minecraft mod 新增能力的筆記\n1.新增值的宣告 Farmer.java\npackage tom8760925.tomkumr.Profession.Life.Level; import net.minecraft.nbt.CompoundTag; public class Farmer { //宣告數值 private int xp; //宣告初值 public Farmer() { this.xp = 0; } //獲取值 public int getXp() { return xp; } //設定值 public void setXp(int xp) { this.xp = xp; } //在nbt儲存值 public void NbtSave(CompoundTag compoundTag){ compoundTag.putInt(\u0026#34;farmer\u0026#34;,xp); } public void NbtGet(CompoundTag compoundTag){ //獲取nbt所儲存的值 xp = compoundTag.getInt(\u0026#34;farmer\u0026#34;); } //值增加 public void increase(int n){ this.xp += n; } } 2.新增能力 Farmer.java\npackage tom8760925.tomkumr.Profession.Life.Provider; import net.minecraft.core.Direction; import net.minecraft.nbt.CompoundTag; import net.minecraft.nbt.Tag; import net.minecraftforge.common.capabilities.Capability; import net.minecraftforge.common.capabilities.CapabilityManager; import net.minecraftforge.common.capabilities.CapabilityToken; import net.minecraftforge.common.capabilities.ICapabilityProvider; import net.minecraftforge.common.util.INBTSerializable; import net.minecraftforge.common.util.LazyOptional; import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; public class Farmer implements ICapabilityProvider , INBTSerializable { //導入值 private tom8760925.tomkumr.Profession.Life.Level.Farmer farmer; //能力設定 public static final Capability\u0026lt;tom8760925.tomkumr.Profession.Life.Level.Farmer\u0026gt; Farmer_Capability = CapabilityManager.get(new CapabilityToken\u0026lt;\u0026gt;(){}); //公開能力 private final LazyOptional\u0026lt;tom8760925.tomkumr.Profession.Life.Level.Farmer\u0026gt; lazyOptional = LazyOptional.of(()-\u0026gt;this.farmer); public Farmer() { this.farmer = new tom8760925.tomkumr.Profession.Life.Level.Farmer();//給與初值 } //獲取能力 @Override public @NotNull \u0026lt;T\u0026gt; LazyOptional\u0026lt;T\u0026gt; getCapability(@NotNull Capability\u0026lt;T\u0026gt; cap/*能力*/, @Nullable Direction side/*方向*/) { //獲得能力 return getCapability(cap); } //獲得能力 @Override public @NotNull \u0026lt;T\u0026gt; LazyOptional\u0026lt;T\u0026gt; getCapability(@NotNull Capability\u0026lt;T\u0026gt; cap/*能力*/) { //判斷能力是否為所設定的 if (cap == Farmer_Capability){ //回傳能力 return lazyOptional.cast(); } else { //回傳空值 return LazyOptional.empty(); } } //儲存值 @Override public Tag serializeNBT() { var tag = new CompoundTag(); farmer.NbtSave(tag); return tag; } //獲取值 @Override public void deserializeNBT(Tag nbt) { farmer.NbtGet((CompoundTag) nbt); } } 3.註冊能力 ModEvent.java\npackage tom8760925.tomkumr.Profession.event; import net.minecraftforge.client.event.RegisterRecipeBookCategoriesEvent; import net.minecraftforge.common.capabilities.RegisterCapabilitiesEvent; import net.minecraftforge.eventbus.api.SubscribeEvent; import net.minecraftforge.fml.common.Mod; import tom8760925.tomkumr.Modinfo; import tom8760925.tomkumr.Profession.Life.Provider.Farmer; //註冊事件 @Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD , modid = Modinfo.MODID) public class ModEvent { //事件處理 @SubscribeEvent //註冊能力 public static void registerCapabilities(RegisterCapabilitiesEvent event){ //註冊 event.register(Farmer.class); } } 4.將能力註冊到玩家身上 tomkumr.java\npackage tom8760925.tomkumr.forge; import net.minecraft.resources.ResourceLocation; import net.minecraft.world.entity.Entity; import net.minecraft.world.entity.player.Player; import net.minecraftforge.common.MinecraftForge; import net.minecraftforge.event.AttachCapabilitiesEvent; import net.minecraftforge.event.entity.player.PlayerEvent; import net.minecraftforge.eventbus.api.SubscribeEvent; import net.minecraftforge.fml.common.Mod; import tom8760925.tomkumr.ChatMessage; import tom8760925.tomkumr.Modinfo; import tom8760925.tomkumr.Profession.Life.Provider.Farmer; //forge入口 @Mod(Modinfo.MODID) //註冊事件 @Mod.EventBusSubscriber public class tomkumr { //事件處理 @SubscribeEvent //玩家登入時 public static void PlayerInWorld(PlayerEvent.PlayerLoggedInEvent event) { //使用繼承 ChatMessage cm = new ChatMessage(); //使用函式 cm.C_Message(event,\u0026#34;hello\u0026#34;); //判斷是否玩家有這個能力 event.getEntity().getCapability(Farmer.Farmer_Capability).ifPresent((xp)-\u0026gt;{ //獲取xp cm.C_Message(event,Integer.toString(xp.getXp())); }); } public tomkumr(){ //建立事件 MinecraftForge.EVENT_BUS.addGenericListener(Entity.class,this::attachCapabilities); } //對玩家實體加上能力 public void attachCapabilities(AttachCapabilitiesEvent\u0026lt;Entity\u0026gt; event){ //判斷是否為玩家 if(event.getObject() instanceof Player player){ //判斷玩家是否有這個能力 if(!player.getCapability(Farmer.Farmer_Capability).isPresent()){ //將能力加到玩家實體上 event.addCapability(new ResourceLocation(Modinfo.MODID,\u0026#34;farmer\u0026#34;),new Farmer()); } } } } 5.新增能力事件 ForgeEvent.java\npackage tom8760925.tomkumr.Profession.event; import net.minecraft.world.level.block.CropBlock; import net.minecraftforge.event.entity.player.PlayerEvent; import net.minecraftforge.event.level.BlockEvent; import net.minecraftforge.eventbus.api.SubscribeEvent; import net.minecraftforge.fml.common.Mod; import tom8760925.tomkumr.Modinfo; import tom8760925.tomkumr.Profession.Life.Provider.Farmer; //註冊事件 @Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE , modid = Modinfo.MODID) public class ForgeEvent { //事件處理 @SubscribeEvent //破壞植物方塊獲得經驗 public static void BlockCropXp(BlockEvent.BreakEvent event){ //判斷破壞的方塊是否為植物方塊 if(event.getState().getBlock() instanceof CropBlock){ //判斷是否玩家有這個能力 event.getPlayer().getCapability(Farmer.Farmer_Capability).ifPresent((xp)-\u0026gt;{ //加一 xp.increase(1); }); } } //事件處理 @SubscribeEvent //玩家死亡後能力複製給新的玩家實體 public static void PlayerClose(PlayerEvent.Clone event){ //將原來的數據激活 event.getOriginal().reviveCaps(); //判斷原來是否有這個能力 event.getOriginal().getCapability(Farmer.Farmer_Capability).ifPresent((old) -\u0026gt;{ //判斷是否玩家有這個能力 event.getEntity().getCapability(Farmer.Farmer_Capability).ifPresent((xp)-\u0026gt;{ //設定等級 xp.setXp(old.getXp()); }); }); } } ","permalink":"https://tom8760925.github.io/tomku/other/notes/minecraft04/","summary":"這篇是minecraft mod 新增能力的筆記","title":"其他的筆記-minecraft mod 新增能力"},{"content":"minecraft mod 顯示登入訊息 這篇是minecraft mod 顯示登入訊息的筆記\ntomkumr.java\npackage tom8760925.tomkumr.forge; import net.minecraftforge.event.entity.player.PlayerEvent; import net.minecraftforge.eventbus.api.SubscribeEvent; import net.minecraftforge.fml.common.Mod; import tom8760925.tomkumr.ChatMessage; import tom8760925.tomkumr.TomkumrConfig; @Mod(TomkumrConfig.MODID) //forge入口 @Mod.EventBusSubscriber //註冊事件 public class tomkumr { @SubscribeEvent //事件處理 //玩家登入時 public static void playerinWorld(PlayerEvent.PlayerLoggedInEvent event) { ChatMessage cm = new ChatMessage(); //使用繼承 cm.C_Message(event); //使用函式 } } TomkumrConfig.java\npackage tom8760925.tomkumr; public class TomkumrConfig { public static final String MODID = \u0026#34;tomkumr\u0026#34;;//設定ID } ChatMessage.java\npackage tom8760925.tomkumr; import net.minecraft.network.chat.ChatType; import net.minecraft.network.chat.OutgoingChatMessage; import net.minecraft.network.chat.PlayerChatMessage; import net.minecraft.world.entity.player.Player; import net.minecraftforge.event.entity.player.PlayerEvent; public class ChatMessage { public void C_Message(PlayerEvent.PlayerLoggedInEvent event) { Player player = event.getEntity();//獲得實體 PlayerChatMessage chatMessage = PlayerChatMessage.unsigned(player.getUUID(), \u0026#34;hello\u0026#34;);//客戶端訊息 player.createCommandSourceStack().sendChatMessage(new OutgoingChatMessage.Player(chatMessage), false, ChatType.bind(ChatType.CHAT, player));//顯示訊息 } } ","permalink":"https://tom8760925.github.io/tomku/other/notes/minecraft03/","summary":"這篇是minecraft mod 顯示登入訊息的筆記","title":"其他的筆記-minecraft mod 顯示登入訊息"},{"content":"netdb.h 這篇是C++的筆記第24篇\nhostent 使用網址取的host資訊\n#include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { hostent *hp; hp = gethostbyname(\u0026#34;www.miaoli.gov.tw\u0026#34;); // 使用網址 if (hp == NULL) { return 1; } printf(\u0026#34;p:%s\\n\u0026#34;, hp-\u0026gt;h_name); // 網址 printf(\u0026#34;p:%d\\n\u0026#34;, hp-\u0026gt;h_addrtype); // 類型 printf(\u0026#34;p:%s\\n\u0026#34;, *hp-\u0026gt;h_aliases); // 備用host printf(\u0026#34;p:%d\\n\u0026#34;, hp-\u0026gt;h_length); // 長度 struct in_addr hpad = *(struct in_addr *)hp-\u0026gt;h_addr_list[0]; // 取得網路字串 char *hpip = inet_ntoa(hpad); // 轉換成十進制 printf(\u0026#34;p:%s\\n\u0026#34;, hpip); // ip printf(\u0026#34;-------\\n\u0026#34;); hostent *hpa; hpa = gethostbyaddr(hp-\u0026gt;h_addr_list[0], hp-\u0026gt;h_length, hp-\u0026gt;h_addrtype); // 使用網路字節 if (hp == NULL) { return 1; } printf(\u0026#34;p:%s\\n\u0026#34;, hpa-\u0026gt;h_name); // 網址 printf(\u0026#34;p:%d\\n\u0026#34;, hpa-\u0026gt;h_addrtype); // 類型 printf(\u0026#34;p:%s\\n\u0026#34;, *hpa-\u0026gt;h_aliases); // 備用host printf(\u0026#34;p:%d\\n\u0026#34;, hpa-\u0026gt;h_length); // 長度 struct in_addr hpada = *(struct in_addr *)hpa-\u0026gt;h_addr_list[0]; // 取得網路字串 char *hpipa = inet_ntoa(hpada); // 轉換成十進制 printf(\u0026#34;p:%s\\n\u0026#34;, hpipa); return 0; } 結果\np:www.miaoli.gov.tw p:2 p:(null) p:4 p:163.29.206.105 ------- p:www.miaoli.gov.tw p:2 p:105.206.29.163.in-addr.arpa p:4 p:163.29.206.105 netent、protoent、servent 現在已經棄用\n根據網址：https://android.googlesource.com/platform/bionic/+/refs/heads/main/libc/include/netdb.h 經過測試也無法使用\ngetaddrinfo、getnameinfo #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { struct addrinfo hints; struct addrinfo *result; struct addrinfo *res; int i; // 設定hints memset(\u0026amp;hints, 0, sizeof(struct addrinfo)); // 設定flags hints.ai_flags = AI_PASSIVE; // 使用bind() // 設定ipv4或ipv6 hints.ai_family = AF_UNSPEC; // 使用ipv4或ipv6 // 設定返回的sock類型 hints.ai_socktype = SOCK_DGRAM; // 使用UDP 或 SOCK_STREAM 使用TCP // 設定協定 hints.ai_protocol = 0; // 不設定就設為0 // 設定主機名稱 hints.ai_canonname = NULL; // 設定主機位子 hints.ai_addr = NULL; // 設定位子長度 hints.ai_addrlen = NULL; // 下一個結構 hints.ai_next = NULL; // getaddrinfo(網址, port, 設定值, 傳送值); i = getaddrinfo(\u0026#34;www.miaoli.gov.tw\u0026#34;, NULL, \u0026amp;hints, \u0026amp;result); if (i != 0) { return 1; } for (res = result; res != NULL; res = res-\u0026gt;ai_next) { // 網址 char hostname[NI_MAXHOST] = \u0026#34;\u0026#34;; char service[NI_MAXSERV] = \u0026#34;\u0026#34;; // getnameinfo(位子, 位子長度, 名稱, 名稱長度, ANSI 字串, ANSI 字串長度, 設定flags); i = getnameinfo(res-\u0026gt;ai_addr, res-\u0026gt;ai_addrlen, hostname, NI_MAXHOST, service, NI_MAXSERV, 0); if (i != 0) { continue; } printf(\u0026#34;hostname: %s\\n\u0026#34;, hostname); printf(\u0026#34;service: %s\\n\u0026#34;, service); } // 釋放addrinfo freeaddrinfo(result); freeaddrinfo(res); return 0; } 結果\nhostname: www.miaoli.gov.tw service: 0 hostname: 2001-4420-7202-0080-0000-0000-0000-0105.hinet-ip6.hinet.net service: 0 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/24/","summary":"這篇是C++的筆記第24篇","title":"C++語言的筆記-netdb.h"},{"content":"minecraft mod 設定 這篇是minecraft mod 設定的筆記\nmods.toml 模組註冊表單\nmodLoader = \u0026#34;javafml\u0026#34; #登入器 loaderVersion = \u0026#34;${loader_version_range}\u0026#34; # forge版本 license = \u0026#34;${mod_license}\u0026#34; # 許可證 [[mods]] modId = \u0026#34;${mod_id}\u0026#34; # id version = \u0026#34;${mod_version}\u0026#34; # mc版本 displayName = \u0026#34;${mod_name}\u0026#34; # 名子 authors = \u0026#34;${mod_authors}\u0026#34; # 作者 description = \u0026#39;\u0026#39;\u0026#39;${mod_description}\u0026#39;\u0026#39;\u0026#39; # 簡介 [[dependencies.${mod_id}]] #需求依賴 modId=\u0026#34;forge\u0026#34; mandatory=true versionRange=\u0026#34;${forge_version_range}\u0026#34; ordering=\u0026#34;NONE\u0026#34; side=\u0026#34;BOTH\u0026#34; [[dependencies.${mod_id}]] #需求依賴 modId=\u0026#34;minecraft\u0026#34; mandatory=true versionRange=\u0026#34;${minecraft_version_range}\u0026#34; ordering=\u0026#34;NONE\u0026#34; side=\u0026#34;BOTH\u0026#34; build.gradle 環境設定檔\nplugins { //插件 id \u0026#39;eclipse\u0026#39; id \u0026#39;maven-publish\u0026#39; id \u0026#39;net.minecraftforge.gradle\u0026#39; version \u0026#39;6.+\u0026#39; } version = mod_version // mc版本 group = mod_group_id base { archivesName = mod_id // id } // java版本 java.toolchain.languageVersion = JavaLanguageVersion.of(17) //測試平台 minecraft { mappings channel: mapping_channel, version: mapping_version runs { configureEach { workingDirectory project.file(\u0026#39;run\u0026#39;) property \u0026#39;forge.logging.markers\u0026#39;, \u0026#39;REGISTRIES\u0026#39; property \u0026#39;forge.logging.console.level\u0026#39;, \u0026#39;debug\u0026#39; mods { \u0026#34;${mod_id}\u0026#34; { source sourceSets.main } } } client { property \u0026#39;forge.enabledGameTestNamespaces\u0026#39;, mod_id } server { property \u0026#39;forge.enabledGameTestNamespaces\u0026#39;, mod_id args \u0026#39;--nogui\u0026#39; } gameTestServer { property \u0026#39;forge.enabledGameTestNamespaces\u0026#39;, mod_id } data { workingDirectory project.file(\u0026#39;run-data\u0026#39;) args \u0026#39;--mod\u0026#39;, mod_id, \u0026#39;--all\u0026#39;, \u0026#39;--output\u0026#39;, file(\u0026#39;src/generated/resources/\u0026#39;), \u0026#39;--existing\u0026#39;, file(\u0026#39;src/main/resources/\u0026#39;) } } } sourceSets.main.resources { srcDir \u0026#39;src/generated/resources\u0026#39; } // 載入的資源 // 依賴庫 repositories { } //依賴的模組 dependencies { minecraft \u0026#34;net.minecraftforge:forge:${minecraft_version}-${forge_version}\u0026#34; } tasks.named(\u0026#39;processResources\u0026#39;, ProcessResources).configure { //轉換字串 var replaceProperties = [ minecraft_version: minecraft_version, minecraft_version_range: minecraft_version_range, forge_version: forge_version, forge_version_range: forge_version_range, loader_version_range: loader_version_range, mod_id: mod_id, mod_name: mod_name, mod_license: mod_license, mod_version: mod_version, mod_authors: mod_authors, mod_description: mod_description, ] inputs.properties replaceProperties filesMatching([\u0026#39;META-INF/mods.toml\u0026#39;, \u0026#39;pack.mcmeta\u0026#39;]) { expand replaceProperties + [project: project] } } // 屬性 tasks.named(\u0026#39;jar\u0026#39;, Jar).configure { manifest { attributes([ \u0026#39;Specification-Title\u0026#39; : mod_id, \u0026#39;Specification-Vendor\u0026#39; : mod_authors, \u0026#39;Specification-Version\u0026#39; : \u0026#39;1\u0026#39;, \u0026#39;Implementation-Title\u0026#39; : project.name, \u0026#39;Implementation-Version\u0026#39; : project.jar.archiveVersion, \u0026#39;Implementation-Vendor\u0026#39; : mod_authors, \u0026#39;Implementation-Timestamp\u0026#39;: new Date().format(\u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ssZ\u0026#34;) ]) } finalizedBy \u0026#39;reobfJar\u0026#39; } // 使用maven-publish publishing { publications { register(\u0026#39;mavenJava\u0026#39;, MavenPublication) { artifact jar } } repositories { maven { url \u0026#34;file://${project.projectDir}/mcmodsrepo\u0026#34; } } } // 使用utf-8進行編譯 tasks.withType(JavaCompile).configureEach { options.encoding = \u0026#39;UTF-8\u0026#39; // Use the UTF-8 charset for Java compilation } gradle.properties 設定檔\n#測試設定 org.gradle.jvmargs=-Xmx3G org.gradle.daemon=false #版本 minecraft_version=1.20.1 minecraft_version_range=[1.20.1,) forge_version=47.3.0 forge_version_range=[47,) loader_version_range=[47,) mapping_channel=official mapping_version=1.20.1 #mod資訊 mod_name=Tomku Mr mod_license=The MIT License (MIT) mod_version=1.0.0 mod_group_id=tom8760925.tomkumr mod_authors=tom8760925 mod_description=tom8760925\u0026#39;s mod settings.gradle 連接載入器\npluginManagement { repositories { gradlePluginPortal() maven { name = \u0026#39;MinecraftForge\u0026#39; url = \u0026#39;https://maven.minecraftforge.net/\u0026#39; } } } plugins { id \u0026#39;org.gradle.toolchains.foojay-resolver-convention\u0026#39; version \u0026#39;0.7.0\u0026#39; } ","permalink":"https://tom8760925.github.io/tomku/other/notes/minecraft02/","summary":"這篇是minecraft mod 設定的筆記","title":"其他的筆記-minecraft mod 設定"},{"content":"minecraft mod 製作環境設置 這篇是minecraft mod 製作的筆記\n先下載forge，選擇要製作的版本下載mdk，接著解壓縮\nhttps://files.minecraftforge.net/net/minecraftforge/forge/ 接著下載IDE，這裡選擇使用eclipse，下載並安裝\nhttps://www.eclipse.org/downloads/ 接著匯入forge\n檔案 -\u0026gt; 匯入 -\u0026gt; Gradle -\u0026gt; Eisting Gradle Project -\u0026gt; 選擇forge資料夾 -\u0026gt; 完成 設定環境\n1.Gradle Tasks -\u0026gt; ide -\u0026gt; eclipse 2.Gradle Tasks -\u0026gt; forgegradle runs -\u0026gt; cleanEclipse 設定完成後，開啟minecraft測試\nGradle Tasks -\u0026gt; forgegradle runs -\u0026gt; runClient 如果沒問題就能正常開啟\n","permalink":"https://tom8760925.github.io/tomku/other/notes/minecraft01/","summary":"這篇是minecraft mod 製作的筆記","title":"其他的筆記-minecraft mod 製作環境設置"},{"content":"arpa/inet.h 這篇是C++的筆記第23篇\n方法 #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { char ip[] = \u0026#34;192.168.1.10\u0026#34;; in_addr add1, add2, add3, add4, add5, add6, add7; std::cout \u0026lt;\u0026lt; \u0026#34;1.-------\\n\u0026#34;; // 1.轉換成網路字節 add1.s_addr = inet_addr(ip); std::cout \u0026lt;\u0026lt; add1.s_addr \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;2.-------\\n\u0026#34;; // 2.轉換成網路位子 if (inet_aton(ip, \u0026amp;add2) == 0) { return 1; } std::cout \u0026lt;\u0026lt; add2.s_addr \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;3.-------\\n\u0026#34;; // 3.獲取網路位置 add3.s_addr = inet_netof(add2); std::cout \u0026lt;\u0026lt; add3.s_addr \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;4.-------\\n\u0026#34;; // 4.獲取主機位置 add4.s_addr = inet_lnaof(add2); std::cout \u0026lt;\u0026lt; add4.s_addr \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;5.-------\\n\u0026#34;; // 5.組合網路位置和主機位置 add5 = inet_makeaddr(add3.s_addr, add4.s_addr); std::cout \u0026lt;\u0026lt; add5.s_addr \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;6.-------\\n\u0026#34;; // 6.轉換成主機字節 add6.s_addr = inet_network(ip); std::cout \u0026lt;\u0026lt; add6.s_addr \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;7.-------\\n\u0026#34;; // 7.轉換成十進制 std::cout \u0026lt;\u0026lt; inet_ntoa(add1) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;8.-------\\n\u0026#34;; // 8.轉換成十進制 char str[INET_ADDRSTRLEN]; std::cout \u0026lt;\u0026lt; inet_ntop(AF_INET, \u0026amp;add1.s_addr, str, sizeof(str)) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;9.-------\\n\u0026#34;; // 9.轉換成網路字節 if (inet_pton(AF_INET, ip, \u0026amp;add7.s_addr) == 0) { return 1; } std::cout \u0026lt;\u0026lt; add7.s_addr \u0026lt;\u0026lt; std::endl; return 0; } 結果\n1.------- 167880896 2.------- 167880896 3.------- 12625921 4.------- 10 5.------- 167880896 6.------- 3232235786 7.------- 192.168.1.10 8.------- 192.168.1.10 192.168.1.10 9.------- 167880896 轉換 #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // 轉換成網路字節32位的 std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; htonl(8080) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 轉換成網路字節16位的 std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; htons(8080) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; // 網路字節32位轉換成主機字節 std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; ntohl(htonl(8080)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 網路字節16位轉換成主機字節 std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; ntohs(htons(8080)) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; return 0; } 結果\np:2417950720 p:36895 -------- p:8080 p:8080 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/23/","summary":"這篇是C++的筆記第23篇","title":"C++語言的筆記-arpa/inet.h"},{"content":"xcode上使用c++ 這篇是xcode上使用c++的筆記\n先設定\nBuild Settings -\u0026gt; Swift Compiler - Language -\u0026gt; C++ and Objective-C Interoperability -\u0026gt; C++/Objective-C++ 新增cpp檔案時會詢問要不要新增橋接欓，如果沒有也可以自行新增\n專案名稱-Bridging-Header.h 裡面會要有連接標頭檔\n#import \u0026#34;xxx.hpp\u0026#34; 在swift檔時因該就能使用。\n例子\nxxx.hpp\n#ifndef xxx_hpp #define xxx_hpp class test{ public: int a(); }; int tttt(); #endif xxx.cpp\n#include \u0026#34;xxx.hpp\u0026#34; int test::a(){ return 3; } int tttt(){ return 4; } xxx-Bridging-Header.h\n#import \u0026#34;xxx.hpp\u0026#34; xxx.swift\nvar a=test() VStack { Text(String(tttt())) } VStack { Text(String(a.a())) } 最後會顯示3和4\n","permalink":"https://tom8760925.github.io/tomku/other/notes/xcodeandc++/","summary":"這篇是xcode上使用c++的筆記","title":"其他的筆記-xcode上使用c++"},{"content":"pygsheets 這篇是python的筆記第04篇\n使用 使用python操作google sheet，可以使用pygsheets函式庫\npip install pysheets 使用 需要先去google cloud 設定google sheet api\n取得金鑰\n再去google sheet 設定使用權限\nimport pysheets as py gc = py.authorize(service_file=\u0026#34;xxx.json\u0026#34;) # 金鑰檔位子 sh = gc.open_by_url(\u0026#34;url\u0026#34;) #表單網址 wks = sh.worksheet_by_title(\u0026#39;sheet\u0026#39;) # 工作表名稱 wks.update_value(\u0026#39;A1\u0026#39;, \u0026#39;test\u0026#39;) # 上傳資料 ","permalink":"https://tom8760925.github.io/tomku/python/notes/04/","summary":"這篇是python的筆記第04篇","title":"python語言的筆記-pygsheets"},{"content":"bs4 這篇是python的筆記第03篇\n使用 使用python將html轉換網頁標籤，可以使用bs4函式庫\npip install beautifulsoup4 使用 from selenium import webdriver from bs4 import BeautifulSoup driver = webdriver.Edge() # 選擇瀏覽器 driver.get(\u0026#39;https://www.cwa.gov.tw/V8/C/E/index.html\u0026#39;) # 打開瀏覽器開啟網頁 soup = BeautifulSoup(driver.page_source, \u0026#34;html.parser\u0026#34;) # 轉換成標籤樹 print(\u0026#34;title:\u0026#34;+soup.title.string) # 取得標題 print(\u0026#34;震度:\u0026#34;+soup.find(\u0026#34;tr\u0026#34;,id=\u0026#34;eq-1\u0026#34;).find(\u0026#34;td\u0026#34;,class_=\u0026#34;eq_lv-1\u0026#34;).string) # 取得資料 driver.close() # 關閉瀏覽器 ","permalink":"https://tom8760925.github.io/tomku/python/notes/03/","summary":"這篇是python的筆記第03篇","title":"python語言的筆記-bs4"},{"content":"selenium 這篇是python的筆記第02篇\n使用python寫網路爬蟲，可以使用selenium函式庫\n安裝 pip install selenium 使用 from selenium import webdriver driver = webdriver.Edge() # 選擇瀏覽器 driver.get(\u0026#39;https://www.cwa.gov.tw/V8/C/E/index.html\u0026#39;) # 打開瀏覽器開啟網頁 f= open(\u0026#39;test.txt\u0026#39;,\u0026#39;w\u0026#39;) #開啟檔案 f.write(driver.page_source) # 寫入網頁程式碼 f.close() ","permalink":"https://tom8760925.github.io/tomku/python/notes/02/","summary":"這篇是python的筆記第02篇","title":"python語言的筆記-selenium"},{"content":"requests 這篇是python的筆記第01篇\n使用python寫網路爬蟲，可以使用requests函式庫\n安裝 pip install requests 使用 import requests # 載入函式庫 params = { # 設定參數 \u0026#39;hl\u0026#39; : \u0026#39;zh_TW\u0026#39; } web = requests.get(\u0026#39;https://www.google.com.tw/\u0026#39;,params= params) # 獲得網頁資料 web.encoding=\u0026#39;utf-8\u0026#39; # 編碼 print(web.text,end=\u0026#39;\\n\u0026#39;) # 顯示字串 import requests # 載入函式庫 web = requests.get(\u0026#39;https://opendataap2.e-land.gov.tw/resource/files/2023-02-12/62f4d78b604ba16b8cc1e856dd28d2c3.json\u0026#39;,verify=False) # 獲得網頁資料時，有可能SSL會錯誤將verify設為False print(web.json(),end=\u0026#39;\\n\u0026#39;) # 顯示json ","permalink":"https://tom8760925.github.io/tomku/python/notes/01/","summary":"這篇是python的筆記第01篇","title":"python語言的筆記-requests"},{"content":"環境設置 這篇是python的練習筆記第01篇\n這篇在MAC上，使用VSCODE寫python\n安裝VSCODE 去以下網址下載VSCODE\nhttps://code.visualstudio.com/ 安裝VSCODE插建 https://marketplace.visualstudio.com/items?itemName=ms-python.python https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance https://marketplace.visualstudio.com/items?itemName=ms-python.debugpy 起始設定 在上方收尋欄輸入\n\u0026gt;python:建立環境 -\u0026gt; venv -\u0026gt;選擇版本 和\n\u0026gt;Python 偵錯工具:使用launch.json進行偵錯 會新增.venv資料夾和.vscode\n啟動測試 新增一個.py的檔案\n寫入進行測試\nprint(\u0026#34;hello world\u0026#34;) ","permalink":"https://tom8760925.github.io/tomku/python/no/01/","summary":"這篇是python的練習筆記第01篇","title":"python語言的練習-環境設置"},{"content":"標頭檔和實作檔 這篇是C++的練習筆記第11篇\n標頭檔是載入時使用，檔案大多都是寫入宣告，而實際執行函式是寫入實作檔。 而標頭檔和實作檔的名稱會使用同一個，會比較好識別。\n執行欓1.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026#34;test.h\u0026#34; using namespace std; void test1(); void test2(); void test3(); int main() { test1(); printf(\u0026#34;---------\\n\u0026#34;); test2(); printf(\u0026#34;---------\\n\u0026#34;); test3(); return 0; } void test1() { printf(\u0026#34;p:%d\\n\u0026#34;, a()); // 使用a()函式 } void test2() { test_class t; t.test_a = 1; t.test_b = 2; printf(\u0026#34;p:%d\\n\u0026#34;, t.test_c()); // 使用class中的test_c()函式 } void test3() { test_namespace::test_class t; t.test_a = 1; t.test_b = 2; printf(\u0026#34;p:%d\\n\u0026#34;, t.test_c()); // 使用class中的test_c()函式 printf(\u0026#34;p:%d\\n\u0026#34;, test_namespace::test_e()); // 使用test_e()函式 } 標頭檔test.h\n#ifndef TEST_H // 判斷有沒有重複載入 #define TEST_H int a(); class test_class { public: int test_a; int test_b; int test_c(); private: int test_d = 3; }; namespace test_namespace { class test_class { public: int test_a; int test_b; int test_c(); private: int test_d = 3; }; int test_e(); } #endif 實作檔test.cpp\n#include \u0026#34;test.h\u0026#34; // a() int a() { return 2; } // test_class int test_class::test_c() { return this-\u0026gt;test_a + this-\u0026gt;test_b + this-\u0026gt;test_d; }; // test_namespace int test_namespace::test_class::test_c() { return this-\u0026gt;test_a + this-\u0026gt;test_b + this-\u0026gt;test_d; } int test_namespace::test_e() { return 3; } ","permalink":"https://tom8760925.github.io/tomku/c++/no/11/","summary":"這篇是C++的練習筆記第11篇","title":"C++語言的練習-標頭檔和實作檔"},{"content":"vscode執行多個檔案 這篇是C++的筆記第22篇\n在使用vscode寫c++時發現，預設是不能執行多個檔案，但改了tasks.json檔案裡的設定就可以執行了\n將\u0026#34;${file}\u0026#34;改成\u0026#34;${fileDirname}/*.cpp\u0026#34; 如果事使用Code Runner進行編譯的，可以在settings.json跟改設定就可以執行了\n將\u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ $fileName -o $fileNameWithoutExt -pthread \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34; 改成 \u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ $dir*.cpp -o $fileNameWithoutExt -std=c++17 -pthread \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, 這些方法只能執行同一個資料夾內的檔案，其他資料夾是不能的。\n","permalink":"https://tom8760925.github.io/tomku/c++/notes/22/","summary":"這篇是C++的筆記第22篇","title":"C++語言的筆記-vscode執行多個檔案"},{"content":"queue 這篇是C++的筆記第21篇\nqueue是先進先出\n#include \u0026lt;queue\u0026gt; using namespace std; void queue1(); int main() { queue1(); return 0; } void queue1() { queue\u0026lt;int\u0026gt; q; // 宣告 q.push(1); // 新增 q.push(2); q.push(3); printf(\u0026#34;p:%d\\n\u0026#34;, q.front()); // 頭的值 printf(\u0026#34;p:%d\\n\u0026#34;, q.back()); // 尾的值 printf(\u0026#34;p:%d\\n\u0026#34;, int(q.size())); // 大小 printf(\u0026#34;-------\\n\u0026#34;); q.pop(); // 從頭移除 printf(\u0026#34;p:%d\\n\u0026#34;, int(q.size())); printf(\u0026#34;p:%d\\n\u0026#34;, q.front()); printf(\u0026#34;p:%d\\n\u0026#34;, q.back()); } 結果\np:1 p:3 p:3 ------- p:2 p:2 p:3 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/21/","summary":"這篇是C++的筆記第21篇","title":"C++語言的筆記-queue"},{"content":"deque 這篇是C++的筆記第20篇\n#include \u0026lt;deque\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; void deque1(); int main() { deque1(); return 0; } void deque1() { deque\u0026lt;int\u0026gt; d = {1, 2, 3, 4, 5}; // 宣告 for (int n : d) // 顯示資料 { printf(\u0026#34;p:%d\\n\u0026#34;, n); } printf(\u0026#34;----------\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;, int(d.size())); // 大小 printf(\u0026#34;----------\\n\u0026#34;); printf(\u0026#34;p:%s\\n\u0026#34;, d.empty() ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); // 是否空白 printf(\u0026#34;----------\\n\u0026#34;); d.pop_front(); // 刪除頭 d.pop_back(); // 刪除尾 d.push_front(0); // 新增在頭 d.push_back(6); // 新增在尾 for (auto n = d.begin(); n != d.end(); n++) // 顯示資料 { printf(\u0026#34;p:%d\\n\u0026#34;, *n); } printf(\u0026#34;----------\\n\u0026#34;); d.insert(d.begin(), 1 /*數量*/, 1 /*值*/); // 新增在頭，並新增1個 d.insert(d.end(), {5, 5}); // 新增在尾，並新增2個 int a[] = {3, 3}; d.insert(next(d.begin(), 4), a, a + size(a)); // 新增在第5個位置，並用陣列新增 for (auto n = d.cbegin(); n != d.cend(); n++) // 顯示資料 { printf(\u0026#34;p:%d\\n\u0026#34;, *n); } } 結果\np:1 p:2 p:3 p:4 p:5 ---------- p:5 ---------- p:false ---------- p:0 p:2 p:3 p:4 p:6 ---------- p:1 p:0 p:2 p:3 p:3 p:3 p:4 p:6 p:5 p:5 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/20/","summary":"這篇是C++的筆記第20篇","title":"C++語言的筆記-deque"},{"content":"stack 這篇是C++的筆記第19篇\nstack是先進後出\n#include \u0026lt;stack\u0026gt; using namespace std; void stack1(); int main() { stack1(); return 0; } void stack1() { stack\u0026lt;int\u0026gt; s; // 宣告 s.push(1); // 從頭加入 if (!s.empty()) { printf(\u0026#34;p:%d\\n\u0026#34;, s.top()); // 顯示頭的值 } s.push(2); if (!s.empty()) { printf(\u0026#34;p:%d\\n\u0026#34;, s.top()); } s.push(3); if (!s.empty()) { printf(\u0026#34;p:%d\\n\u0026#34;, s.top()); } printf(\u0026#34;------------\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;, int(s.size())); // 大小 printf(\u0026#34;------------\\n\u0026#34;); if (!s.empty()) // 是否為空 { s.pop(); // 從頭移出 } printf(\u0026#34;p:%d\\n\u0026#34;, int(s.size())); if (!s.empty()) { s.pop(); } printf(\u0026#34;p:%d\\n\u0026#34;, int(s.size())); } 結果\np:1 p:2 p:3 ------------ p:3 ------------ p:2 p:1 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/19/","summary":"這篇是C++的筆記第19篇","title":"C++語言的筆記-stack"},{"content":"Valid Parentheses 這篇是C++的練習實作第07篇\n練習leetcode上的Valid Parentheses\n寫了兩個版本\n#include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; class Solution { public: bool isValid1(string s) // 將判斷分成兩個 { unordered_map\u0026lt;char, char\u0026gt; um = {{\u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;}, {\u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;}, {\u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;}}; // 建立字典 int len = s.length(); // 字串長度 if (um[s[0]] == s[1]) // 判斷是否為第一種 { for (int n = 0; n \u0026lt; len; n++) // 迴圈 { if (um[s[n]] == s[n + 1]) // 判斷是否相同 { n++; } else { return false; } } } else { for (int n = 0; n \u0026lt; len / 2; n++) // 執行一半迴圈 { if (um[s[n]] != s[(len - 1) - n]) // 判斷是否相同 { return false; } } } return true; } bool isValid2(string s) // 使用stack簡化判斷 { stack\u0026lt;char\u0026gt; sk; // 宣告 unordered_map\u0026lt;char, char\u0026gt; um = {{\u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;}, {\u0026#39;[\u0026#39;, \u0026#39;]\u0026#39;}, {\u0026#39;{\u0026#39;, \u0026#39;}\u0026#39;}}; // 建立字典 for (char c : s) // 宣告 { if (um.find(c) != um.end()) // 判斷是否為(、{、[ { sk.push(um[c]); // 將)、]、}加入 } else if (!sk.empty() \u0026amp;\u0026amp; sk.top() == c) // 是否stack是否為空和是否為相對 { sk.pop(); // 移除 } else { return false; } } return true; } }; int main() { Solution s; string n = \u0026#34;([{}])\u0026#34;; bool r = s.isValid1(n); printf(\u0026#34;p:%s\\n\u0026#34;, r ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/practice/07/","summary":"這篇是C++的練習實作第07篇","title":"C++語言的練習-Valid Parentheses"},{"content":"Longest Common Prefix 這篇是C++的練習實作第06篇\n練習leetcode上的Longest Common Prefix\n寫了兩個版本\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Solution { public: string longestCommonPrefix1(vector\u0026lt;string\u0026gt; \u0026amp;strs) // 直接比較 { int len = 0; int strs_len = 0; char data = \u0026#39; \u0026#39;; bool data_b = true; string strs_array = \u0026#34;\u0026#34;; string r = \u0026#34;\u0026#34;; len = strs[0].length(); for (int n = 1; n \u0026lt; int(strs.size()); n++) // 找出字數最低的字串 { strs_array = strs[n]; strs_len = strs_array.length(); if (len \u0026gt; strs_len) { len = strs_len; } } for (int i = 0; i \u0026lt; len; i++) // 比較字串 { data = strs[0][i]; for (int a = 1; a \u0026lt; int(strs.size()); a++) { if (data != strs[a][i]) { data_b = false; } } if (data_b) { r += data; data_b = true; } else { data_b = true; } } return r; } string longestCommonPrefix2(vector\u0026lt;string\u0026gt; \u0026amp;strs) // 先排序後比較 { vector\u0026lt;string\u0026gt; strss = strs; int len = 0; string strss_end = \u0026#34;\u0026#34;; string r = \u0026#34;\u0026#34;; sort(strss.begin(), strss.end()); // 排序 len = strss[0].length(); strss_end = strss[strss.size() - 1]; for (int n = 0; n \u0026lt; len; n++) // 直接比較頭尾字串 { if (strss[0][n] == strss_end[n]) { r += strss[0][n]; } else { return \u0026#34;\u0026#34;; } } return r; } }; int main() { Solution s; vector\u0026lt;string\u0026gt; n = {\u0026#34;flower\u0026#34;, \u0026#34;flight\u0026#34;, \u0026#34;flow\u0026#34;}; string r = s.longestCommonPrefix2(n); cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/practice/06/","summary":"這篇是C++的練習實作第06篇","title":"C++語言的練習-Longest Common Prefix"},{"content":"Palindrome Number 這篇是C++的練習實作第05篇\n練習leetcode上的Palindrome Number\n寫了兩個版本\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; class Solution { public: bool isPalindrome1(int x) // 使用字串判斷 { if (x \u0026lt;= 0) // 小於等於是否為０ { return false; } string data = to_string(x); // 轉換字串 int len = data.length(); // 字串長度 for (int n = 0; n \u0026lt; len / 2; n++) // 判斷 { if (data[n] != data[len - (n + 1)]) { return false; } } return true; } bool isPalindrome2(int x) // 使用數值判斷 { if (x \u0026lt;= 0) // 小於等於是否為０ { return false; } int xx = x; int len = 0; while (true) // 數值長度 { xx /= 10; len++; if (xx == 0) { break; } } xx = x; for (int n = 0; n \u0026lt; len / 2; n++) // 判斷 { int a = pow(10, (len - 1) - (2 * n)); // 10的單數次方 if ((xx / a) != (xx % 10)) { return false; } xx %= a; xx /= 10; } return true; } }; int main() { Solution s; int input_number = 12321; bool r = s.isPalindrome1(input_number); printf(\u0026#34;p:%s\\n\u0026#34;, r ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); // 輸出 return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/practice/05/","summary":"這篇是C++的練習實作第05篇","title":"C++語言的練習-Palindrome Number"},{"content":"Two Sum 這篇是C++的練習實作第04篇\n練習leetcode上的Two Sum\n寫了三個版本\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) // 第一版本兩個數字相加 { vector\u0026lt;int\u0026gt; r; for (unsigned long n = 0; n \u0026lt; nums.size(); n++) { if (nums[n] \u0026gt; target) // 判斷數字是否大於目標數 { continue; } for (unsigned long i = 1; i \u0026lt; nums.size(); i++) // 相加 { if (nums[n] + nums[i] == target) { return {nums[n], nums[i]}; } } } return {}; } vector\u0026lt;int\u0026gt; twoSum2(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) // 第二版本改成用函數 { vector\u0026lt;int\u0026gt; r = twosum_filter(nums, target); return twosum_judge(r, target); } vector\u0026lt;int\u0026gt; twoSum3(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) // 第三版本新增排序 { vector\u0026lt;int\u0026gt; nums_sort = twosum_sort(nums); vector\u0026lt;int\u0026gt; r = twosum_filter(nums_sort, target); return twosum_judge(r, target); } private: vector\u0026lt;int\u0026gt; twosum_sort(vector\u0026lt;int\u0026gt; \u0026amp;nums) // 排序 { vector\u0026lt;int\u0026gt; r = nums; int len = nums.size(); int rr = 0; while (len \u0026gt; 1) { for (int i = 0; i \u0026lt; len - 1; i++) { if (r[i] \u0026gt; r[i + 1]) { rr = r[i]; r[i] = r[i + 1]; r[i + 1] = rr; } } len--; } return r; } vector\u0026lt;int\u0026gt; twosum_filter(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) // 判斷數字是否大於目標數 { vector\u0026lt;int\u0026gt; r = {}; for (unsigned long n = 0; n \u0026lt; nums.size(); n++) { if (nums[n] \u0026lt; target) { r.push_back(nums[n]); } } return r; } vector\u0026lt;int\u0026gt; twosum_judge(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) // 相加 { for (unsigned long n = 0; n \u0026lt; nums.size(); n++) { for (unsigned long i = 1; i \u0026lt; nums.size(); i++) { if (nums[n] + nums[i] == target) { return {nums[n], nums[i]}; } } } return {}; } }; int main() { Solution s; vector\u0026lt;int\u0026gt; nums = {11, 7, 15, 2}; vector\u0026lt;int\u0026gt; v = s.twoSum3(nums, 9); if (v.empty()) // 判斷是否資料 { printf(\u0026#34;p:\\n\u0026#34;); } else { printf(\u0026#34;p:\u0026#34;); for (unsigned long n = 0; n \u0026lt; v.size(); n++) { cout \u0026lt;\u0026lt; v[n]; if (n \u0026lt; v.size() - 1) { cout \u0026lt;\u0026lt; \u0026#34;、\u0026#34;; } } cout \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/practice/04/","summary":"這篇是C++的練習實作第04篇","title":"C++語言的練習-Two Sum"},{"content":"FreeRTOS 這篇是esp的練習筆記第09篇\nFreeRTOS是esp32用來協調同時執行緒。\nvoid A(void *n){ while(true){ Serial.println(\u0026#34;A\u0026#34;); vTaskDelay(1000/portTICK_PERIOD_MS);//跟delay一樣，但使用Freertos時要使用vTaskDelay } } void B(void *n){ while(true){ Serial.println(\u0026#34;B\u0026#34;); } } void setup() { Serial.begin(115200); xTaskCreate(A/*函數*/,\u0026#34;A\u0026#34;/*描述*/,1000/*記憶體大小*/,NULL,1/*優先度*/,NULL);//建立任務 xTaskCreate(B,\u0026#34;B\u0026#34;,1000,NULL,2,NULL); } void loop() { } 如果需要不想B一直執行，可以使用函式解決\n如果都是B執行，有可能會觸發wdt，造成以為當機發生錯誤。\n#include \u0026lt;esp_task_wdt.h\u0026gt; void A(void *n){ while(true){ Serial.println(\u0026#34;A\u0026#34;); } } void B(void *n){ while(true){ Serial.println(\u0026#34;B\u0026#34;); //yield();//退讓優先權，結果會大多都是B //taskYIELD();//重新確認優先權，結果大多都是Ｂ //vTaskDelay(1);//延遲，結果會大多都是Ａ esp_task_wdt_reset();//重置wdt } } void setup() { Serial.begin(115200); disableCore0WDT();//關閉wdt xTaskCreate(A/*函數*/,\u0026#34;A\u0026#34;/*描述*/,1000/*記憶體大小*/,NULL,1/*優先度*/,NULL);//建立任務 xTaskCreate(B,\u0026#34;B\u0026#34;,1000,NULL,2,NULL); } void loop() { } 除了用上述方法，也能直接對任務進行更動，刪除或是更改優先度\n在實驗時發現i加到24後if才會作用。\nTaskHandle_t thb = NULL;//任務參照 void A(void *n){ while(true){ Serial.print(\u0026#34;A:\u0026#34;); Serial.println(i); i++; if(i \u0026gt;= 50){ vTaskPrioritySet( thb , 3);//設定優先度 } yield(); } } void B(void *n){ while(true){ Serial.print(\u0026#34;B:\u0026#34;); Serial.print(i); Serial.print(\u0026#34;:\u0026#34;); Serial.println(uxTaskPriorityGet(thb));//取得優先度 if(i\u0026gt;=60){ vTaskDelete(thb);//刪除任務 } yield(); } } void setup() { Serial.begin(115200); Serial.println(\u0026#34;............\u0026#34;); xTaskCreate(A/*函數*/,\u0026#34;A\u0026#34;/*描述*/,1000/*記憶體大小*/,NULL,2/*優先度*/,NULL);//建立任務 xTaskCreate(B,\u0026#34;B\u0026#34;,1000,NULL,1,\u0026amp;thb); } void loop() { } ","permalink":"https://tom8760925.github.io/tomku/esp/no/09/","summary":"這篇是esp的練習筆記第09篇","title":"esp的練習-FreeRTOS"},{"content":"藍芽 這篇是esp的練習筆記第08篇\n使用esp32開啟藍芽。\n#include \u0026lt;BluetoothSerial.h\u0026gt; BluetoothSerial BT; void setup() { Serial.begin(115200); BT.begin(\u0026#34;xxx\u0026#34;);//開啟藍牙，輸入藍牙名稱 } void loop() { if (Serial.available()) { BT.write(Serial.read()); } if (BT.available()) { Serial.println(BT.readString()); } delay(50); } ","permalink":"https://tom8760925.github.io/tomku/esp/no/08/","summary":"這篇是esp的練習筆記第08篇","title":"esp的練習-藍芽"},{"content":"SPIFFS 這篇是esp的練習筆記第07篇\n快閃記憶體內有SPIFFS分區可以使用，而SPIFFS分區可以依照設定更改內容大小。\n工具-\u0026gt;Partition Scheme 預設-\u0026gt;依照需求選擇 #include \u0026lt;SPIFFS.h\u0026gt;//載入SPIFFS void wf(){ File file = SPIFFS.open(\u0026#34;/test.txt\u0026#34;,\u0026#34;w\u0026#34;);//寫入檔案 if(!file){//檢測是否打開 Serial.println(\u0026#34;p:w\u0026#34;); return; } file.println(\u0026#34;11\u0026#34;);//寫入資料 file.println(\u0026#34;22\u0026#34;);//寫入資料 file.close();//關掉檔案 } void rf(){ File file = SPIFFS.open(\u0026#34;/test.txt\u0026#34;,\u0026#34;r\u0026#34;);//讀取檔案 if(!file){//檢測是否打開 Serial.println(\u0026#34;p:r\u0026#34;); return; } Serial.printf(\u0026#34;size:%d\\n\u0026#34;,file.size());//檔案大小 Serial.println(\u0026#34;p:\u0026#34;); while(file.available()){//讀取檔案內容 Serial.write(file.read());//讀取一行 } file.close();//關掉檔案 } void lf(){ File root = SPIFFS.open(\u0026#34;/\u0026#34;);//開啟根目錄 File file =root.openNextFile();//開啟下一個檔案 while(file){ Serial.printf(\u0026#34;p:%s\\n\u0026#34;,file.name());//檔案名稱 file =root.openNextFile();//開啟下一個檔案 } file.close();//關掉檔案 } void setup() { Serial.begin(115200); if(!SPIFFS.begin(true)){//掛載SPIFFS是否成功 Serial.println(\u0026#34;XXX\u0026#34;); } wf(); rf(); lf(); Serial.printf(\u0026#34;p:%u\\n\u0026#34;,SPIFFS.totalBytes());//內容總共大小 Serial.printf(\u0026#34;p:%u\\n\u0026#34;,SPIFFS.usedBytes());//以使用內容大小 } void loop() { } ","permalink":"https://tom8760925.github.io/tomku/esp/no/07/","summary":"這篇是esp的練習筆記第07篇","title":"esp的練習-SPIFFS"},{"content":"睡眠模式 這篇是esp的練習筆記第06篇\nesp32有深度睡眠和輕度睡眠。\nRTC_DATA_ATTR int wakes = 0;//使用RTC記憶體 void tai(){ } void setup(){ Serial.begin(115200); Serial.printf(\u0026#34;p:%d\\n\u0026#34;,wakes); wakes++; delay(1000); Serial.println(\u0026#34;ZZZ\u0026#34;); delay(1000); touchAttachInterrupt(15,tai,40);//執行接觸中斷 esp_sleep_enable_touchpad_wakeup();//執行接觸喚醒 //esp_sleep_enable_timer_wakeup(5*1000000);//啟動定時喚醒 //esp_light_sleep_start();//輕度睡眠 esp_deep_sleep_start();//進入深度睡眠 } void loop(){ } ","permalink":"https://tom8760925.github.io/tomku/esp/no/06/","summary":"這篇是esp的練習筆記第06篇","title":"esp的練習-睡眠模式"},{"content":"webserver 這篇是esp的練習筆記第05篇\n#include \u0026lt;WiFi.h\u0026gt; //載入WIFI #include \u0026lt;WebServer.h\u0026gt; //載入webserver const char *ssid = \u0026#34;xxx\u0026#34;; // 設定ssid const char *password = \u0026#34;xxx\u0026#34;; // 設定密碼 WebServer server(80); // 設定port號 void h1()//網站內容 { String Html = \u0026#34;\u0026lt;p\u0026gt;11\u0026lt;/p\u0026gt;\u0026#34;; server.send(200, \u0026#34;text/html\u0026#34;, Html); } void h2()//網站內容 { String state = server.arg(\u0026#34;data\u0026#34;);//get或post的內容 String Html = \u0026#34;\u0026lt;p\u0026gt;\u0026#34; + state + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; server.send(200, \u0026#34;text/html\u0026#34;, Html); } void setup() { Serial.begin(115200); // 設定波長 WiFi.begin(ssid,password); // 連接WIFI，如果沒有密碼就只要WiFi.begin(ssid); while (WiFi.status() != WL_CONNECTED) { // 測試是否連接 delay(500); Serial.print(\u0026#34;.\u0026#34;); } Serial.println(); Serial.print(\u0026#34;IP:\u0026#34;); Serial.println(WiFi.localIP()); // 顯示IP server.on(\u0026#34;/\u0026#34;, h1);//網址跟網站內容 server.on(\u0026#34;/in\u0026#34;, h2);//網址跟網站內容 server.onNotFound([]() { String Html =\u0026#34;\u0026lt;p\u0026gt;404\u0026lt;/p\u0026gt;\u0026#34;; server.send(404,\u0026#34;text/html\u0026#34;,Html); });//錯誤網址顯示 server.begin();//啟動網站 } void loop() { server.handleClient();//使用者端連線 } ","permalink":"https://tom8760925.github.io/tomku/esp/no/05/","summary":"這篇是esp的練習筆記第05篇","title":"esp的練習-webserver"},{"content":"中斷處理 這篇是esp的練習筆記第04篇\n外部中斷 當檢測到接腳的狀態更改時會執行中斷，檢測接腳為0V和5V或3V\n中斷的模式有五種，這篇使用HIGH模式進行測試\n將接腳18接腳插入3.3V的接腳時，會觸發中斷\nconst byte p = 18; void IRAM_ATTR ISRF(){ Serial.begin(115200);//設定波長 Serial.print(\u0026#34;p:\u0026#34;); Serial.print(digitalRead(p));//檢測訊號 Serial.println(\u0026#34;:FALLING\u0026#34;); } void IRAM_ATTR ISRR(){ Serial.begin(115200);//設定波長 Serial.print(\u0026#34;p:\u0026#34;); Serial.print(digitalRead(p));//檢測訊號 Serial.println(\u0026#34;:RISING\u0026#34;); } void IRAM_ATTR ISRC(){ Serial.begin(115200);//設定波長 Serial.print(\u0026#34;p:\u0026#34;); Serial.print(digitalRead(p));//檢測訊號 Serial.println(\u0026#34;:CHANGE\u0026#34;); } void IRAM_ATTR ISRL(){ Serial.begin(115200);//設定波長 Serial.print(\u0026#34;p:\u0026#34;); Serial.print(digitalRead(p));//檢測訊號 Serial.println(\u0026#34;:LOW\u0026#34;); } void IRAM_ATTR ISRH(){ Serial.begin(115200);//設定波長 Serial.print(\u0026#34;p:\u0026#34;); Serial.print(digitalRead(p));//檢測訊號 Serial.println(\u0026#34;:HIGH\u0026#34;); } void setup() { pinMode(p, OUTPUT); //attachInterrupt(p,ISRF,FALLING);//測下降 //attachInterrupt(p,ISRR,RISING);//測上降 //attachInterrupt(p,ISRC,CHANGE);//測下降上降 //attachInterrupt(p,ISRL,LOW);//測低 attachInterrupt(p,ISRH,HIGH);//測高 } void loop() { Serial.begin(115200);//設定波長 Serial.print(\u0026#34;p:\u0026#34;); Serial.println(digitalRead(p));//檢測訊號 delay(1000); } ","permalink":"https://tom8760925.github.io/tomku/esp/no/04/","summary":"這篇是esp的練習筆記第04篇","title":"esp的練習-中斷處理"},{"content":"觸控類比訊號 這篇是esp的練習筆記第03篇\n將開發板的A0連接電線和3.3V連接電線\n如果將兩條電線捏著，監視窗接收的訊號因該會超過100，反之沒有捏著接收訊號會很低。\nvoid setup() { } void loop() { Serial.begin(115200);//設定波長 Serial.print(\u0026#34;p:\u0026#34;); Serial.println(analogRead(A0));//檢測類比訊號 delay(1000); } ","permalink":"https://tom8760925.github.io/tomku/esp/no/03/","summary":"這篇是esp的練習筆記第03篇","title":"esp的練習-觸控類比訊號"},{"content":"連接WIFI 這篇是esp的練習筆記第02篇\n#include \u0026lt;ESP8266WiFi.h\u0026gt;//載入WIFI const char *ssid = \u0026#34;xxx\u0026#34;;//設定ssid const char *password = \u0026#34;xxx\u0026#34;;//設定密碼 void setup() { Serial.begin(115200);//設定波長 WiFi.begin(ssid,password);//連接WIFI，如果沒有密碼就只要WiFi.begin(ssid); while (WiFi.status() != WL_CONNECTED){//測試是否連接 delay(500); Serial.print(\u0026#34;.\u0026#34;); } Serial.println(); Serial.print(\u0026#34;IP:\u0026#34;); Serial.println(WiFi.localIP());//顯示IP Serial.print(\u0026#34;RSSI:\u0026#34;); Serial.println(WiFi.RSSI());//顯示訊號強度 Serial.println(); } void loop() { delay(2000); Serial.print(\u0026#34;RSSI:\u0026#34;); Serial.println(WiFi.RSSI()); } ","permalink":"https://tom8760925.github.io/tomku/esp/no/02/","summary":"這篇是esp的練習筆記第02篇","title":"esp的練習-連接WIFI"},{"content":"環境設置 這篇是esp的練習筆記第01篇\n這篇Arduino IDE以使用MAC操作esp8266\n安裝Arduino IDE 到官網安裝\nhttps://www.arduino.cc/en/software 使用esp8266 遮篇開始是使用esp8266的開發板\n首先將開發板連接到MAC，將連接許可\n接著設定Arduino IDE\n偏好設定-\u0026gt;其他開發板管理員網址-\u0026gt;加入這兩個網址( http://arduino.esp8266.com/stable/package_esp8266com_index.json https://dl.espressif.com/dl/package_esp32_index.json ) 開發板管理員-\u0026gt;安裝兩個( esp32 esp8266 ) 工具-\u0026gt;開發板-\u0026gt;Generic ESP8266 Module 工具-\u0026gt;連接埠-\u0026gt;選擇出現的連接埠 使用內建的內建LED閃爍範例，進行測試\n檔案-\u0026gt;範例-\u0026gt;01.basics-\u0026gt;blink 沒問題的話，開發板上的LED會開始閃爍\n","permalink":"https://tom8760925.github.io/tomku/esp/no/01/","summary":"這篇是esp的練習筆記第01篇","title":"esp的練習-環境設置"},{"content":"x11vnc 這篇是x11vnc的筆記 安裝x11vnc\nsudo apt-get install x11vnc 設定密碼\nx11vnc -storepasswd 啟動x11vnc，會顯示port號\nx11vnc -forever -usepw -localhost -rfbport 5901 -display :0 -usepw 使用密碼 -forever 不會斷開時關閉 -localhost 限本地端連線 -rfbport 5901 連線的port號 ssh連線 建立通道\nssh -fNL 5961:localhost:5901(設定port號:localhost:vnc port號) user@ip 進行vnc連線，ip要輸入localhost，port要輸入5961\n","permalink":"https://tom8760925.github.io/tomku/other/notes/vnc/","summary":"這篇是vnc的筆記","title":"其他的筆記-x11vnc"},{"content":"主題Menus 這篇是hugo的筆記第02篇\n主題的Menus筆記 hugo.toml\n[[menus.main2]] identifier = \u0026#39;test\u0026#39; title = \u0026#39;test3\u0026#39; name = \u0026#39;test\u0026#39; pageRef = \u0026#39;/\u0026#39; weight = 10 post = \u0026#39;:point_left:\u0026#39; pre = \u0026#39;:point_right:\u0026#39; [menus.main2.params] p = \u0026#39;a\u0026#39; [[menus.main2]] identifier = \u0026#39;test2\u0026#39; title = \u0026#39;test3\u0026#39; name = \u0026#39;test2\u0026#39; pageRef = \u0026#39;/test2\u0026#39; weight = 20 post = \u0026#39;:point_left:\u0026#39; pre = \u0026#39;:point_right:\u0026#39; [menus.main2.params] p = \u0026#39;b\u0026#39; [[menus.main2]] identifier = \u0026#39;test3\u0026#39; title = \u0026#39;test3\u0026#39; name = \u0026#39;test3\u0026#39; pageRef = \u0026#39;/test3\u0026#39; parent = \u0026#39;testtt\u0026#39; weight = 30 post = \u0026#39;:point_left:\u0026#39; pre = \u0026#39;:point_right:\u0026#39; [menus.main2.params] p = \u0026#39;c\u0026#39; {{ with index site.Menus \u0026#34;main2\u0026#34; }} \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;--Children---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Children}}\u0026lt;/li\u0026gt;{{/*子選單*/}} {{ end }} \u0026lt;li\u0026gt;---HasChildren--\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.HasChildren}}\u0026lt;/li\u0026gt;{{/*是否有子選單*/}} {{ end }} \u0026lt;li\u0026gt;--Identifier---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Identifier}}\u0026lt;/li\u0026gt;{{/*標示碼*/}} {{ end }} \u0026lt;li\u0026gt;--KeyName---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.KeyName}}\u0026lt;/li\u0026gt;{{/*鍵值*/}} {{ end }} \u0026lt;li\u0026gt;--Menu---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Menu}}\u0026lt;/li\u0026gt;{{/*Menu名稱*/}} {{ end }} \u0026lt;li\u0026gt;---Name--\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Name}}\u0026lt;/li\u0026gt;{{/*名稱*/}} {{ end }} \u0026lt;li\u0026gt;---Page--\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Page}}\u0026lt;/li\u0026gt;{{/*URL*/}} {{ end }} \u0026lt;li\u0026gt;---Params--\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{ with .Params.p }}{{ . }}{{ end }}\u0026lt;/li\u0026gt;{{/*傳送值*/}} {{ end }} \u0026lt;li\u0026gt;--Parent---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Parent}}\u0026lt;/li\u0026gt;{{/*傳送值*/}} {{ end }} \u0026lt;li\u0026gt;---Post--\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Post }}\u0026lt;/li\u0026gt;{{/*表情符號值1*/}} {{ end }} \u0026lt;li\u0026gt;--Pre---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Pre }}\u0026lt;/li\u0026gt;{{/*表情符號值2*/}} {{ end }} \u0026lt;li\u0026gt;--Title---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Title }}\u0026lt;/li\u0026gt;{{/*Title值*/}} {{ end }} \u0026lt;li\u0026gt;--URL---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.URL }}\u0026lt;/li\u0026gt;{{/*URL*/}} {{ end }} \u0026lt;li\u0026gt;--Weight---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Weight }}\u0026lt;/li\u0026gt;{{/*Weight*/}} {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; {{ end }} 結果\n--Children--- [] [] [0x140009ba8c0] ---HasChildren-- false false true --Identifier--- test test2 --KeyName--- test test2 testtt --Menu--- main2 main2 ---Name-- test test2 testtt ---Page-- Page(/) Page(/test2) ---Params-- a b --Parent--- ---Post-- :point_left: :point_left: --Pre--- :point_right: :point_right: --Title--- test3 test3 --URL--- / /test2/ --Weight--- 10 20 0 使用子選單\n{{ with index site.Menus \u0026#34;main2\u0026#34; }} \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; {{ range .}} {{ with .Children }} \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;--Name---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{.Name}}\u0026lt;/li\u0026gt;{{/*名稱*/}} {{ end }} \u0026lt;li\u0026gt;--Params---\u0026lt;/li\u0026gt; {{ range .}} \u0026lt;li\u0026gt;{{ with .Params.p }}{{ . }}{{ end }}\u0026lt;/li\u0026gt;{{/*傳送值*/}} {{ end }} \u0026lt;/ul\u0026gt; {{ end }} {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; {{ end }} 結果\n--Name--- test3 --Params--- c ","permalink":"https://tom8760925.github.io/tomku/hugo/notes/02/","summary":"這篇是hugo的筆記第02篇","title":"hugo的筆記-主題Menus"},{"content":"指令 這篇是hugo的筆記第01篇\n記錄指令\nhugo new site 名稱 //新增hugo hugo new theme 名稱 //新增主題 hugo new content 位子和名稱 //新增內容 hugo new -k 原型 位子和名稱 // 指定原型新增內容 hugo server //開起伺服器 hugo server -D //開起測試伺服器 hugo // 輸出網頁 ","permalink":"https://tom8760925.github.io/tomku/hugo/notes/01/","summary":"這篇是hugo的筆記第01篇","title":"hugo的筆記-指令"},{"content":"指令 這篇是git的筆記第01篇\n記錄git指令\ngit init //初始化 git clone 網址 //複製 git status //查詢狀態 git add 檔案 //加入暫存，.是全部 git restore --staged //取消暫存 git commit //提交修改，會需要使用vim進行編輯，可以使用-m後面加上提交訊息就可以。 git push //推送 git pull //接收 git log //查詢記錄 git merge 分區名稱 //查詢分區狀態 git branch 分區名稱 //新增分區 git branch -d 分區名稱 //刪除分區 git branch -a 分區名稱 //顯示所有分區 git branch -f 分區名稱 //顯示遠端分區 git checkout 分區名稱 //切換分區 git push origin 分區名稱 //推送到指定分區 git pull origin 分區名稱 //接收到指定分區 git rm 檔案 //刪除檔案 git mv 檔案 //改檔案名稱 git diff //顯示差異 git merge 分區名稱 //合併分區 記錄vim離開指令\nshift+:+q ","permalink":"https://tom8760925.github.io/tomku/git/notes/01/","summary":"這篇是git的筆記第01篇","title":"git的筆記-指令"},{"content":"mysql 這篇是C++的筆記第18篇\nc++的mysql練習，在vs2022上進行操作。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mysql_connection.h\u0026gt; #include \u0026lt;mysql_driver.h\u0026gt; #include \u0026lt;cppconn/resultset.h\u0026gt; #include \u0026lt;cppconn/statement.h\u0026gt; using namespace std; void sf();//收尋 void ii();//新增 void us();//修改 void df();//刪除 string ip = \u0026#34;tcp://localhost:3306\u0026#34;; string user = \u0026#34;root\u0026#34;; string password = \u0026#34;password\u0026#34;; int main() { sf(); } void sf() { try { sql::mysql::MySQL_Driver* driver;//宣告 sql::Connection* con;//宣告 driver = sql::mysql::get_mysql_driver_instance(); con = driver-\u0026gt;connect(ip, user, password);//輸入IP、USER、PASSWORD con-\u0026gt;setSchema(\u0026#34;test\u0026#34;);//輸入資料庫名稱 sql::Statement* stmt;//宣告 stmt = con-\u0026gt;createStatement();//啟動連接 string selectDataSQL = \u0026#34;SELECT * FROM tests\u0026#34;;//SQL語法 sql::ResultSet* res = stmt-\u0026gt;executeQuery(selectDataSQL);//執行SQL語法 int count = 1; while (res-\u0026gt;next()) {//依照每一筆輸出 cout \u0026lt;\u0026lt; \u0026#34;id\u0026#34; \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; res-\u0026gt;getString(\u0026#34;id\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;v\u0026#34; \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; res-\u0026gt;getString(\u0026#34;v\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;i\u0026#34; \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; res-\u0026gt;getString(\u0026#34;i\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;ii\u0026#34; \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; res-\u0026gt;getString(\u0026#34;ii\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;count:\u0026#34;\u0026lt;\u0026lt;count++\u0026lt;\u0026lt;\u0026#34;-----\u0026#34; \u0026lt;\u0026lt; endl; } delete res;//關閉 delete stmt;//關閉 delete con;//關閉 } catch (sql::SQLException\u0026amp; e) {//錯誤 std::cerr \u0026lt;\u0026lt; \u0026#34;SQL Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl;//錯誤輸出 } } void ii() { try { sql::mysql::MySQL_Driver* driver; sql::Connection* con; driver = sql::mysql::get_mysql_driver_instance(); con = driver-\u0026gt;connect(ip, user, password); con-\u0026gt;setSchema(\u0026#34;test\u0026#34;); sql::Statement* stmt; stmt = con-\u0026gt;createStatement(); string i = \u0026#34;INSERT INTO tests (v,i,ii) VALUES (\u0026#39;C\u0026#39;, 3, 3)\u0026#34;; stmt-\u0026gt;execute(i);// delete stmt; delete con; } catch (sql::SQLException\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;SQL Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } void us() { try { sql::mysql::MySQL_Driver* driver; sql::Connection* con; driver = sql::mysql::get_mysql_driver_instance(); con = driver-\u0026gt;connect(ip, user, password); con-\u0026gt;setSchema(\u0026#34;test\u0026#34;); sql::Statement* stmt; stmt = con-\u0026gt;createStatement(); string u = \u0026#34;UPDATE tests SET ii=3 WHERE id=\u0026#39;2\u0026#39;\u0026#34;; stmt-\u0026gt;executeUpdate(u); delete stmt; delete con; } catch (sql::SQLException\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;SQL Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } void df() { try { sql::mysql::MySQL_Driver* driver; sql::Connection* con; driver = sql::mysql::get_mysql_driver_instance(); con = driver-\u0026gt;connect(ip, user, password); con-\u0026gt;setSchema(\u0026#34;test\u0026#34;); sql::Statement* stmt; stmt = con-\u0026gt;createStatement(); string d = \u0026#34;DELETE FROM tests WHERE id=\u0026#39;3\u0026#39;\u0026#34;; stmt-\u0026gt;execute(d); delete stmt; delete con; } catch (sql::SQLException\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;SQL Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } ","permalink":"https://tom8760925.github.io/tomku/c++/notes/18/","summary":"這篇是C++的筆記第18篇","title":"C++語言的筆記-mysql"},{"content":"mutex 這篇是C++的筆記第17篇\nmutex 使用thread時，可會造成結果不可預期如下面範例，使用mutex可以解決如下面範例，因為在設定的範圍內會先讓先執行的thread執行完後， 才會換下一個thread執行。 沒使用mutex\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mmutex; int n = 0; void a(char b) { // mmutex.lock(); for (int i = 0; i \u0026lt;= 5; i++) { printf(\u0026#34;p:%d(%c)\\n\u0026#34;, i, b); ++n; } // mmutex.unlock(); } int main() { std::thread t1(a, \u0026#39;A\u0026#39;); std::thread t2(a, \u0026#39;B\u0026#39;); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; return 0; } 結果\np:0(A) p:0(B) p:1(A) p:2(A) p:3(A) p:4(A) p:5(A) p:1(B) p:2(B) p:3(B) p:4(B) p:5(B) p：11 有使用mutex\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mmutex;//宣告 int n = 0; void a(char b) { mmutex.lock();//鎖上 for (int i = 0; i \u0026lt;= 5; i++) { printf(\u0026#34;p:%d(%c)\\n\u0026#34;, i, b); ++n; } mmutex.unlock();//解鎖 } int main() { std::thread t1(a, \u0026#39;A\u0026#39;); std::thread t2(a, \u0026#39;B\u0026#39;); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; return 0; } 結果\np:0(A) p:1(A) p:2(A) p:3(A) p:4(A) p:5(A) p:0(B) p:1(B) p:2(B) p:3(B) p:4(B) p:5(B) p：12 lock_guard 自動上鎖和解鎖。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mmutex; int n = 0; void a(char b) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mmutex); // 自動上鎖，程序結束後自動解鎖 for (int i = 0; i \u0026lt;= 5; i++) { printf(\u0026#34;p:%d(%c)\\n\u0026#34;, i, b); ++n; } } int main() { std::thread t1(a, \u0026#39;A\u0026#39;); std::thread t2(a, \u0026#39;B\u0026#39;); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; return 0; } 結果\np:0(A) p:1(A) p:2(A) p:3(A) p:4(A) p:5(A) p:0(B) p:1(B) p:2(B) p:3(B) p:4(B) p:5(B) p：12 unique_lock 跟lock_guard類似，但可以自行選擇哪裡上鎖和解鎖。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; std::mutex mmutex; int n = 0; void a(char b) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mmutex); // 自動上鎖，程序結束後自動解鎖，可以選擇哪裡上鎖和解鎖，lock_guard沒有這個功能。 for (int i = 0; i \u0026lt;= 5; i++) { printf(\u0026#34;p:%d(%c)\\n\u0026#34;, i, b); ++n; } lock.unlock(); } int main() { std::thread t1(a, \u0026#39;A\u0026#39;); std::thread t2(a, \u0026#39;B\u0026#39;); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; return 0; } 結果\np:0(B) p:1(B) p:2(B) p:3(B) p:4(B) p:5(B) p:0(A) p:1(A) p:2(A) p:3(A) p:4(A) p:5(A) p：12 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/17/","summary":"這篇是C++的筆記第17篇","title":"C++語言的筆記-mutex"},{"content":"thread 這篇是C++的筆記第16篇\nfork像是將主程式複製後例外開新的資源執行，thread像是在主程式中分割出資源執行程序\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; void a() { printf(\u0026#34;p:a\\n\u0026#34;); } void b(int n) { printf(\u0026#34;p:%d\\n\u0026#34;, n); } int main() { std::thread t1(a); // 啟動程序 std::thread t2(b, 1); // 啟動程序，但編譯器有可能會顯示，但是是沒問題的可以跑的 printf(\u0026#34;---\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; t1.get_id() \u0026lt;\u0026lt; std::endl; // ID std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; t2.get_id() \u0026lt;\u0026lt; std::endl; // ID printf(\u0026#34;----\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; t1.joinable() \u0026lt;\u0026lt; std::endl; // 程序的狀態 std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; t2.joinable() \u0026lt;\u0026lt; std::endl; // 程序的狀態 printf(\u0026#34;----\\n\u0026#34;); t1.join();//暫停等待程序完成 t2.join(); printf(\u0026#34;----\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; t1.joinable() \u0026lt;\u0026lt; std::endl; // 程序的狀態 std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; t2.joinable() \u0026lt;\u0026lt; std::endl; // 程序的狀態 printf(\u0026#34;----\\n\u0026#34;); return 0; } 結果\np:a --- p:p:1 0x16d6a3000 p:0x16d72f000 ---- p:1 p:1 ---- ---- p:0 p:0 ---- 其他 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;unistd.h\u0026gt; void a() { std::thread::id this_id = std::this_thread::get_id(); // 顯示ID std::cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; this_id \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; } void b(int n) { while (true) { printf(\u0026#34;p:%d\\n\u0026#34;, n); if (n == 3) { break; } std::chrono::milliseconds dura(5000); // 設定時間這邊設定5秒 std::this_thread::sleep_for(dura); // 暫停程序執行 n++; } } int main() { std::thread t1(a); // 啟動執行 std::thread t2(b, 1); // 啟動執行，但編譯器有可能會顯示，但是是沒問題的可以跑的 printf(\u0026#34;---\\n\u0026#34;); t1.join(); t2.join(); return 0; } 結果\n--- p:0x16aff3000 p:1 p:2 p:3 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/16/","summary":"這篇是C++的筆記第16篇","title":"C++語言的筆記-thread"},{"content":"exec 這篇是C++的筆記第15篇\nexecl、execv 執行程式 第一個\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { int x, r; pid_t pid = fork(); // 建立新程序 if (pid == 0) // 子 { pid_t pid1 = fork(); // 建立新程序 if (pid1 == 0) // 子 { char *argv[] = {NULL}; // 參數 r = execv(\u0026#34;./2\u0026#34;, argv); if (r == -1) perror(\u0026#34;execl error\u0026#34;); } else if (pid1 \u0026gt; 0) // 父 { char *argv[] = {\u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, NULL}; // 參數 r = execv(\u0026#34;/bin/ls\u0026#34;, argv); if (r == -1) perror(\u0026#34;execl error\u0026#34;); wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } } else if (pid \u0026gt; 0) // 父 { pid_t pid1 = fork(); // 建立新程序 if (pid1 == 0) // 子 { r = execl(\u0026#34;./2\u0026#34;, NULL); if (r == -1) perror(\u0026#34;execl error\u0026#34;); } else if (pid1 \u0026gt; 0) // 父 { r = execl(\u0026#34;/bin/ls\u0026#34;, \u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, NULL); if (r == -1) perror(\u0026#34;execl error\u0026#34;); wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } return 0; } 第二個\n#include \u0026lt;iostream\u0026gt; int main() { printf(\u0026#34;p:test\\n\u0026#34;); return 0; } 結果\np:test p:test total 216 total 216 -rwxr-xr-x 1 use staff 34032 5 2 10:33 1 drwxr-xr-x 3 use staff 96 5 2 09:34 1.dSYM -rwxr-xr-x 1 use staff 33696 5 2 09:49 2 drwxr-xr-x 3 use staff 96 5 2 09:49 2.dSYM -rwxr-xr-x 1 use staff 34032 5 2 10:33 1 drwxr-xr-x 3 use staff 96 5 2 09:34 1.dSYM -rwxr-xr-x 1 use staff 33696 5 2 09:49 2 drwxr-xr-x 3 use staff 96 5 2 09:49 2.dSYM execle、execve 執行程式並傳送參數\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { int x, r; pid_t pid = fork(); // 建立新程序 if (pid == 0) // 子 { pid_t pid1 = fork(); // 建立新程序 if (pid1 == 0) // 子 { char *argv[] = {NULL}; char *envp[] = {\u0026#34;A=1\u0026#34;, \u0026#34;B=2\u0026#34;, NULL}; r = execve(\u0026#34;./4\u0026#34;, argv, envp); if (r == -1) perror(\u0026#34;execvp error\u0026#34;); } else if (pid1 \u0026gt; 0) // 父 { char *argv[] = {\u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, NULL}; char *envp[] = {NULL}; r = execve(\u0026#34;/bin/ls\u0026#34;, argv, envp); if (r == -1) perror(\u0026#34;execvp error\u0026#34;); wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } } else if (pid \u0026gt; 0) // 父 { pid_t pid1 = fork(); // 建立新程序 if (pid1 == 0) // 子 { } else if (pid1 \u0026gt; 0) // 父 { char *envp[] = {NULL}; r = execle(\u0026#34;/bin/ls\u0026#34;, \u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, NULL, envp); if (r == -1) perror(\u0026#34;execl error\u0026#34;); wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } return 0; } 結果\nA=1 B=2 total 288 total 288 -rwxr-xr-x 1 use staff 34032 May 2 10:33 1 drwxr-xr-x 3 use staff 96 May 2 09:34 1.dSYM -rwxr-xr-x 1 use staff 33696 May 2 09:49 2 drwxr-xr-x 3 use staff 96 May 2 09:49 2.dSYM -rwxr-xr-x 1 use staff 34032 May 2 11:33 3 drwxr-xr-x 3 use staff 96 May 2 10:09 3.dSYM -rwxr-xr-x 1 use staff 33744 May 2 11:28 4 drwxr-xr-x 3 use staff 96 May 2 11:28 4.dSYM -rwxr-xr-x 1 use staff 34032 May 2 10:33 1 drwxr-xr-x 3 use staff 96 May 2 09:34 1.dSYM -rwxr-xr-x 1 use staff 33696 May 2 09:49 2 drwxr-xr-x 3 use staff 96 May 2 09:49 2.dSYM -rwxr-xr-x 1 use staff 34032 May 2 11:33 3 drwxr-xr-x 3 use staff 96 May 2 10:09 3.dSYM -rwxr-xr-x 1 use staff 33744 May 2 11:28 4 drwxr-xr-x 3 use staff 96 May 2 11:28 4.dSYM execlp、execvp 不用輸入路徑，會自動去環境變數找。\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { int x, r; pid_t pid = fork(); // 建立新程序 if (pid == 0) // 子 { pid_t pid1 = fork(); // 建立新程序 if (pid1 == 0) // 子 { } else if (pid1 \u0026gt; 0) // 父 { char *argv[] = {\u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, NULL}; r = execvp(\u0026#34;ls\u0026#34;, argv); if (r == -1) perror(\u0026#34;execvp error\u0026#34;); wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } } else if (pid \u0026gt; 0) // 父 { pid_t pid1 = fork(); // 建立新程序 if (pid1 == 0) // 子 { } else if (pid1 \u0026gt; 0) // 父 { r = execlp(\u0026#34;ls\u0026#34;, \u0026#34;ls\u0026#34;, \u0026#34;-l\u0026#34;, NULL); if (r == -1) perror(\u0026#34;execl error\u0026#34;); wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } wait(\u0026amp;x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } return 0; } 結果\ntotal 432 total 432 -rwxr-xr-x 1 use staff 34032 5 2 10:33 1 drwxr-xr-x 3 use staff 96 5 2 09:34 1.dSYM -rwxr-xr-x 1 use staff 33696 5 2 09:49 2 drwxr-xr-x 3 use staff 96 5 2 09:49 2.dSYM -rwxr-xr-x 1 use staff 34032 5 2 11:35 3 drwxr-xr-x 3 use staff 96 5 2 10:09 3.dSYM -rwxr-xr-x 1 use staff 33744 5 2 11:28 4 drwxr-xr-x 3 use staff 96 5 2 11:28 4.dSYM -rwxr-xr-x 1 use staff 34032 5 2 10:33 1 -rwxr-xr-x 1 use staff 34032 5 2 12:00 5 drwxr-xr-x 3 use staff 96 5 2 11:44 5.dSYM drwxr-xr-x 3 use staff 96 5 2 09:34 1.dSYM -rwxr-xr-x 1 use staff 33744 5 2 11:39 6 -rwxr-xr-x 1 use staff 33696 5 2 09:49 2 drwxr-xr-x 3 use staff 96 5 2 11:39 6.dSYM drwxr-xr-x 3 use staff 96 5 2 09:49 2.dSYM -rwxr-xr-x 1 use staff 34032 5 2 11:35 3 drwxr-xr-x 3 use staff 96 5 2 10:09 3.dSYM -rwxr-xr-x 1 use staff 33744 5 2 11:28 4 drwxr-xr-x 3 use staff 96 5 2 11:28 4.dSYM -rwxr-xr-x 1 use staff 34032 5 2 12:00 5 drwxr-xr-x 3 use staff 96 5 2 11:44 5.dSYM -rwxr-xr-x 1 use staff 33744 5 2 11:39 6 drwxr-xr-x 3 use staff 96 5 2 11:39 6.dSYM ","permalink":"https://tom8760925.github.io/tomku/c++/notes/15/","summary":"這篇是C++的筆記第15篇","title":"C++語言的筆記-exec"},{"content":"fork 這篇是C++的筆記第14篇\nc++有fork可以讓主程式和子程式同時執行，像是將主程式複製的。\n建立 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { int x = 1; pid_t pid = fork();//建立新程序 if (pid == 0)//子 { x--; printf(\u0026#34;p:%d\\n\u0026#34;, x); } else if (pid \u0026gt; 0)//父 { printf(\u0026#34;p:%d\\n\u0026#34;, x); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } return 0; } 結果\np:1 p:0 wait 如果子程序沒有執行完成，但父程序完成後就會關掉，造成子程序還在執行，變成殭屍程序。使用wait可以避免。\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { pid_t pid = fork(); // 建立新程序 if (pid == 0) // 子 { sleep(5); printf(\u0026#34;p:B(%d)\\n\u0026#34;, getpid()); } else if (pid \u0026gt; 0) // 父 { printf(\u0026#34;p:A(%d)\\n\u0026#34;, getpid()); wait(nullptr); printf(\u0026#34;p:---\\n\u0026#34;); } else { perror(\u0026#34;pid error\u0026#34;); exit(1); } return 0; } 結果\np:A(1755) p:B(1756) p:--- ","permalink":"https://tom8760925.github.io/tomku/c++/notes/14/","summary":"這篇是C++的筆記第14篇","title":"C++語言的筆記-fork"},{"content":"TCP/IP socket 03 這篇是C++的筆記第13篇\n學習select的使用。\n伺服器端 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;sys/time.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctime\u0026gt; int main() { struct sockaddr_in sinadd, cinadd; struct sockaddr_in cliall[1024]; socklen_t addlen; char indata[1024] = {0}, outdata[1024] = {0}; int sock, csock, crecv, ssel; int port = 8000; int on = 1; int maxfd = 0, maxi = 0; int client[1024]; fd_set fdread; // 有幾個連線 fd_set fdread2; // 有幾個連線 fd_set fdwrite; // 有幾個準備傳送資料 struct timeval tv; sock = socket(AF_INET, SOCK_STREAM, 0); // 設定通訊協定 if (sock == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } else { printf(\u0026#34;socket OK\\n\u0026#34;); } if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof(int)) == -1) // 設定為TCP，對bind設定釋放的通訊端立即可以使用 { perror(\u0026#34;setsockopt error\u0026#34;); exit(1); } else { printf(\u0026#34;setsockopt OK\\n\u0026#34;); } sinadd.sin_family = AF_INET; // 設定使用IP sinadd.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 設定IP，轉換成符合sin_addr的u_long sinadd.sin_port = htons(port); // 設定port號，轉換成網路序 // sin.sin_addr.s_addr = INADDR_ANY;//如果不指定ip，可以這樣用 if (bind(sock, (struct sockaddr *)\u0026amp;sinadd, sizeof(sinadd)) == -1) // 綁定ip和port，如果使用using namespace std;，這裡要加::不然會發生錯誤，因為會讓編譯器以為要使用std::bind造成錯誤。 { perror(\u0026#34;bind error\u0026#34;); exit(1); } else { printf(\u0026#34;bind OK\\n\u0026#34;); } printf(\u0026#34;server start at: %s:%d\\n\u0026#34;, inet_ntoa(sinadd.sin_addr), port); if (listen(sock, 5) == -1) // 監聽接口，接口數量最多5個 { perror(\u0026#34;listen error\u0026#34;); exit(1); } else { printf(\u0026#34;listen OK\\n\u0026#34;); } printf(\u0026#34;wait...\\n\u0026#34;); FD_ZERO(\u0026amp;fdread); // 清空 FD_ZERO(\u0026amp;fdwrite); // 清空 FD_SET(sock, \u0026amp;fdread); // 設定 FD_SET(sock, \u0026amp;fdwrite); // 設定 tv.tv_sec = 5; tv.tv_usec = 0; maxfd = sock; memset(client, -1, sizeof(int) * 1024); addlen = sizeof(cinadd); while (true) { FD_ZERO(\u0026amp;fdread2); // 清空 fdread2 = fdread; ssel = select(maxfd + 1, \u0026amp;fdread2, \u0026amp;fdwrite, (fd_set *)0, /*(struct timeval *)*/ \u0026amp;tv); // 監控描述符組，只要有事件就對變成1，例如socket的描述符是第3位置，有事件就會成1，，回傳值等於有幾個描述符在監控 if (ssel == -1) { perror(\u0026#34;recv error\u0026#34;); close(ssel); break; } else if (ssel == 0) { continue; } if (FD_ISSET(sock, \u0026amp;fdread2)) // 判斷描述黨是否為1 { int i = 0; csock = accept(sock, (struct sockaddr *)\u0026amp;cinadd, \u0026amp;addlen); // 等待請求 printf(\u0026#34;accept: %s:%d\\n\u0026#34;, inet_ntoa(cinadd.sin_addr), ntohs(cinadd.sin_port)); // 顯示請求的ip和port，ip轉換成十進位，port轉換成電腦序。 FD_SET(csock, \u0026amp;fdread); // 設定 for (; i \u0026lt; 1024; i++) // 將描述符和sockaddr_in記錄 { if (client[i] == -1) { client[i] = csock; cliall[i] = cinadd; break; } } if (csock \u0026gt; maxfd) // 更新最大值 maxfd = csock; if (i \u0026gt; maxi) // 更新最大值 maxi = i; if (ssel == 1) // 只有連線請求 { continue; } } for (int i = 0; i \u0026lt;= maxi; i++) { if (client[i] == -1) // 沒有描述符就跳過 continue; memset(indata, \u0026#39;\\0\u0026#39;, 1024); // 清空資料 memset(outdata, \u0026#39;\\0\u0026#39;, 1024); // 清空資料 if (FD_ISSET(client[i], \u0026amp;fdread2)) // 判斷是否接收資料請求 { crecv = recv(client[i], indata, sizeof(indata), 0); // 接收資料 if (crecv == -1) { perror(\u0026#34;recv error\u0026#34;); close(crecv); continue; } else if (crecv == 0) { printf(\u0026#34;close\\n\u0026#34;); FD_CLR(client[i], \u0026amp;fdread); FD_CLR(client[i], \u0026amp;fdwrite); client[i] = -1; close(client[i]); continue; } else { time_t now = time(0); printf(\u0026#34;%d:%d:%d \u0026#34;, localtime(\u0026amp;now)-\u0026gt;tm_hour, localtime(\u0026amp;now)-\u0026gt;tm_min, localtime(\u0026amp;now)-\u0026gt;tm_sec); // 輸出時間 printf(\u0026#34;%s:%d inout:%s\\n\u0026#34;, inet_ntoa(cliall[i].sin_addr), ntohs(cliall[i].sin_port), indata); FD_SET(csock, \u0026amp;fdwrite); } } if (FD_ISSET(client[i], \u0026amp;fdwrite)) // 判斷是否輸出資料請求 { strcpy(outdata, indata); if (send(client[i], outdata, strlen(outdata), 0) == -1) // 傳送資料 { perror(\u0026#34;send error\u0026#34;); continue; } FD_CLR(client[i], \u0026amp;fdwrite); } } } close(sock); return 0; } 用戶端 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;typeinfo\u0026gt; int main() { struct sockaddr_in sin; char indata[1024] = {0}, outdata[1024] = {0}; std::string inputfgets; int sock, crecv; // 設定通訊協定 int port = 8000; bool cin_while = true; sock = socket(AF_INET, SOCK_STREAM, 0); // 設定通訊協定 if (sock == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } else { printf(\u0026#34;socket OK\\n\u0026#34;); } sin.sin_family = AF_INET; // 設定使用IP sin.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 設定IP，轉換成符合sin_addr的u_long // sin.sin_addr.s_addr = INADDR_ANY;//如果不指定ip，可以這樣用 sin.sin_port = htons(port); // 設定port號，轉換成網路序 if (connect(sock, (struct sockaddr *)\u0026amp;sin, sizeof(sin)) == -1) // 綁定ip和port。 { perror(\u0026#34;connect error\u0026#34;); exit(1); } else { printf(\u0026#34;connect OK\\n\u0026#34;); } while (cin_while) { printf(\u0026#34;輸入1傳送資料\\n\u0026#34;); printf(\u0026#34;輸入2離開\\n\u0026#34;); printf(\u0026#34;P:\u0026#34;); std::cin \u0026gt;\u0026gt; inputfgets; try { switch (std::stoi(inputfgets)) { case 1: while (true) { memset(indata, \u0026#39;\\0\u0026#39;, 1024); // 等待請求 memset(outdata, \u0026#39;\\0\u0026#39;, 1024); // 等待請求 printf(\u0026#34;輸入exit結束資料輸入\\n\u0026#34;); printf(\u0026#34;p:\u0026#34;); std::cin \u0026gt;\u0026gt; outdata; // 輸入資料 if (strcmp(outdata, \u0026#34;exit\u0026#34;) == 0) { close(crecv); break; } send(sock, outdata, strlen(outdata), 0); // 傳送資料 crecv = recv(sock, indata, sizeof(indata), 0); // 接收資料 if (crecv == -1) { perror(\u0026#34;recv error\u0026#34;); close(crecv); exit(1); } else if (crecv == 0) { printf(\u0026#34;close\\n\u0026#34;); close(crecv); exit(1); } printf(\u0026#34;recv: %s\\n\u0026#34;, indata); } std::cout \u0026lt;\u0026lt; \u0026#34;結束資料輸入\u0026#34; \u0026lt;\u0026lt; std::endl; break; case 2: cin_while = false; printf(\u0026#34;exit\\n\u0026#34;); break; default: printf(\u0026#34;輸入錯誤(請輸入半形的1-2)\\n\u0026#34;); break; } } catch (const std::invalid_argument \u0026amp;e) { printf(\u0026#34;輸入錯誤(請輸入半形的1-2)\\n\u0026#34;); } } close(sock); return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/notes/13/","summary":"這篇是C++的筆記第13篇","title":"C++語言的筆記-TCP/IP socket 03"},{"content":"TCP/IP socket 02 這篇是C++的筆記第12篇\n學習TCP/IP socket的筆記。 學習傳送資料到伺服器。\n伺服器端 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { struct sockaddr_in sinadd, cinadd; socklen_t addlen; char indata[1024] = {0}, outdata[1024] = {0}; int sock, csock, crecv; int port = 8000; int on = 1; sock = socket(AF_INET, SOCK_STREAM, 0); // 設定通訊協定 if (sock == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } else { printf(\u0026#34;socket OK\\n\u0026#34;); } if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof(int)) == -1) // 設定為TCP，對bind設定釋放的通訊端立即可以使用 { perror(\u0026#34;setsockopt error\u0026#34;); exit(1); } else { printf(\u0026#34;setsockopt OK\\n\u0026#34;); } sinadd.sin_family = AF_INET; // 設定使用IP sinadd.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 設定IP，轉換成符合sin_addr的u_long sinadd.sin_port = htons(port); // 設定port號，轉換成網路序 // sin.sin_addr.s_addr = INADDR_ANY;//如果不指定ip，可以這樣用 if (bind(sock, (struct sockaddr *)\u0026amp;sinadd, sizeof(sinadd)) == -1) // 綁定ip和port，如果使用using namespace std;，這裡要加::不然會發生錯誤，因為會讓編譯器以為要使用std::bind造成錯誤。 { perror(\u0026#34;bind error\u0026#34;); exit(1); } else { printf(\u0026#34;bind OK\\n\u0026#34;); } printf(\u0026#34;server start at: %s:%d\\n\u0026#34;, inet_ntoa(sinadd.sin_addr), port); if (listen(sock, 5) == -1) // 監聽接口，接口數量最多5個 { perror(\u0026#34;listen error\u0026#34;); exit(1); } else { printf(\u0026#34;listen OK\\n\u0026#34;); } printf(\u0026#34;wait...\\n\u0026#34;); addlen = sizeof(cinadd); while (true) { csock = accept(sock, (struct sockaddr *)\u0026amp;cinadd, \u0026amp;addlen); // 等待請求 printf(\u0026#34;accept: %s:%d\\n\u0026#34;, inet_ntoa(cinadd.sin_addr), ntohs(cinadd.sin_port)); // 顯示請求的ip和port，ip轉換成十進位，port轉換成電腦序。 while (true) { memset(indata, \u0026#39;\\0\u0026#39;, 1024); // 清空資料 memset(outdata, \u0026#39;\\0\u0026#39;, 1024); // 清空資料 crecv = recv(csock, indata, sizeof(indata), 0); // 接收資料 if (crecv == -1) { perror(\u0026#34;recv error\u0026#34;); close(crecv); break; } else if (crecv == 0) { printf(\u0026#34;close\\n\u0026#34;); close(crecv); break; } printf(\u0026#34;recv:%s\\n\u0026#34;, indata); strcpy(outdata, indata); // 複製字串 send(csock, outdata, strlen(outdata), 0); // 傳送資料 } } close(sock); return 0; } 用戶端 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;typeinfo\u0026gt; int main() { struct sockaddr_in sin; char indata[1024] = {0}, outdata[1024] = {0}; std::string inputfgets; int sock, crecv; // 設定通訊協定 int port = 8000; bool cin_while = true; sock = socket(AF_INET, SOCK_STREAM, 0); // 設定通訊協定 if (sock == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } else { printf(\u0026#34;socket OK\\n\u0026#34;); } sin.sin_family = AF_INET; // 設定使用IP sin.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 設定IP，轉換成符合sin_addr的u_long // sin.sin_addr.s_addr = INADDR_ANY;//如果不指定ip，可以這樣用 sin.sin_port = htons(port); // 設定port號，轉換成網路序 if (connect(sock, (struct sockaddr *)\u0026amp;sin, sizeof(sin)) == -1) // 綁定ip和port。 { perror(\u0026#34;connect error\u0026#34;); exit(1); } else { printf(\u0026#34;connect OK\\n\u0026#34;); } while (cin_while) { printf(\u0026#34;輸入1傳送資料\\n\u0026#34;); printf(\u0026#34;輸入2離開\\n\u0026#34;); printf(\u0026#34;P:\u0026#34;); std::cin \u0026gt;\u0026gt; inputfgets; try { switch (std::stoi(inputfgets)) { case 1: while (true) { memset(indata, \u0026#39;\\0\u0026#39;, 1024); // 等待請求 memset(outdata, \u0026#39;\\0\u0026#39;, 1024); // 等待請求 printf(\u0026#34;輸入exit結束資料輸入\\n\u0026#34;); printf(\u0026#34;p:\u0026#34;); std::cin \u0026gt;\u0026gt; outdata; // 輸入資料 if (strcmp(outdata, \u0026#34;exit\u0026#34;) == 0) { close(crecv); break; } send(sock, outdata, strlen(outdata), 0); // 傳送資料 crecv = recv(sock, indata, sizeof(indata), 0); // 接收資料 if (crecv == -1) { perror(\u0026#34;recv error\u0026#34;); close(crecv); break; } else if (crecv == 0) { printf(\u0026#34;close\\n\u0026#34;); close(crecv); break; } printf(\u0026#34;recv: %s\\n\u0026#34;, indata); } std::cout \u0026lt;\u0026lt; \u0026#34;結束資料輸入\u0026#34; \u0026lt;\u0026lt; std::endl; break; case 2: cin_while = false; printf(\u0026#34;exit\\n\u0026#34;); break; default: printf(\u0026#34;輸入錯誤(請輸入半形的1-2)\\n\u0026#34;); break; } } catch (const std::invalid_argument \u0026amp;e) { printf(\u0026#34;輸入錯誤(請輸入半形的1-2)\\n\u0026#34;); } } close(sock); return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/notes/12/","summary":"這篇是C++的筆記第12篇","title":"C++語言的筆記-TCP/IP socket 02"},{"content":"TCP/IP socket 01 這篇是C++的筆記第11篇 學習TCP/IP socket的筆記。\n伺服器端 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { struct sockaddr_in sinadd, cinadd; socklen_t addlen; char outdata[1024] = \u0026#34;hello world\u0026#34;; int sock, csock; int port = 8000; int on = 1; sock = socket(AF_INET, SOCK_STREAM, 0); // 設定通訊協定 if (sock == -1) { perror(\u0026#34;socket error\u0026#34;); exit(1); } if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, \u0026amp;on, sizeof(int)) == -1) // 設定為TCP，對bind設定釋放的通訊端立即可以使用 { perror(\u0026#34;setsockopt error\u0026#34;); exit(1); } sinadd.sin_family = AF_INET; // 設定使用IP sinadd.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 設定IP，轉換成符合sin_addr的u_long sinadd.sin_port = htons(port); // 設定port號，轉換成網路序 // sin.sin_addr.s_addr = INADDR_ANY;//如果不指定ip，可以這樣用 if (bind(sock, (struct sockaddr *)\u0026amp;sinadd, sizeof(sinadd)) == -1) // 綁定ip和port，如果使用using namespace std;，這裡要加::不然會發生錯誤，因為會讓編譯器以為要使用std::bind造成錯誤。 { perror(\u0026#34;bind error\u0026#34;); exit(1); } printf(\u0026#34;server start at: %s:%d\\n\u0026#34;, inet_ntoa(sinadd.sin_addr), port); if (listen(sock, 5) == -1) // 監聽接口，接口數量最多5個 { perror(\u0026#34;listen error\u0026#34;); exit(1); } addlen = sizeof(cinadd); while (true) { csock = accept(sock, (struct sockaddr *)\u0026amp;cinadd, \u0026amp;addlen); // 等待請求 while (true) { send(csock, outdata, strlen(outdata), 0); // 傳送資料 break; } } close(sock); return 0; } 用戶端 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { struct sockaddr_in sin; char indata[1024] = {0}; int sock; // 設定通訊協定 int port = 8000; sock = socket(AF_INET, SOCK_STREAM, 0); // 設定通訊協定 if (sock == -1) { perror(\u0026#34;sock error\u0026#34;); exit(1); } sin.sin_family = AF_INET; // 設定使用IP sin.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 設定IP，轉換成符合sin_addr的u_long // sin.sin_addr.s_addr = INADDR_ANY;//如果不指定ip，可以這樣用 sin.sin_port = htons(port); // 設定port號，轉換成網路序 if (connect(sock, (struct sockaddr *)\u0026amp;sin, sizeof(sin)) == -1) // 綁定ip和port。 { perror(\u0026#34;connect error\u0026#34;); exit(1); } while (true) { if (recv(sock, indata, sizeof(indata), 0) == -1) // 接收資料 { perror(\u0026#34;recv error\u0026#34;); break; } printf(\u0026#34;recv: %s\\n\u0026#34;, indata); break; } close(sock); return 0; } ","permalink":"https://tom8760925.github.io/tomku/c++/notes/11/","summary":"這篇是C++的筆記第11篇","title":"C++語言的筆記-TCP/IP socket 01"},{"content":"繼承模板 這篇是C++的筆記第10篇\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class a { public: int t = 10; void tt() { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; template \u0026lt;typename T\u0026gt; class b : public T { public: void bb() { T::tt(); } }; int main() { b\u0026lt;a\u0026gt; aa; aa.tt(); aa.bb(); cout \u0026lt;\u0026lt; endl; return 0; } 結果\np:10 p:10 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/10/","summary":"這篇是C++的筆記第10篇","title":"C++語言的筆記-繼承模板"},{"content":"可變參數 這篇是C++的筆記第09篇\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; template \u0026lt;typename T, typename... TT\u0026gt; void a(T n, TT... nn); int main() { int i = 1; a(i, 2, 3, 4); cout \u0026lt;\u0026lt; endl; return 0; } template \u0026lt;typename T, typename... TT\u0026gt; void a(T n, TT... nn) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; vector\u0026lt;T\u0026gt; v = {nn...}; for (auto i : v) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } 結果\np:1 p:2 p:3 p:4 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/09/","summary":"這篇是C++的筆記第09篇","title":"C++語言的筆記-可變參數"},{"content":"多載 這篇是C++的筆記第08篇\n函數 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void a(int n); void a(string n); void a(bool n); int main() { int i = 1; string s = \u0026#34;A\u0026#34;; bool b = true; a(i); cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; a(s); cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; a(b); cout \u0026lt;\u0026lt; endl; return 0; } void a(int n) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void a(string n) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void a(bool n) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 結果\np:1 ------ p:A ------ p:1 模板 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; void a(T n); template \u0026lt;typename T\u0026gt; void a(T n, T b); template \u0026lt;typename T, typename TT\u0026gt; void a(T n, TT b); int main() { int i = 1; int ii = 2; string s = \u0026#34;A\u0026#34;; a(i); cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; a(i, ii); cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; a(i, s); cout \u0026lt;\u0026lt; endl; return 0; } template \u0026lt;typename T\u0026gt; void a(T n) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template \u0026lt;typename T\u0026gt; void a(T n, T b) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;|\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } template \u0026lt;typename T, typename TT\u0026gt; void a(T n, TT b) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;|\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 結果\np:1 ------ p:1|2 ------ p:1|A ","permalink":"https://tom8760925.github.io/tomku/c++/notes/08/","summary":"這篇是C++的筆記第08篇","title":"C++語言的筆記-多載"},{"content":"reference 這篇是C++的筆記第07篇\nreference是參考來源，可以使用來源或改變來源。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct t { int a; string b; }; void aa(const t \u0026amp;tt); void bb(t \u0026amp;tt); int main() { t a = {1, \u0026#34;A\u0026#34;}; int b = 2; int \u0026amp;c = b; aa(a); cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; bb(a); cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; c = 3; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;endl; return 0; } void aa(const t \u0026amp;tt) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; tt.a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; tt.b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void bb(t \u0026amp;tt) { tt.a = 2; tt.b = \u0026#34;B\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; tt.a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; tt.b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 結果\np:1 p:A ------ p:2 p:B ------ p:2 p:B ------ p:3 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/07/","summary":"這篇是C++的筆記第07篇","title":"C++語言的筆記-reference"},{"content":"url 這篇是golang的筆記第09篇\n使用api\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; ) func main() { getmain() } func getmain() { url := \u0026#34;http://localhost:4567/test\u0026#34; req, _ := http.Get(url) defer req.Body.Close() //defer 延後執行在結束時執行 s, _ := io.ReadAll(req.Body) fmt.Println(string(s)) } func postmain() { v := url.Values{\u0026#34;v\u0026#34;: {\u0026#34;d\u0026#34;}, \u0026#34;i\u0026#34;: {\u0026#34;4\u0026#34;}, \u0026#34;ii\u0026#34;: {\u0026#34;4\u0026#34;}} url := \u0026#34;http://localhost:4567/test\u0026#34; req, _ := http.PostForm(url, v) defer req.Body.Close() s, _ := io.ReadAll(req.Body) fmt.Println(string(s)) } ","permalink":"https://tom8760925.github.io/tomku/golang/notes/09/","summary":"這篇是golang的筆記第09篇","title":"golang語言的筆記-url"},{"content":"練習實作api 這篇是golang的練習實作第01篇\n練習製作api連接資料庫\npackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strconv\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; \u0026#34;github.com/labstack/echo/v4\u0026#34; ) type T struct { //資料表欄位 ID int V string I int II int } var sqlname string = \u0026#34;mysql\u0026#34; var conn string = \u0026#34;root:password@tcp(localhost:3306)/test?charset=utf8\u0026#34; var tables string = \u0026#34;tests\u0026#34; var field []string = []string{\u0026#34;v\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;ii\u0026#34;} func main() { //http://localhost:4567/test e := echo.New() e.GET(\u0026#34;/test\u0026#34;, getdata) e.POST(\u0026#34;/test\u0026#34;, postdata) e.PUT(\u0026#34;/test/:id\u0026#34;, putdata) e.DELETE(\u0026#34;/test/:id\u0026#34;, deletedata) e.Logger.Fatal(e.Start(\u0026#34;:4567\u0026#34;)) } func getdata(c echo.Context) error { var dt []T //連結資料庫 db, err := sql.Open(sqlname, conn) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //sql語法 rows, err := db.Query(\u0026#34;SELECT * FROM \u0026#34; + tables) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } for rows.Next() { var t T //讀資料 err := rows.Scan(\u0026amp;t.ID, \u0026amp;t.V, \u0026amp;t.I, \u0026amp;t.II) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } dt = append(dt, t) } rows.Close() db.Close() //轉json j, err := json.Marshal(dt) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //return c.JSON(http.StatusOK, j)//base64 return c.JSONBlob(http.StatusOK, j) } func postdata(c echo.Context) error { post_id := 0 post_v := c.FormValue(field[0]) //string to int post_i, err := strconv.Atoi(c.FormValue(field[1])) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //string to int post_ii, err := strconv.Atoi(c.FormValue(field[2])) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } t := T{ID: post_id, V: post_v, I: post_i, II: post_ii} //連結資料庫 db, err := sql.Open(sqlname, conn) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //sql語法 pre, err := db.Prepare(\u0026#34;INSERT \u0026#34; + tables + \u0026#34; SET v=?,i=?,ii=?\u0026#34;) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //寫入的資料 inst, err := pre.Exec(t.V, t.I, t.II) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //執行 id, err := inst.LastInsertId() if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } pre.Close() db.Close() return c.String(http.StatusOK, fmt.Sprint(id)) } func putdata(c echo.Context) error { //string to int put_id, err := strconv.Atoi(c.Param(\u0026#34;id\u0026#34;)) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } put_v := c.FormValue(field[0]) //string to int put_i, err := strconv.Atoi(c.FormValue(field[1])) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //string to int put_ii, err := strconv.Atoi(c.FormValue(field[2])) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } t := T{ID: put_id, V: put_v, I: put_i, II: put_ii} //連結資料庫 db, err := sql.Open(sqlname, conn) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //sql語法 pre, err := db.Prepare(\u0026#34;UPDATE \u0026#34; + tables + \u0026#34; SET v=?,i=?,ii=? where id=?\u0026#34;) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //寫入的資料 inst, err := pre.Exec(t.V, t.I, t.II, t.ID) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //執行 id, err := inst.RowsAffected() if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } pre.Close() db.Close() return c.String(http.StatusOK, fmt.Sprint(id)) } func deletedata(c echo.Context) error { delete_id := c.Param(\u0026#34;id\u0026#34;) //連結資料庫 db, err := sql.Open(sqlname, conn) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //sql語法 pre, err := db.Prepare(\u0026#34;delete from \u0026#34; + tables + \u0026#34; where id=?\u0026#34;) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //寫入的資料 inst, err := pre.Exec(delete_id) if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } //執行 id, err := inst.RowsAffected() if err != nil { return c.String(http.StatusOK, fmt.Sprint(err)) } pre.Close() db.Close() return c.String(http.StatusOK, fmt.Sprint(id)) } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/golang/practice/01/","summary":"這篇是golang的練習實作第01篇","title":"golang語言的練習-練習實作api01"},{"content":"mysql 這篇是golang的筆記第08篇\n讀取 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) type t struct { id int v string i int ii int } func main() { selectdata() } func selectdata() { var dt []t db, _ := sql.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:password@tcp(localhost:3306)/test?charset=utf8\u0026#34;) rows, _ := db.Query(\u0026#34;SELECT * FROM tests\u0026#34;) for rows.Next() { var t t _ = rows.Scan(\u0026amp;t.id, \u0026amp;t.v, \u0026amp;t.i, \u0026amp;t.ii) dt = append(dt, t) } fmt.Println(\u0026#34;p:\u0026#34; + fmt.Sprint(dt[0].id)) rows.Close() db.Close() } func insertdata() { db, _ := sql.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:password@tcp(localhost:3306)/test?charset=utf8\u0026#34;) pre, _ := db.Prepare(\u0026#34;INSERT tests SET v=?,i=?,ii=?\u0026#34;) inst, _ := pre.Exec(\u0026#34;c\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;3\u0026#34;) id, _ := inst.LastInsertId() fmt.Println(\u0026#34;p:\u0026#34; + fmt.Sprint(id)) } func insertdata1() { db, _ := sql.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:password@tcp(localhost:3306)/test?charset=utf8\u0026#34;) inst, _ := db.Exec(\u0026#34;INSERT INTO tests (v, i, ii) VALUES (?, ?, ?)\u0026#34;, \u0026#34;d\u0026#34;, 4, 4) id, _ := inst.LastInsertId() fmt.Println(\u0026#34;p:\u0026#34; + fmt.Sprint(id)) } func deletedata() { db, _ := sql.Open(\u0026#34;mysql\u0026#34;, \u0026#34;root:password@tcp(localhost:3306)/test?charset=utf8\u0026#34;) pre, _ := db.Prepare(\u0026#34;delete from tests where id=?\u0026#34;) inst, _ := pre.Exec(5) id, _ := inst.RowsAffected() fmt.Println(\u0026#34;p:\u0026#34; + fmt.Sprint(id)) } 結果\np:1 ","permalink":"https://tom8760925.github.io/tomku/golang/notes/08/","summary":"這篇是golang的筆記第08篇","title":"golang語言的筆記-mysql"},{"content":"api03 這篇是golang的筆記第07篇\nput、patch、delete package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/labstack/echo/v4\u0026#34; ) func main() { put_main() } func put_main() { //http://localhost:4567 e := echo.New() e.PUT(\u0026#34;/test/:id\u0026#34;, postdata) //覆蓋 e.PATCH(\u0026#34;/test/:id\u0026#34;, patchdata) //修改 e.DELETE(\u0026#34;/test/:id\u0026#34;, deletedata) //刪除 e.Logger.Fatal(e.Start(\u0026#34;:4567\u0026#34;)) } func postdata(c echo.Context) error { return c.String(http.StatusOK, \u0026#34;p:\u0026#34;+c.Param(\u0026#34;id\u0026#34;)+\u0026#34;(p)\u0026#34;) } func patchdata(c echo.Context) error { return c.String(http.StatusOK, \u0026#34;p:\u0026#34;+c.Param(\u0026#34;id\u0026#34;)+\u0026#34;(p)\u0026#34;) } func deletedata(c echo.Context) error { return c.String(http.StatusOK, \u0026#34;p:\u0026#34;+c.Param(\u0026#34;id\u0026#34;)+\u0026#34;(d)\u0026#34;) } ","permalink":"https://tom8760925.github.io/tomku/golang/notes/07/","summary":"這篇是golang的筆記第07篇","title":"golang語言的筆記-api03"},{"content":"api02 這篇是golang的筆記第06篇\npost package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/labstack/echo/v4\u0026#34; ) func main() { post_main() } func post_main() { //http://localhost:4567 e := echo.New() e.POST(\u0026#34;/\u0026#34;, postdata) e.Logger.Fatal(e.Start(\u0026#34;:4567\u0026#34;)) } func postdata(c echo.Context) error { a := c.FormValue(\u0026#34;a\u0026#34;) return c.String(http.StatusOK, \u0026#34;p:\u0026#34;+a) } ","permalink":"https://tom8760925.github.io/tomku/golang/notes/06/","summary":"這篇是golang的筆記第06篇","title":"golang語言的筆記-api02"},{"content":"api01 這篇是golang的筆記第05篇\n使用echo，製作api的筆記第01篇 在終端輸入\ngo get github.com/labstack/echo/v4 api測試插件\nhttps://marketplace.visualstudio.com/items?itemName=Postman.postman-for-vscode get package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/labstack/echo/v4\u0026#34; \u0026#34;encoding/json\u0026#34; ) func main() { get_main() } // ----- func get_main() { //http://localhost:4567 e := echo.New() e.GET(\u0026#34;/\u0026#34;, getdata) e.Logger.Fatal(e.Start(\u0026#34;:4567\u0026#34;)) } func getdata(c echo.Context) error { return c.String(http.StatusOK, \u0026#34;test\u0026#34;) //test } // ----- func get_main1() { //http://localhost:4567/test e := echo.New() e.GET(\u0026#34;/test\u0026#34;, getdata1) e.Logger.Fatal(e.Start(\u0026#34;:4567\u0026#34;)) } func getdata1(c echo.Context) error { return c.String(http.StatusOK, \u0026#34;test\u0026#34;) //test } // ----- func get_main2() { //http://localhost:4567/test/a/b e := echo.New() e.GET(\u0026#34;/test/:a/:b\u0026#34;, getdata2) e.Logger.Fatal(e.Start(\u0026#34;:4567\u0026#34;)) } func getdata2(c echo.Context) error { a := c.Param(\u0026#34;a\u0026#34;) b := c.Param(\u0026#34;b\u0026#34;) return c.String(http.StatusOK, a+\u0026#34;|\u0026#34;+b) //a|b } // ----- func get_main3() { //http://localhost:4567/test/a?ty=ty e := echo.New() e.GET(\u0026#34;/test/:a\u0026#34;, getdata3) e.Logger.Fatal(e.Start(\u0026#34;:4567\u0026#34;)) } func getdata3(c echo.Context) error { a := c.Param(\u0026#34;a\u0026#34;) ty := c.QueryParam(\u0026#34;ty\u0026#34;) return c.String(http.StatusOK, a+\u0026#34;|\u0026#34;+ty) //a|ty } // ----- type datajson struct { A int B string C datajson2 D []string E map[string]int } type datajson2 struct { A int B string } func get_main4() { //http://localhost:4567 e := echo.New() e.GET(\u0026#34;/\u0026#34;, getdata4) e.Logger.Fatal(e.Start(\u0026#34;:4567\u0026#34;)) } func getdata4(c echo.Context) error { d := datajson{ A: 1, B: \u0026#34;a\u0026#34;, C: datajson2{ A: 2, B: \u0026#34;b\u0026#34;, }, D: []string{\u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;}, E: map[string]int{ \u0026#34;E\u0026#34;: 3, \u0026#34;F\u0026#34;: 4, }, } j, _ := json.Marshal(d) return c.JSON(http.StatusOK, j) //\u0026#34;eyJBIjoxLCJCIjoiYSIsIkMiOnsiQSI6MiwiQiI6ImIifSwiRCI6WyJjIiwiZCJdLCJFIjp7IkUiOjMsIkYiOjR9fQ==\u0026#34; //base64:{\u0026#34;A\u0026#34;:1,\u0026#34;B\u0026#34;:\u0026#34;a\u0026#34;,\u0026#34;C\u0026#34;:{\u0026#34;A\u0026#34;:2,\u0026#34;B\u0026#34;:\u0026#34;b\u0026#34;},\u0026#34;D\u0026#34;:[\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;],\u0026#34;E\u0026#34;:{\u0026#34;E\u0026#34;:3,\u0026#34;F\u0026#34;:4}} } ","permalink":"https://tom8760925.github.io/tomku/golang/notes/05/","summary":"這篇是golang的筆記第05篇","title":"golang語言的筆記-api01"},{"content":"指令 這篇是mysql的筆記第02篇\n記錄mysql指令\n資料庫 CREATE DATABASE `test` ;//新增資料庫 DROP DATABASE `test`; //刪除資料庫 SHOW DATABASES;//顯示資料庫 use test;//指定使用的資料庫 資料表 CREATE TABLE tests (新增資料表 id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, //新增主鍵、自動填值、不能重複、不能為null v VARCHAR(50) NOT NULL,//不能為null i int NOT NULL CHECK (i\u0026gt;0)//不能為null、值要大於0 ); ALTER TABLE tests ADD ii int not null;//修改新增欄位 INSERT INTO tests VALUES (1,\u0026#34;A\u0026#34;,1,1);//新增資料 INSERT INTO tests (v,i,ii) VALUES (\u0026#34;A\u0026#34;,1,1);//新增資料夾指定欄位，而且id欄位有加AUTO_INCREMENT，所以可以省略 UPDATE tests SET ii=3 WHERE id=4;//更新資料 DELETE FROM tests WHERE ID=2;//刪除資料 DROP TABLE `test`.`tests`;//刪除資料表 ALTER TABLE tests DRop vv;//刪除欄位 SELECT * FROM tests;顯示資料表資料 ","permalink":"https://tom8760925.github.io/tomku/mysql/notes/02/","summary":"這篇是mysql的筆記第02篇","title":"mysql的筆記-指令"},{"content":"安裝 這篇是mysql的筆記第01篇\n記錄mysql的安裝(使用mac安裝) 到官網下載\nhttps://www.mysql.com/downloads/ 點選\nMySQL Community (GPL) Downloads -\u0026gt; MySQL Community Server 和\nMySQL Community (GPL) Downloads -\u0026gt; MySQL Workbench ","permalink":"https://tom8760925.github.io/tomku/mysql/notes/01/","summary":"這篇是mysql的筆記第01篇","title":"mysql的筆記-安裝"},{"content":"aps.net core mvc的架構 這篇是C#的筆記第01篇\n記錄aps.net core mvc的檔案或資料夾\n名稱 功能 Program.cs 起始 appsettings.json 預設設定欓 appsettings.Development.json 開發設定欓 wwwroot 資源資料夾 Views 視圖資料夾 Models 模型資料夾 Controllers 控制器資料夾 launchSettings.json 啟動設定欓 ","permalink":"https://tom8760925.github.io/tomku/csharp/notes/01/","summary":"這篇是C#的筆記第01篇","title":"C#語言的筆記-aps.net core mvc的檔案或資料夾"},{"content":"符號 這篇是golang的筆記第04篇\n記錄 \u0026hellip; 和 _ 的用法\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a, b, _ := notes04_1() //忽略回傳值 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;------\u0026#34;) var c = [...]int{1, 2} //忽略大小 fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;------\u0026#34;) notes04_2(1, 2) notes04_2(1, 2, 3, 4) } func notes04_1() (int, string, bool) { return 1, \u0026#34;A\u0026#34;, false } func notes04_2(n ...int) { //可變的input fmt.Println(\u0026#34;p:\u0026#34;, n) } 結果\np: 1 p: A ------ p: [1 2] ------ p: [1 2] p: [1 2 3 4] ","permalink":"https://tom8760925.github.io/tomku/golang/notes/04/","summary":"這篇是golang的筆記第04篇","title":"golang語言的筆記-符號"},{"content":"errors 這篇是golang的練習筆記第10篇\ngolang沒有try，但能使用errors實現。\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { no10_1() } func no10_1() { err := errors.New(\u0026#34;p:err\u0026#34;) if err != nil { fmt.Println(err) } } 結果\np:err 函數的應用\nfunc no10_2() { if n, err := no10_2r(0); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;p:\u0026#34;, n) } if n, err := no10_2r(1); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;p:\u0026#34;, n) } } func no10_2r(n int) (int, error) { if n == 0 { return n, fmt.Errorf(\u0026#34;p:err\u0026#34;) } return n, nil } 結果\np:err p: 1 結構的應用\ntype a struct { n int i int } func no10_3() { if n, err := no10_3r(1, 2); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;p:\u0026#34;, n) } if n, err := no10_3r(1, 0); err != nil { fmt.Println(err) } else { fmt.Println(\u0026#34;p:\u0026#34;, n) } } func no10_3r(n, i int) (int, error) { if n \u0026lt;= 0 || i \u0026lt;= 0 { return 0, \u0026amp;a{n: n, i: i} } return n + i, nil } func (e *a) Error() string { if e.n \u0026lt;= 0 { return \u0026#34;err(n=\u0026#34; + fmt.Sprint(e.n) + \u0026#34;)\u0026#34; } else if e.i \u0026lt;= 0 { return \u0026#34;err(i=\u0026#34; + fmt.Sprint(e.i) + \u0026#34;)\u0026#34; } else { return \u0026#34;p:err\u0026#34; } } 結果\np: 3 err(i=0) ","permalink":"https://tom8760925.github.io/tomku/golang/no/10/","summary":"這篇是golang的練習筆記第10篇","title":"golang語言的練習-errors"},{"content":"interfaces 這篇是golang的筆記第03篇\npackage main import \u0026#34;fmt\u0026#34; type a interface { is() } type b interface { isi(int) } type c interface { isir(int) string } type d interface { is2() } type e interface { is() isi(int) isir(int) string is2() } type nint struct { n int } type nstring struct { n string } func (n nint) is() { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(int)\u0026#34;) } func (n nstring) is() { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(string)\u0026#34;) } func (n nint) isi(i int) { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(int)\u0026#34;, i) } func (n nstring) isi(i int) { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(string)\u0026#34;, i) } func (n nint) isir(i int) string { return \u0026#34;P:\u0026#34; + fmt.Sprint(n.n) + \u0026#34;(int)\u0026#34; + fmt.Sprint(i) } func (n nstring) isir(i int) string { return \u0026#34;P:\u0026#34; + n.n + \u0026#34;(string)\u0026#34; + fmt.Sprint(i) } func (n *nint) is2() { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(int)\u0026#34;) } func (n *nstring) is2() { fmt.Println(\u0026#34;P:\u0026#34;, n.n, \u0026#34;(string)\u0026#34;) } func is(n e) { n.is() n.is2() } func is2(n e, i int) string { return n.isir(i) } func main() { var aa a var bb b var cc c var dd d aa = nint{n: 1} aa.is() fmt.Println(\u0026#34;------\u0026#34;) aa = nstring{n: \u0026#34;A\u0026#34;} aa.is() fmt.Println(\u0026#34;======\u0026#34;) bb = nint{n: 2} bb.isi(1) fmt.Println(\u0026#34;------\u0026#34;) bb = nstring{n: \u0026#34;B\u0026#34;} bb.isi(1) fmt.Println(\u0026#34;======\u0026#34;) cc = nint{n: 3} fmt.Println(cc.isir(1)) fmt.Println(\u0026#34;------\u0026#34;) cc = nstring{n: \u0026#34;C\u0026#34;} fmt.Println(cc.isir(1)) fmt.Println(\u0026#34;=====\u0026#34;) dd = \u0026amp;nint{n: 4} dd.is2() fmt.Println(\u0026#34;------\u0026#34;) dd = \u0026amp;nstring{n: \u0026#34;D\u0026#34;} dd.is2() fmt.Println(\u0026#34;======\u0026#34;) ee := nint{n: 5} ee.is() fmt.Println(\u0026#34;------\u0026#34;) ee2 := nstring{n: \u0026#34;E\u0026#34;} ee2.is() fmt.Println(\u0026#34;=====\u0026#34;) ff := nint{n: 6} is(\u0026amp;ff) fmt.Println(\u0026#34;------\u0026#34;) ff2 := nstring{n: \u0026#34;F\u0026#34;} is(\u0026amp;ff2) fmt.Println(\u0026#34;=====\u0026#34;) gg := nint{n: 7} fmt.Println(is2(\u0026amp;gg, 1)) fmt.Println(\u0026#34;------\u0026#34;) gg2 := nstring{n: \u0026#34;G\u0026#34;} fmt.Println(is2(\u0026amp;gg2, 1)) } 結果\nP: 1 (int) ------ P: A (string) ====== P: 2 (int) 1 ------ P: B (string) 1 ====== P:3(int)1 ------ P:C(string)1 ===== P: 4 (int) ------ P: D (string) ====== P: 5 (int) ------ P: E (string) ===== P: 6 (int) P: 6 (int) ------ P: F (string) P: F (string) ===== P:7(int)1 ------ P:G(string)1 ","permalink":"https://tom8760925.github.io/tomku/golang/notes/03/","summary":"這篇是golang的筆記第03篇","title":"golang語言的筆記-interfaces"},{"content":"type 這篇是golang的筆記第02篇\npackage main import \u0026#34;fmt\u0026#34; func main() { type a int var b a = 1 fmt.Println(\u0026#34;p:\u0026#34;, b) } 結果\np: 1 ","permalink":"https://tom8760925.github.io/tomku/golang/notes/02/","summary":"這篇是golang的筆記第02篇","title":"golang語言的筆記-type"},{"content":"結構 這篇是golang的練習筆記第09篇\npackage main import \u0026#34;fmt\u0026#34; func main() { no09_1() } type no09 struct { i int n string } type no092 struct { a struct { b int c string } d bool } type no093 struct { no no09 d bool } type no094 struct { no09 //隱藏 d bool } func no09_1() { a := no09{i: 1, n: \u0026#34;A\u0026#34;} var b no09 = no09{2, \u0026#34;B\u0026#34;} fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, a.i) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;p:\u0026#34;, b.i) fmt.Println(\u0026#34;-----\u0026#34;) c := no09_1r(a) fmt.Println(\u0026#34;p:\u0026#34;, c.i) fmt.Println(\u0026#34;p:\u0026#34;, c.n) fmt.Println(\u0026#34;-----\u0026#34;) d := no092{} d.a.b = 3 d.a.c = \u0026#34;C\u0026#34; d.d = true fmt.Println(\u0026#34;p:\u0026#34;, d.a) fmt.Println(\u0026#34;p:\u0026#34;, d.a.b) fmt.Println(\u0026#34;p:\u0026#34;, d.a.c) fmt.Println(\u0026#34;p:\u0026#34;, d.d) fmt.Println(\u0026#34;-----\u0026#34;) e := no093{no09{4, \u0026#34;D\u0026#34;}, false} fmt.Println(\u0026#34;p:\u0026#34;, e.no) fmt.Println(\u0026#34;p:\u0026#34;, e.no.i) fmt.Println(\u0026#34;p:\u0026#34;, e.no.n) fmt.Println(\u0026#34;p:\u0026#34;, e.d) fmt.Println(\u0026#34;-----\u0026#34;) f := no094{no09{4, \u0026#34;D\u0026#34;}, false} fmt.Println(\u0026#34;p:\u0026#34;, f) fmt.Println(\u0026#34;p:\u0026#34;, f.i) fmt.Println(\u0026#34;p:\u0026#34;, f.n) fmt.Println(\u0026#34;p:\u0026#34;, f.d) } func no09_1r(no no09) no09 { no.i += 2 no.n = \u0026#34;c\u0026#34; return no } 結果\np: {1 A} p: 1 ----- p: {2 B} p: 2 ----- p: 3 p: c ----- p: {3 C} p: 3 p: C p: true ----- p: {4 D} p: 4 p: D p: false ----- p: {{4 D} false} p: 4 p: D p: false ","permalink":"https://tom8760925.github.io/tomku/golang/no/09/","summary":"這篇是golang的練習筆記第09篇","title":"golang語言的練習-結構"},{"content":"map 這篇是golang的筆記第01篇\ngolang有像python的字典的常數\npackage main import \u0026#34;fmt\u0026#34; func main() { a := map[string]int{ \u0026#34;A\u0026#34;: 1, \u0026#34;B\u0026#34;: 2, \u0026#34;C\u0026#34;: 3, } b := make(map[string]int) c := a fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, a[\u0026#34;A\u0026#34;]) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) b[\u0026#34;A\u0026#34;] = 1 //新增 fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, len(a)) fmt.Println(\u0026#34;-----\u0026#34;) delete(a, \u0026#34;C\u0026#34;) //刪除 fmt.Println(\u0026#34;p:\u0026#34;, a) } 結果\np: map[A:1 B:2 C:3] p: 1 ----- p: map[] p: map[A:1] ----- p: map[A:1 B:2 C:3] ----- p: 3 ----- p: map[A:1 B:2] ","permalink":"https://tom8760925.github.io/tomku/golang/notes/01/","summary":"這篇是golang的筆記第01篇","title":"golang語言的筆記-map"},{"content":"指標 這篇是golang的練習筆記第08篇\npackage main import \u0026#34;fmt\u0026#34; func main() { no08_1() } func no08_1() { var a int = 1 var b *int var c **int var d [1]*int b = \u0026amp;a c = \u0026amp;b d[0] = \u0026amp;a fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;p:\u0026#34;, *b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, *c) fmt.Println(\u0026#34;p:\u0026#34;, **c) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, d[0]) fmt.Println(\u0026#34;p:\u0026#34;, *d[0]) } 結果\np: 0x14000110018 p: 1 ----- p: 0x14000110018 p: 1 ----- p: 0x14000110018 p: 1 ","permalink":"https://tom8760925.github.io/tomku/golang/no/08/","summary":"這篇是golang的練習筆記第08篇","title":"golang語言的練習-指標"},{"content":"陣列 這篇是golang的練習筆記第07篇\ngolang有陣列和slice，差別在陣列長度不可改變，slice可以改變\n宣告 一元 package main import \u0026#34;fmt\u0026#34; func main() { no07_1() } func no07_1() { var a [3]int = [3]int{1, 2, 3} var b []int = []int{1, 2, 3, 4, 5, 6} var c []int = make([]int, 5) //宣告5個長度 var d []int = make([]int, 5, 10) //宣告5個長度，預留10個長度 var e []int f := [3]int{1, 2, 3} var g []int = a[0:3] fmt.Println(\u0026#34;p:\u0026#34;, a[0]) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, d) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, e) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, f) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, g) } 結果\np: 1 ----- p: [1 2 3 4 5 6] ----- p: [0 0 0 0 0] ----- p: [0 0 0 0 0] ----- p: [] ----- p: [1 2 3] ----- p: [1 2 3] 二元 func no07_2() { var a [3][3]int = [3][3]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} var b [][]int = [][]int{{1, 2, 3}, {4, 5, 6}} var c [][]int = [][]int{make([]int, 3), make([]int, 3)} var d [][]int = make([][]int, 2) for i := range d { d[i] = make([]int, 3) } var e [][]int f := [2][3]int{} fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, d) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, e) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, f) } 結果\np: [[1 2 3] [4 5 6] [7 8 9]] ----- p: [[1 2 3] [4 5 6]] ----- p: [[0 0 0] [0 0 0]] ----- p: [[0 0 0] [0 0 0]] ----- p: [] ----- p: [[0 0 0] [0 0 0]] 新增 func no07_3() { var a []int = []int{1, 2, 3} var b []int var c [][]int = [][]int{{1, 2, 3}, {4, 5, 6}} var d []int = make([]int, 3) b = append(b, 1, 2, 3, 4) c[0] = append(c[0], 4) copy(d, a) //複製進去的容量要足夠才能複製 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) } 結果\np: [1 2 3] ----- p: [1 2 3 4] ----- p: [[1 2 3 4] [4 5 6]] 大小 func no07_4() { var a []int = []int{1, 2, 3} var b [][]int = [][]int{{1, 2, 3}, {4, 5, 6}} fmt.Println(\u0026#34;p:\u0026#34;, len(a)) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, len(b)) fmt.Println(\u0026#34;-----\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, len(b[0])) } 結果\np: 3 ----- p: 2 ----- p: 3 顯示 func no07_5() { var a []int = []int{1, 2, 3} for i := range a { //顯示key fmt.Println(\u0026#34;p:\u0026#34;, i) } fmt.Println(\u0026#34;-----\u0026#34;) for _, i := range a { //顯示值 fmt.Println(\u0026#34;p:\u0026#34;, i) } } 結果\np: 0 p: 1 p: 2 ----- p: 1 p: 2 p: 3 參考資料:\n連結：底層為陣列的 slice | openhome.cc網址：https://openhome.cc/Gossip/Go/Slice.html\n連結：Go 语言切片(Slice) | 菜鸟教程網址：https://www.runoob.com/go/go-slice.html\n連結：[Golang] 程式設計教學：使用陣列 (Array) 和切片 (Slice) | 開源技術教學網址：https://opensourcedoc.com/golang-programming/array-slice/\n","permalink":"https://tom8760925.github.io/tomku/golang/no/07/","summary":"這篇是golang的練習筆記第07篇","title":"golang語言的練習-陣列"},{"content":"迴圈 這篇是golang的練習筆記第06篇\n宣告 package main import \u0026#34;fmt\u0026#34; func main() { no06_2() } func no06_1() { var a int = 1 for i := 1; i \u0026lt; 3; i++ { fmt.Println(\u0026#34;p:\u0026#34;, i) } fmt.Println(\u0026#34;----\u0026#34;) for a \u0026lt; 3 { fmt.Println(\u0026#34;p:\u0026#34;, a) a++ } } 結果\np: 1 p: 2 ---- p: 1 p: 2 其他 func no06_2() { for i := 1; i \u0026lt; 4; i++ { if i == 2 { continue } fmt.Println(\u0026#34;p:\u0026#34;, i) } fmt.Println(\u0026#34;----\u0026#34;) for i := 1; i \u0026lt; 4; i++ { if i == 2 { break } fmt.Println(\u0026#34;p:\u0026#34;, i) } fmt.Println(\u0026#34;----\u0026#34;) var a int = 1 test: //從這裡重新開始 for a \u0026lt; 4 { if a == 2 { a++ goto test //會返到test } fmt.Println(\u0026#34;p:\u0026#34;, a) a++ } } 結果\np: 1 p: 3 ---- p: 1 ---- p: 1 p: 3 參考資料:\n連結：Go 语言 goto 语句 | 菜鸟教程網址：https://www.runoob.com/go/go-goto-statement.html\n","permalink":"https://tom8760925.github.io/tomku/golang/no/06/","summary":"這篇是golang的練習筆記第06篇","title":"golang語言的練習-迴圈"},{"content":"if 這篇是golang的練習筆記第05篇\npackage main import \u0026#34;fmt\u0026#34; func main() { no05_1() } func no05_1() { var a int = 1 var b string = \u0026#34;Apple\u0026#34; if a == 1 { fmt.Println(\u0026#34;p:\u0026#34;, a) } else if a == 2 { fmt.Println(\u0026#34;p:\u0026#34;, a) } else { fmt.Println(\u0026#34;p:\u0026#34;, a) } fmt.Println(\u0026#34;-----\u0026#34;) switch b { case \u0026#34;Apple\u0026#34;: fmt.Println(\u0026#34;p:\u0026#34;, b) case \u0026#34;banana\u0026#34;: fmt.Println(\u0026#34;p:\u0026#34;, b) default: fmt.Println(\u0026#34;p:\u0026#34;, b) } } 結果\np: 1 ----- p: Apple ","permalink":"https://tom8760925.github.io/tomku/golang/no/05/","summary":"這篇是golang的練習筆記第05篇","title":"golang語言的練習-if"},{"content":"函數 這篇是golang的練習筆記第04篇\npackage main import \u0026#34;fmt\u0026#34; func main() { no04_1() } func no04_1() { a := no04_1r fmt.Println(\u0026#34;p:\u0026#34;, no04_1r(2, \u0026#34;A\u0026#34;)) fmt.Println(\u0026#34;------\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, a(2, \u0026#34;B\u0026#34;)) } func no04_1r(n int, i string) int { fmt.Println(\u0026#34;p:\u0026#34;, i) fmt.Println(\u0026#34;p:\u0026#34;, n) fmt.Println(\u0026#34;------\u0026#34;) return n } 結果\np: A p: 2 ------ p: 2 ------ p: B p: 2 ------ p: 2 回傳複數的值\nfunc no04_2() { a, b := no04_2r(1, \u0026#34;A\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;------\u0026#34;) var c int var d string c, d = no04_2r2(2, \u0026#34;B\u0026#34;) fmt.Println(\u0026#34;p:\u0026#34;, c) fmt.Println(\u0026#34;p:\u0026#34;, d) } func no04_2r(n int, i string) (int, string) { return n, i } func no04_2r2(n int, i string) (rn int, ri string) { rn = n ri = i return } 結果\np: 1 p: A ------ p: 2 p: B 參考資料:\n連結：函式入門 | openhome.cc網址：https://openhome.cc/Gossip/Go/Function.html\n連結：一級函式 | openhome.cc網址：https://openhome.cc/Gossip/Go/FirstClassFunction.html\n連結：Go 语言函数 | 菜鸟教程網址：https://www.runoob.com/go/go-functions.html\n","permalink":"https://tom8760925.github.io/tomku/golang/no/04/","summary":"這篇是golang的練習筆記第04篇","title":"golang語言的練習-函數"},{"content":"print和scan 這篇是golang的練習筆記第03篇\nprint package main import \u0026#34;fmt\u0026#34; func main() { no03_1() } func no03_1() { var a int = 1 fmt.Print(\u0026#34;p:\u0026#34;, a, \u0026#34;\\n\u0026#34;) //單純顯示 fmt.Printf(\u0026#34;p:%d\\n\u0026#34;, a) //使用參數 fmt.Println(\u0026#34;p:\u0026#34;, a) //自動換行 } 結果\np:1 p:1 p: 1 scan func no03_2() { var a, b int = 0, 0 fmt.Print(\u0026#34;s:\u0026#34;) fmt.Scan(\u0026amp;a, \u0026amp;b) //可以連續讀取，並可以用空白符號間隔兩個變數的輸入 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-------\u0026#34;) fmt.Print(\u0026#34;s:\u0026#34;) fmt.Scanf(\u0026#34;%d-%d\u0026#34;, \u0026amp;a, \u0026amp;b) //可以使用參數，並可以自行設定符號作為間隔 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) fmt.Println(\u0026#34;-------\u0026#34;) fmt.Print(\u0026#34;s:\u0026#34;) fmt.Scanln(\u0026amp;a, \u0026amp;b) //只要到換行符號就停止 fmt.Println(\u0026#34;p:\u0026#34;, a) fmt.Println(\u0026#34;p:\u0026#34;, b) } 結果\ns:1 2 p: 1 p: 2 ------- s:3-4 p: 3 p: 4 ------- s:5 6 p: 5 p: 6 參考資料:\n連結：fmt package - fmt - Go Packages網址：https://pkg.go.dev/fmt\n","permalink":"https://tom8760925.github.io/tomku/golang/no/03/","summary":"這篇是golang的練習筆記第03篇","title":"golang語言的練習-print和scan"},{"content":"unordered_map 這篇是C++的筆記第06篇\nc++有像python的字典的常數\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; int main() { unordered_map\u0026lt;string, int\u0026gt; a = {{\u0026#34;a\u0026#34;, 1}, // 宣告 {\u0026#34;b\u0026#34;, 2}, {\u0026#34;c\u0026#34;, 3}, {\u0026#34;d\u0026#34;, 4}}; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a[\u0026#34;a\u0026#34;] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; if (a.insert(make_pair(\u0026#34;e\u0026#34;, 5)).second) // 新增，如果鍵值已經有就會新增失敗回傳false { cout \u0026lt;\u0026lt; \u0026#34;p:true\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a[\u0026#34;e\u0026#34;] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.count(\u0026#34;a\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 用鍵值找是否存在 cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.count(\u0026#34;f\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a.insert({\u0026#34;f\u0026#34;, 6}); cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.count(\u0026#34;f\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 大小 cout \u0026lt;\u0026lt; \u0026#34;--------\\n\u0026#34;; a.erase(\u0026#34;e\u0026#34;); // 刪除 a.clear(); if (a.empty()) // 判斷是否為空 { cout \u0026lt;\u0026lt; \u0026#34;p:0\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } 結果\np:1 -------- p:true p:5 -------- p:1 p:0 p:1 -------- p:6 -------- p:0 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/06/","summary":"這篇是C++的筆記第06篇","title":"C++語言的筆記-unordered_map"},{"content":"型態 這篇是golang的練習筆記第02篇\ngolang的變數有８、１６、３２、６４的大小\n種類 名稱 8 16 32 64 數值 int 有 有 有 有 uint(無負號) 有 有 有 有 byte 有 沒有 沒有 沒有 rune 沒有 沒有 有 沒有 浮點數 float 沒有 沒有 有 有 字元 string 沒有 沒有 沒有 沒有 布林 bool 沒有 沒有 沒有 沒有 變數 func no02_1() { var a = 1 var a1 int = 2 var ( a2 int = 3 a3 string = \u0026#34;4\u0026#34; a4 bool ) var a5, a6 int = 5, 6 a7 := 7 //簡化寫法 fmt.Println(a) fmt.Println(a1) fmt.Println(a2) fmt.Println(a3) fmt.Println(a4) fmt.Println(a5) fmt.Println(a6) fmt.Println(a7) a5, a6 = a6, a5 //交換 fmt.Println(a5) fmt.Println(a6) } 結果\n1 2 3 4 false 5 6 7 6 5 常數 func no02_2() { const a = 1 const a1 int = 2 const ( a2 int = 3 a3 string = \u0026#34;4\u0026#34; ) const a4, a5 int = 5, 6 const ( //沒有宣告值會使用前一個值 a6 = 6 a7 ) fmt.Println(a) fmt.Println(a1) fmt.Println(a2) fmt.Println(a3) fmt.Println(a4) fmt.Println(a5) fmt.Println(a6) fmt.Println(a7) } 結果\n1 2 3 4 5 6 6 6 iota func no02_3() { const (//+1 a = iota a1 a2 ) const ( //二進位往左移 a3 = 1 \u0026lt;\u0026lt; iota //1 a4 //10 a5 //100 ) fmt.Println(a) fmt.Println(a1) fmt.Println(a2) fmt.Println(a3) fmt.Println(a4) fmt.Println(a5) } 結果\n0 1 2 1 2 4 ","permalink":"https://tom8760925.github.io/tomku/golang/no/02/","summary":"這篇是golang的練習筆記第02篇","title":"golang語言的練習-型態"},{"content":"環境設置 這篇是golang的練習筆記第01篇\n以下以mac的vscode進行操作\n安裝golang 去以下網址下載golang(mac要安裝arm64)\nhttps://go.dev/ 使用以下指令確認是否安裝成功。\ngo version 安裝VSCODE插建 安裝golang的插件\nhttps://marketplace.visualstudio.com/items?itemName=golang.Go 起始設定 在上面輸入指令更新插件\nGo: Install/Update tools 在終端機輸入\ngo mod init (資料夾名稱) 就會出現go.mod\n在偵錯按新增launch.json，然後在裡面加\n\u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; 啟動測試 新增.go檔案，裡面寫入程式進行測試，如果沒問題應該能執行。\npackage main func main() { } 參考資料:\n連結：設定 Visual Studio Code for Go 開發 - Go on Azure | Microsoft learn網址：https://learn.microsoft.com/zh-tw/azure/developer/go/configure-visual-studio-code\n","permalink":"https://tom8760925.github.io/tomku/golang/no/01/","summary":"這篇是golang的練習筆記第01篇","title":"golang語言的練習-環境設置"},{"content":" 這篇是C++的練習實作第03篇\n嘗試用visual studio 製作和理解win32 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c++/practice/03/","summary":"這篇是C++的練習實作第03篇","title":"C++語言的練習-練習實作win32"},{"content":"MFC設置 這篇是C++的練習筆記第10篇\n安裝visual studio\nhttps://visualstudio.microsoft.com/zh-hant/downloads/ 將使用c++的桌面開發裡面的mfc勾選。\n","permalink":"https://tom8760925.github.io/tomku/c++/no/10/","summary":"這篇是C++的練習筆記第10篇","title":"C++語言的練習-MFC設置"},{"content":" 這篇是C++的練習實作第02篇\n練習使用variant、例外、函數、命名空間、迴圈、陣列、結構、預處理、模板、輸入輸出、繼承。\n#include \u0026lt;stdio.h\u0026gt; //載入指令 #include \u0026lt;iostream\u0026gt; //載入指令 #include \u0026lt;string\u0026gt; //載入指令 #include \u0026lt;vector\u0026gt; //載入指令 #include \u0026lt;typeinfo\u0026gt; //載入指令 using namespace std; #ifndef MAX // 定義 #define MAX 2 #endif namespace student_input // 輸入 { class st_input_default // 輸入預設 { public: st_input_default(vector\u0026lt;string\u0026gt; sa) : sa(sa) {} ~st_input_default() { cout \u0026lt;\u0026lt; \u0026#34;輸入完成\u0026#34; \u0026lt;\u0026lt; endl; } void st_input_cout(int n) { cout \u0026lt;\u0026lt; \u0026#34;請輸入\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;sa[n] \u0026lt;\u0026lt; \u0026#34;:\u0026#34;; } protected: vector\u0026lt;string\u0026gt; sa; // 輸入的欄位名稱 }; class st_input_add : public st_input_default // 新增 { public: using st_input_default::st_input_default; template \u0026lt;typename T\u0026gt; void st_input_cin(T *s, int n) // 輸入資料 { auto i = *s; st_input_cout(n); cin \u0026gt;\u0026gt; i; *s = i; cout \u0026lt;\u0026lt; this-\u0026gt;sa[n] \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } }; } namespace student_output // 輸出 { class st_output_default // 輸出預設 { public: st_output_default(vector\u0026lt;string\u0026gt; sa) : sa(sa) {} ~st_output_default() { cout \u0026lt;\u0026lt; \u0026#34;顯示完成\u0026#34; \u0026lt;\u0026lt; endl; } protected: vector\u0026lt;string\u0026gt; sa; // 輸出的欄位名稱 }; class st_output_show : public st_output_default // 顯示資料 { public: using st_output_default::st_output_default; template \u0026lt;typename T\u0026gt; void st_output_cout(T s, int n) // 顯示欄位資料 { cout \u0026lt;\u0026lt; this-\u0026gt;sa[n] \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } }; } struct student // 結構宣告 { int id; string name; int no, score; student() { id = 0; name = \u0026#34;\u0026#34;; no = 0; score = 0; } student(int id) : id(id) {} student(int id, string name, int no, int score) : id(id), name(name), no(no), score(score) {} }; struct visit_type // 判斷資料型態 { string type = \u0026#34;\u0026#34;; // 存放資料的型態 void operator()(const int *t) { type = \u0026#34;int*\u0026#34;; } void operator()(const int t) { type = \u0026#34;int\u0026#34;; } void operator()(const string *t) { type = \u0026#34;string*\u0026#34;; } void operator()(const string t) { type = \u0026#34;string\u0026#34;; } }; void st_input(int n); // 函數宣告 void st_list(int n); // 函數宣告 void st_sumscore(int n); // 函數宣告 vector\u0026lt;struct student\u0026gt; student_data; // 資料庫 int main() { string cin_if; int n = 0; bool cin_if_while = true; while (cin_if_while) { cout \u0026lt;\u0026lt; \u0026#34;輸入1輸入學生資料(最多輸入\u0026#34; \u0026lt;\u0026lt; MAX \u0026lt;\u0026lt; \u0026#34;筆資料，現在已經輸入\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;筆)\\n輸入2計算總成績\\n輸入3查看輸入的資料\\n輸入4離開\\n請輸入半形的1、2、3、4:\u0026#34;; cin \u0026gt;\u0026gt; cin_if; try { switch (stoi(cin_if)) { case 1: if (n \u0026lt; MAX) { st_input(n + 1); n++; } else { cout \u0026lt;\u0026lt; \u0026#34;已達輸入上限\u0026#34; \u0026lt;\u0026lt; endl; } break; case 2: if (n \u0026gt; 0) { st_sumscore(n); } else { cout \u0026lt;\u0026lt; \u0026#34;尚未輸入任何資料\u0026#34; \u0026lt;\u0026lt; endl; } break; case 3: if (n \u0026gt; 0) { st_list(n); } else { cout \u0026lt;\u0026lt; \u0026#34;尚未輸入任何資料\u0026#34; \u0026lt;\u0026lt; endl; } break; case 4: cin_if_while = false; cout \u0026lt;\u0026lt; \u0026#34;結束\u0026#34; \u0026lt;\u0026lt; endl; break; default: cout \u0026lt;\u0026lt; \u0026#34;輸入錯誤(請輸入半形的1-4)\u0026#34; \u0026lt;\u0026lt; endl; break; } } catch (const std::invalid_argument \u0026amp;e) // 輸入了數字以外的的例外 { cout \u0026lt;\u0026lt; \u0026#34;輸入錯誤(請輸入半形的1-4)\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } void st_input(int n) // 輸入資料 { using namespace student_input; vector\u0026lt;string\u0026gt; vector_string = {\u0026#34;姓名\u0026#34;, \u0026#34;學號\u0026#34;, \u0026#34;成績\u0026#34;}; // 欄位名稱 struct student stud(n); struct visit_type vt; vector\u0026lt;variant\u0026lt;int *, string *\u0026gt;\u0026gt; vector_student = {\u0026amp;stud.name, \u0026amp;stud.no, \u0026amp;stud.score}; // 資料型態 st_input_add st(vector_string); for (int i = 0; i \u0026lt; (int)vector_string.size(); i++) { visit(vt, vector_student[i]); // 判斷資料型態 if (vt.type == \u0026#34;int*\u0026#34;) { st.st_input_cin(get\u0026lt;int *\u0026gt;(vector_student[i]), i); // 資料型態為int } else if (vt.type == \u0026#34;string*\u0026#34;) { st.st_input_cin(get\u0026lt;string *\u0026gt;(vector_student[i]), i); // 資料型態為string } } student_data.push_back(stud); // 將資料存放到資料庫 } void st_list(int n) // 顯示資料 { using namespace student_output; vector\u0026lt;string\u0026gt; vector_string = {\u0026#34;編號\u0026#34;, \u0026#34;姓名\u0026#34;, \u0026#34;學號\u0026#34;, \u0026#34;成績\u0026#34;}; // 欄位名稱 st_output_show st(vector_string); struct visit_type vt; for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;variant\u0026lt;int, string\u0026gt;\u0026gt; vector_student = {student_data[i].id, student_data[i].name, student_data[i].no, student_data[i].score}; // 資料型態 for (int ii = 0; ii \u0026lt; (int)vector_string.size(); ii++) { visit(vt, vector_student[ii]); // 判斷資料型態 if (vt.type == \u0026#34;int\u0026#34;) { st.st_output_cout(get\u0026lt;int\u0026gt;(vector_student[ii]), ii); // 資料型態為int } else if (vt.type == \u0026#34;string\u0026#34;) { st.st_output_cout(get\u0026lt;string\u0026gt;(vector_student[ii]), ii); // 資料型態為string } } } } void st_sumscore(int n) // 計算總成績 { using namespace student_output; vector\u0026lt;string\u0026gt; vector_string = {\u0026#34;總成績\u0026#34;}; // 欄位名稱 st_output_show st(vector_string); int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += student_data[i].score; } st.st_output_cout(sum, 0); // 顯示總成績 } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c++/practice/02/","summary":"這篇是C++的練習實作第02篇","title":"C++語言的練習-練習實作02"},{"content":"lambda 這篇是C++的筆記第05篇\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 1; auto la = [](int n) -\u0026gt; int { return n; }; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; la(a) \u0026lt;\u0026lt; endl; return 0; } 結果\np:1 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/05/","summary":"這篇是C++的筆記第05篇","title":"C++語言的筆記-lambda"},{"content":"variant 這篇是C++的練習筆記第09篇\nc++有可以儲存多種型態的容器\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { variant\u0026lt;int, string\u0026gt; a, b;//宣告型態的種類和變數 a = 11; b = \u0026#34;AA\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; get\u0026lt;int\u0026gt;(a) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;//輸出值 cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; get\u0026lt;string\u0026gt;(b) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;//輸出值 if (get_if\u0026lt;int\u0026gt;(\u0026amp;a) != nullptr)//判斷變數的型態是否正確，不正確就輸出nullptr，要記得加上\u0026amp;。 { cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; get\u0026lt;int\u0026gt;(a) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } 結果\np;11 p;AA p;11 visit 型態自動判斷\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct t { void operator()(const int \u0026amp;t) { cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void operator()(const string \u0026amp;t) { cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } }; struct tt { string a = \u0026#34;\u0026#34;; void operator()(const int \u0026amp;t) { a = \u0026#34;int\u0026#34;; } void operator()(const string \u0026amp;t) { a = \u0026#34;string\u0026#34;; } }; int main() { struct t tt; struct tt tt2; variant\u0026lt;int, string\u0026gt; a, b; // 宣告型態的種類和變數 a = 11; b = \u0026#34;AA\u0026#34;; visit([](auto \u0026amp;\u0026amp;arg) { cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; arg \u0026lt;\u0026lt; endl; }, a); visit(tt, a); visit(tt2, a); cout \u0026lt;\u0026lt; \u0026#34;p;\u0026#34; \u0026lt;\u0026lt; tt2.a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } 結果\np:11 p;11 p;int 參考資料:\n連結：如何优雅的使用 std::variant 与 std::optional - 知乎網址：https://zhuanlan.zhihu.com/p/366537214\n連結：std::variant - cppreference.com網址：https://en.cppreference.com/w/cpp/utility/variant\n連結：C++17 更通用的 union：variant - Heresy's Space網址：https://kheresy.wordpress.com/2017/10/16/cpp17-variant/\n","permalink":"https://tom8760925.github.io/tomku/c++/no/09/","summary":"這篇是C++的練習筆記第09篇","title":"C++語言的練習-variant"},{"content":"正規表達式 這篇是C++的筆記第04篇\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;regex\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; void rim(string n); int main(){ string a=\u0026#34;AzxB\u0026#34;,b=\u0026#34;12456\u0026#34;; rim(a); cout\u0026lt;\u0026lt;\u0026#34;-----\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; rim(b); cout\u0026lt;\u0026lt;endl; return 0; } void rim(string n){ regex r(\u0026#34;[A-Za-z]*\u0026#34;); if(regex_match(n,r)){//與字串比對 cout\u0026lt;\u0026lt;\u0026#34;T\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else{ cout\u0026lt;\u0026lt;\u0026#34;F\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } 結果\nT ----- F ","permalink":"https://tom8760925.github.io/tomku/c++/notes/04/","summary":"這篇是C++的筆記第04篇","title":"C++語言的筆記-正規表達式"},{"content":"const 這篇是C++的筆記第03篇 加上const，就不能跟改值。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { const int a = 1; int const b = 2; int aa = 1; int bb = 2; const int *c = \u0026amp;aa; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 不能用a=2，改變值。 cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 不能用b=3，改變值。 cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; *c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 不能用*c = 2，改變aa值。 c = \u0026amp;bb; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; *c \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 但能改變指數，改為bb。 cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; int *const d = \u0026amp;aa; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; *d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 不能用d = \u0026amp;bb，改變aa值。 *d = 2; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; *d \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 但能改變指數，改為bb。 cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; const int *const e = \u0026amp;aa; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; *e \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 不能用*e = 2 也不能用e = \u0026amp;b;，改變任何值。 cout \u0026lt;\u0026lt; \u0026#34;------\\n\u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 結果\np:1 ------ p:2 ------ p:1 p:2 ------ p:1 p:2 ------ p:2 ------ ","permalink":"https://tom8760925.github.io/tomku/c++/notes/03/","summary":"這篇是C++的筆記第03篇","title":"C++語言的筆記-const"},{"content":"例外 這篇是C++的練習筆記第08篇\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ try { throw \u0026#34;1\u0026#34;;//發生例外 } catch(const exception\u0026amp; e)//根據例外顯示結果 { cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;endl; return 0; } 結果\nlibc++abi: terminating due to uncaught exception of type char Abort 例外可以顯示自定文字\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ try { throw \u0026#34;A\u0026#34;;//發生例外 } catch(const char * e)//根據例外顯示結果 { cerr \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:A ","permalink":"https://tom8760925.github.io/tomku/c++/no/08/","summary":"這篇是C++的練習筆記第08篇","title":"C++語言的練習-例外"},{"content":"命名空間 這篇是C++的練習筆記第07篇\n#include \u0026lt;iostream\u0026gt; using namespace std; namespace a { int r(int n){ return n; } namespace b { int r2(int n){ return n+1; } } } using namespace a; using namespace b;//指向b using namespace a::b;//指向b int main(){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;r(1)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;r2(1)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a::b::r2(1)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:1 p:2 p:2 參考資料:\n連結：類別和結構 (C++) | Microsoft Learn 網址：https://learn.microsoft.com/zh-tw/cpp/cpp/classes-and-structs-cpp?view=msvc-170\n","permalink":"https://tom8760925.github.io/tomku/c++/no/07/","summary":"這篇是C++的練習筆記第07篇","title":"C++語言的練習-命名空間"},{"content":"模板 這篇是C++的練習筆記第06篇\n#include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; void a(T n); int main(){ a(1); a(\u0026#39;A\u0026#39;); cout\u0026lt;\u0026lt;endl; return 0; } template \u0026lt;typename T\u0026gt; void a(T n){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } 結果\np:1 p:A ","permalink":"https://tom8760925.github.io/tomku/c++/no/06/","summary":"這篇是C++的練習筆記第06篇","title":"C++語言的練習-模板"},{"content":"繼承 這篇是C++的練習筆記第05篇\n創建 #include \u0026lt;iostream\u0026gt; using namespace std; class a { public: int pca(){ return 1; } }; class b:public a { public: int pcb(){ return 2; } }; int main(){ a ca; b cb; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;ca.pca()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;cb.pca()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;cb.pcb()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 結果\np:1 p:1 p:2 控制 繼承有3個控制\n#include \u0026lt;iostream\u0026gt; using namespace std; class a { public: void pca(){ cout\u0026lt;\u0026lt;\u0026#34;--pca--\\n\u0026#34;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;pda()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;pea()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } protected: int pda(){ return 2; } private: int pea(){ return 3; } }; class b : public a { public: void pcb(){ pca(); cout\u0026lt;\u0026lt;\u0026#34;--pcb--\\n\u0026#34;; cout\u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;pda()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } }; class c : protected b { public: void pcc(){ pcb(); } }; class d : private c { public: void pcd(){ pcc(); } }; int main(){ a ca; b cb; c cc; d cd; cout\u0026lt;\u0026lt;\u0026#34;--ca--\\n\u0026#34;; ca.pca(); cout\u0026lt;\u0026lt;\u0026#34;--cb--\\n\u0026#34;; cb.pcb(); cb.pca(); cout\u0026lt;\u0026lt;\u0026#34;--cc--\\n\u0026#34;; cc.pcc();//因為控制權限所以不能使用pca cout\u0026lt;\u0026lt;\u0026#34;--cd--\\n\u0026#34;; cd.pcd();//因為控制權限所以不能使用pca cout\u0026lt;\u0026lt;endl; return 0; } 結果\n--ca-- --pca-- p:2 p:3 --cb-- --pca-- p:2 p:3 --pcb-- p:2 --pca-- p:2 p:3 --cc-- --pca-- p:2 p:3 --pcb-- p:2 --cd-- --pca-- p:2 p:3 --pcb-- p:2 宣告 constructor是建構宣告\n#include \u0026lt;iostream\u0026gt; using namespace std; class a { public: a()=default;//設定預設 a(int n):n(n){} a(int n1,int n2){ this-\u0026gt;n=n1+n2; } a(const a\u0026amp;)=delete;//將這個宣告禁止，例ca1=ca2不能用。 void pca(){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;this-\u0026gt;n\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } private: int n=0; }; int main(){ a ca1; ca1.pca(); a ca2(1); ca2.pca(); a ca3(1,2); ca3.pca(); cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:0 p:1 p:3 繼承 #include \u0026lt;iostream\u0026gt; using namespace std; class a { public: a(int n):n(n){} void pca(){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;this-\u0026gt;n\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } private: int n=0; }; class b :public a { public: using a::a;//直接繼承宣告 void pcb(){ a::pca();//直接繼承函式 } }; class c :public a { using ca=a;//將繼承修改 public: using ca::a; void pcc(){ ca::pca(); } }; int main(){ b cb(1); cb.pcb(); cout\u0026lt;\u0026lt;\u0026#34;----\\n\u0026#34;; c cc(2); cc.pcc(); cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:1 ---- p:2 參考資料:\n連結：類別和結構 (C++) | Microsoft Learn網址：https://learn.microsoft.com/zh-tw/cpp/cpp/classes-and-structs-cpp?view=msvc-170\n連結：C++ 继承 | 菜鸟教程網址：https://www.runoob.com/cplusplus/cpp-inheritance.html\n連結：C繼承共同行為網址：https://openhome.cc/Gossip/CppGossip/Inheritance.html\n連結：遮蔽父類方法網址：https://openhome.cc/Gossip/CppGossip/HideMemberFunction.html\n","permalink":"https://tom8760925.github.io/tomku/c++/no/05/","summary":"這篇是C++的練習筆記第05篇","title":"C++語言的練習-繼承"},{"content":"執行問題 這篇是C++的筆記第02篇\n在mac上使用vscode，如果使用到c++11的，可能會發生錯誤。\n將可能解決方法記錄。\n在延伸模組c/c++中的cpp standard和cpp standard設定c++17和c17。還有在seetting.json的\u0026quot;cpp\u0026quot;:裡面加入-std=c++17 -pthread 在延伸模組complie run configuration中cpp-flags裡面加入-std=c++17(有使用到C/C++ Compile Run，才需要使用) 將四個json設定欓刪掉重新創建。 ","permalink":"https://tom8760925.github.io/tomku/c++/notes/02/","summary":"這篇是C++的筆記第02篇","title":"C++語言的筆記-執行問題"},{"content":"vector 這篇是C++的練習筆記第04篇\nc++有個動態調整的陣列，會預留陣列空間。\n宣告 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; a; vector\u0026lt;int\u0026gt; b = {1,2,3}; vector\u0026lt;int\u0026gt; c {1,2,3}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; d {{1,2},{3}}; int e[]={4,5,6}; vector\u0026lt;int\u0026gt; f (e,e+3); vector\u0026lt;int\u0026gt; g (b.begin()+1,b.end()-1); for(int n=0 ;n\u0026lt;3;n++){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;b[n]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;\u0026#34;---\\n\u0026#34;; for(int n=0 ;n\u0026lt;3;n++){ cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;\u0026#34;---\\n\u0026#34;; for(auto \u0026amp;n:g){//簡易顯示方法 cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } cout\u0026lt;\u0026lt;\u0026#34;---\\n\u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; a.reserve(3);//預先配置記憶體大小 cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:1 p:2 p:3 --- p:4 p:5 p:6 --- p:2 --- p:0 p:3 新增 使用pop_back後，因為會預留空間，所以值還會在。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; a = {1,2,3}; a.push_back(4); cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a[3]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; a.pop_back(); cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a[3]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;//值還是在 cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:4 p:3 p:4 大小 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; a = {1,2,3,4,5}; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;//大小 cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.end()-a.begin()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;//記憶體大小 cout\u0026lt;\u0026lt;\u0026#34;---\\n\u0026#34;; a.push_back(6); cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; a.shrink_to_fit();//清多餘的記憶體大小 cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.size()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a.capacity()\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;endl; return 0; } 結果\np:5 p:5 p:5 --- p:6 p:10 p:6 p:6 參考資料:\n連結：C++ std::vector 用法與範例網址：https://shengyu7697.github.io/std-vector/\n連結：使用 vector網址：https://openhome.cc/Gossip/CppGossip/vector1.html\n","permalink":"https://tom8760925.github.io/tomku/c++/no/04/","summary":"這篇是C++的練習筆記第04篇","title":"C++語言的練習-vector"},{"content":"字串複製 這篇是C的筆記第06篇\nstrcpy 將字串複製到變數內，因為字串無法用a=\u0026ldquo;AA\u0026rdquo;，所以可以使用strcpy。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main(){ char a[50],b[50]; strcpy(a,\u0026#34;AA\u0026#34;); strcpy(b,a); printf(\u0026#34;p:%s\\n\u0026#34;,a); printf(\u0026#34;p:%s\\n\u0026#34;,b); return 0; } 結果\np:AA p:AA strdup strdup也是複製，只是是先用malloc創建才複製。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ char *a,b[]=\u0026#34;AA\u0026#34;; a=strdup(b); printf(\u0026#34;p:%s\\n\u0026#34;,a); printf(\u0026#34;p:%s\\n\u0026#34;,b); free(a); return 0; } 結果\np:AA p:AA ","permalink":"https://tom8760925.github.io/tomku/c/notes/06/","summary":"這篇是C的筆記第06篇","title":"C語言的筆記-字串複製"},{"content":"strlen 這篇是C的筆記第05篇\nc有陣列長度的方法strlen，需要宣告#include \u0026lt;string.h\u0026gt;，而他找的是有存資料的長度。\n#include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main(){ char a[50],b[50]=\u0026#34;AAA\u0026#34;; int c=0,d=0; c=strlen(a); d=strlen(b); printf(\u0026#34;p:%d\\n\u0026#34;,c); printf(\u0026#34;p:%d\\n\u0026#34;,d); return 0; } 結果\np:0 p:3 ","permalink":"https://tom8760925.github.io/tomku/c/notes/05/","summary":"這篇是C的筆記第05篇","title":"C語言的筆記-陣列長度"},{"content":"auto 這篇是C++的筆記第01篇\nc++有自動判斷型態，但不能兩種不同型態不能放在一起，像auto a=11,b=\u0026ldquo;AA\u0026rdquo;。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ auto a=11; auto b=\u0026#34;AA\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt;endl; return 0; } 結果\np:11 p:AA ","permalink":"https://tom8760925.github.io/tomku/c++/notes/01/","summary":"這篇是C++的筆記第01篇","title":"C++語言的筆記-auto"},{"content":" 這篇是C++的練習實作第01篇\n使用C語言的練習-練習實作01，改成C++練習使用函式宣告，輸入姓名、學號、成績，並顯示出來。\n#include \u0026lt;iostream\u0026gt; //載入指令 #include \u0026lt;string\u0026gt;//載入指令 using namespace std; void student_input();//函數宣告 int main(){ student_input();//呼叫函數 return 0; } void student_input(){ string name=\u0026#34;\u0026#34;; int no=0,score=0; cout \u0026lt;\u0026lt; \u0026#34;請輸入姓名:\u0026#34;;//顯示需要輸入的值 cin \u0026gt;\u0026gt; name;//輸入的值 cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;//顯示輸入的值 cout \u0026lt;\u0026lt; \u0026#34;請輸入學號:\u0026#34;;//顯示需要輸入的值 cin \u0026gt;\u0026gt; no;//輸入的值 cout \u0026lt;\u0026lt; \u0026#34;學號:\u0026#34; \u0026lt;\u0026lt; no \u0026lt;\u0026lt; endl;//顯示輸入的值 cout \u0026lt;\u0026lt; \u0026#34;請輸入成績:\u0026#34;;//顯示需要輸入的值 cin \u0026gt;\u0026gt; score;//輸入的值 cout \u0026lt;\u0026lt; \u0026#34;成績:\u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; endl;//顯示輸入的值 } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c++/practice/01/","summary":"這篇是C++的練習實作第01篇","title":"C++語言的練習-練習實作01"},{"content":"輸入輸出 這篇是C++的練習筆記第03篇\nC++的輸入輸出，可以使用C語言的練習-printf 和 scanf那篇的方法。\nC++有增加輸入輸出的方法\ncout 用來顯示\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int a=11,b=22; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; a; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;and\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;std::flush; return 0; } 結果\np：11 p：11 p：11 p：11and22 endl可以使用\\n替代，endl等於\u0026rsquo;\\n\u0026rsquo;\u0026laquo;std::flush，換行之後清暫存。\ncin 用來輸入 cin 可以同時輸入兩個，可以直接按enter後在輸入，或在中間加空格。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int a=0,b=0; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;; cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;; cin \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt;b; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt;b; cout \u0026lt;\u0026lt; \u0026#34;p:\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;+\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0; } 結果\np:1 p:2 p:1+2 p:1 2 p:1+2 p:1 2 p:1+2 cerr 是用來顯示錯誤訊息。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int a=0; cerr \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 結果\n0 Clog 是用來顯示log訊息。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int a=0; clog \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 結果\n0 ","permalink":"https://tom8760925.github.io/tomku/c++/no/03/","summary":"這篇是C++的練習筆記第03篇","title":"C++語言的練習-輸入輸出"},{"content":"型態 這篇是C++的練習筆記第02篇\n記錄C++有哪些型態\n在型態前面加上unsigned，會變強制沒有負號\n在型態前面加上signed，會變強制有負號\n種類 名稱 記憶體空間 加unsigned 加signed 數值 int 4 Bytes 可 可 short 2 Bytes 可 可 long 8 Bytes 可 可 long long 8 Bytes 不可 不可 浮點數 float 4 Bytes 不可 不可 double 8 Bytes 不可 不可 long double 16 Bytes 不可 不可 字元 char 1 Bytes 可 可 無種類 void 不可 不可 布林 bool 1 Bytes 不可 不可 Unicode wchar_t 不可 不可 c++有string，可以使用但需要宣告，才能使用string。\n#include \u0026lt;string\u0026gt; using namespace std; 使用方式\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ string d=\u0026#34;AAA\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;p：\u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } 結果\np：AAA ","permalink":"https://tom8760925.github.io/tomku/c++/no/02/","summary":"這篇是C++的練習筆記第02篇","title":"C++語言的練習-型態"},{"content":"環境設置 這篇是C++的練習筆記第01篇\n以下跟Ｃ的環境設置大致相同，只有副檔名不相同，C++的副檔名其中一個是cpp。\n以下是在MAC進行操作執行\n安裝VSCODE 去以下網址下載VSCODE\nhttps://code.visualstudio.com/ 安裝VSCODE插建 安裝C的插件\nhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack 繁體插件\nhttps://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hant 起始設定 先在程式資料夾中新增檔案，名子隨意副檔名為.cpp 點選新增的.cpp檔案，再點選右上角齒輪\nC/C++:clang 建置及偵錯使用中的檔案 就會新增2個json欓 接著在收尋欄輸入\n\u0026gt;c/c++:Edit Configurations(JSON) 點選後會新增一個JSON檔案\n接著再輸入\nC/C++: 選取 IntelliSense 設定... 點選出現的編譯器其中一個。 就會新增一個JSON檔案\n啟動測試 接著就能執行程式偵錯 有兩個方式可以偵錯\n1.直接點上方的執行-\u0026gt;進行偵錯 但這個方法在使用scanf，輸入時會有問題，可以在launch.json裡面修改參數externalConsole改成true，就會額外乎叫終端機視窗。 2.點右邊上三角形下拉選點單，選CompileRun : Compile with default flags \u0026amp; Run with default arguments，就能直接在vscode裡的終端機進行操作，使用scanf輸入也不會有問題。 沒問題就能直接執行.cpp檔案\n有問題可能是因為.cpp檔案內沒有程式，可以先寫個起始程式，應該就能執行。\nint main(){ return 0; } 參考資料:\n連結：Configure VS Code for Clang/LLVM on macOS網址：https://code.visualstudio.com/docs/cpp/config-clang-mac\n","permalink":"https://tom8760925.github.io/tomku/c++/no/01/","summary":"這篇是C++的練習筆記第01篇","title":"C++語言的練習-環境設置"},{"content":"restrict 這篇是C的筆記第04篇\nc有可以優化指標的讀取的方法。\n#include \u0026lt;stdio.h\u0026gt; int test1(int *a,int *b,int *restrict c); int main(){ int a = 1; int b = 2; int c = 3; printf(\u0026#34;p:%d\\n\u0026#34;,test1(\u0026amp;a,\u0026amp;b,\u0026amp;c)); return 0; } int test1(int *a,int *b,int *restrict c){ *a += *c; *b += *c; return *a + *b; } 結果\np:9 參考資料:\n連結：restrict- Wikipedia網址：https://en.wikipedia.org/wiki/Restrict\n連結：C/C++关键字之restrict網址：https://backendhouse.github.io/post/c-c++%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Brestrict/\n","permalink":"https://tom8760925.github.io/tomku/c/notes/04/","summary":"這篇是C的筆記第04篇","title":"C語言的筆記-restrict"},{"content":"typedef 這篇是C的筆記第03篇\ntypedef可以對資料類型取別名\n#include \u0026lt;stdio.h\u0026gt; struct a //第一種 { int aa; }; typedef struct a b; int main(){ b c; c.aa=1; printf(\u0026#34;p:%d\\n\u0026#34;,c.aa); return 0; } 結果\np:1 參考資料:\n連結：Typedef - 維基百科，自由的百科全書網址：https://zh.wikipedia.org/wiki/Typedef\n","permalink":"https://tom8760925.github.io/tomku/c/notes/03/","summary":"這篇是C的筆記第03篇","title":"C語言的筆記-typedef"},{"content":"student 這篇是C的練習實作第05篇\n將鏈結加入、新增顯示輸入的資料\n#include \u0026lt;stdio.h\u0026gt;//載入指令 #include \u0026lt;stdbool.h\u0026gt;//載入指令 #include \u0026lt;stdlib.h\u0026gt;//載入指令 #include \u0026lt;ctype.h\u0026gt;//載入指令 #include \u0026lt;string.h\u0026gt;//載入指令 #ifndef MAX //定義 #define MAX 2 #endif struct student //結構宣告 { struct student *Previous; int ID; char name[50]; int no,score; struct student *next; }; void student_input(int n);//資料輸入 int student_score();//總成績 void student_list();//顯示輸入的資料 void scanf_flush();//清input buffer void student_flush();//清鏈結 struct student *head,*prt,*last;//結構變數宣告 char *pr[]={\u0026#34;英文姓名\u0026#34;,\u0026#34;學號\u0026#34;,\u0026#34;成績\u0026#34;},*scanf_if[]={\u0026#34;char\u0026#34;,\u0026#34;int\u0026#34;,\u0026#34;int\u0026#34;};//宣告 int main(){ char scanf_in[]=\u0026#34;\u0026#34;;//宣告 int scanf_number=0;//宣告 bool bool_n = true;//宣告 head = (struct student *)malloc(sizeof(struct student));//創建鏈結 head-\u0026gt;Previous=NULL; head-\u0026gt;next=NULL; last=head; while (bool_n)//判斷是否結束迴圈 { printf(\u0026#34;輸入1輸入學生資料(最多輸入%d筆資料，現在已經輸入%d筆)\\n輸入2計算總成績\\n輸入3查看輸入的資料\\n輸入4離開\\n請輸入1、2、3、4:\u0026#34;,(int)MAX,scanf_number);//顯示需要輸入的值 scanf(\u0026#34;%[1-4]s\u0026#34;,scanf_in);//輸入的值 switch (atoi(\u0026amp;scanf_in[0]))//判斷輸入的值 { case 1: if(scanf_number\u0026lt;MAX){//判斷輸入筆數 printf(\u0026#34;現在輸入的是第%d筆\\n\u0026#34;,scanf_number+1);//顯示筆數 student_input(scanf_number);//呼叫函數 scanf_number++;//筆數+1 } else{ printf(\u0026#34;現在已經輸入%d筆，結束輸入\\n\u0026#34;,scanf_number);//超過筆數強制結束 bool_n=false; } break; case 2: if(scanf_number\u0026gt;0){ printf(\u0026#34;總成績:%d\\n\u0026#34;,student_score());//總成績 } else{ printf(\u0026#34;並未輸入任何成績\\n\u0026#34;); } break; case 3: if(scanf_number\u0026gt;0){ student_list();//顯示輸入的資料 } else{ printf(\u0026#34;並未輸入任何成績\\n\u0026#34;); } break; case 4: printf(\u0026#34;離開\\n\u0026#34;);//結束迴圈 bool_n=false; student_flush();//清鏈結 break; default: printf(\u0026#34;輸入錯誤\\n\u0026#34;);//輸入的值錯誤 break; } scanf_flush();//清input buffer } return 0; } void student_input(int n){ prt=(struct student *)malloc(sizeof(struct student));//創建鏈結 void *scanf_void[]={\u0026amp;prt-\u0026gt;name,\u0026amp;prt-\u0026gt;no,\u0026amp;prt-\u0026gt;score};//宣告記憶體位置 for(int i=0;i\u0026lt;(int)(sizeof(pr)/sizeof(pr[0]));i++){//跑迴圈 scanf_flush();//清input buffer printf(\u0026#34;請輸入%s:\u0026#34;,pr[i]);//顯示需要輸入的值 if(strcmp(scanf_if[i],\u0026#34;char\u0026#34;)==0)//判斷輸入為字串或數值 { scanf(\u0026#34;%s\u0026#34;,(char *)scanf_void[i]);//輸入字串 printf(\u0026#34;%s:%s\\n\u0026#34;,pr[i],(char *)scanf_void[i]);//顯示數入值 } else { scanf(\u0026#34;%d\u0026#34;,(int *)scanf_void[i]);//輸入數值 printf(\u0026#34;%s:%d\\n\u0026#34;,pr[i],*(int *)scanf_void[i]);//顯示數入值 } } prt-\u0026gt;ID=n+1;//輸入登入資料 prt-\u0026gt;Previous=last;//輸入上一個鏈結位置 prt-\u0026gt;next=NULL;//輸入下一個鏈結位置 last-\u0026gt;next=prt;//上一個鏈結輸入下一個鏈結位置 last=prt; } int student_score(){ int return_score=0;//宣告 struct student *current; current=head-\u0026gt;next; while (current != NULL) { return_score+=current-\u0026gt;score;//計算總和 current=current-\u0026gt;next; } return return_score; } void student_list(){ struct student *current; current=head-\u0026gt;next; printf(\u0026#34;------\\n\u0026#34;); while (current != NULL) { printf(\u0026#34;登入編號:%d\\n\u0026#34;,current-\u0026gt;ID); void *scanf_void[]={\u0026amp;current-\u0026gt;name,\u0026amp;current-\u0026gt;no,\u0026amp;current-\u0026gt;score};//宣告記憶體位置 for(int i=0;i\u0026lt;(int)(sizeof(pr)/sizeof(pr[0]));i++){//跑迴圈 if(strcmp(scanf_if[i],\u0026#34;char\u0026#34;)==0)//判斷輸入為字串或數值 { printf(\u0026#34;%s:%s\\n\u0026#34;,pr[i],(char *)scanf_void[i]);//顯示數入值 } else { printf(\u0026#34;%s:%d\\n\u0026#34;,pr[i],*(int *)scanf_void[i]);//顯示數入值 } } printf(\u0026#34;------\\n\u0026#34;); current=current-\u0026gt;next; } } void scanf_flush(){ while ( (getchar()) != \u0026#39;\\n\u0026#39; ); } void student_flush(){ struct student *current; void *flush; current=head-\u0026gt;next; while (current != NULL) { flush=current; current=current-\u0026gt;next; free(flush); } } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/05/","summary":"這篇是C的練習實作第05篇","title":"C語言的練習-練習實作05"},{"content":"鏈結 這篇是C的練習筆記第11篇\n建立 鏈結的建立\n第一個 在輸入next時要注意，要先使用malloc才能輸入next，不然會是NULL。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct node { int ID; struct node *next; }; void node_in(); void node_up(); struct node *head,*prt1,*prt2,*prt3; int main(){ node_in(); printf(\u0026#34;-----\\n\u0026#34;); node_up(); return 0; } void node_in(){ head = (struct node *)malloc(sizeof(struct node)); head-\u0026gt;next=NULL; prt1=(struct node *)malloc(sizeof(struct node)); prt1-\u0026gt;ID=1; head-\u0026gt;next=prt1; printf(\u0026#34;p:%d\\n\u0026#34;,prt1-\u0026gt;ID); prt2=(struct node *)malloc(sizeof(struct node)); prt2-\u0026gt;ID=2; prt1-\u0026gt;next=prt2; printf(\u0026#34;p:%d\\n\u0026#34;,prt2-\u0026gt;ID); prt3=(struct node *)malloc(sizeof(struct node)); prt3-\u0026gt;ID=3; prt2-\u0026gt;next=prt3; printf(\u0026#34;p:%d\\n\u0026#34;,prt3-\u0026gt;ID); prt3-\u0026gt;next=NULL; } void node_up(){ struct node *current; current=head-\u0026gt;next; while (current != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;next; } } 結果\np:1 p:2 p:3 ----- p:1 p:2 p:3 第二個 更改新增方法，增加暫存變數。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct node { int ID; struct node *next; }; void node_in(int n); void node_up(); struct node *head,*prt,*last; int main(){ head = (struct node *)malloc(sizeof(struct node)); head-\u0026gt;next=NULL; last=head; for(int n=1;n\u0026lt;=3;n++){ node_in(n); } printf(\u0026#34;----\\n\u0026#34;); node_up(); return 0; } void node_in(int n){ prt=(struct node *)malloc(sizeof(struct node)); prt-\u0026gt;ID=n; prt-\u0026gt;next=NULL; last-\u0026gt;next=prt; last=prt; printf(\u0026#34;p:%d\\n\u0026#34;,prt-\u0026gt;ID); } void node_up(){ struct node *current; current=head-\u0026gt;next; while (current != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;next; } } 結果\np:1 p:2 p:3 ---- p:1 p:2 p:3 第三個 以先進後出的鏈結。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct node { int ID; struct node *next; }; void node_in(int n); void node_up(); struct node *head,*prt; int main(){ head = (struct node *)malloc(sizeof(struct node)); head-\u0026gt;next=NULL; for(int n=1;n\u0026lt;=3;n++){ node_in(n); } printf(\u0026#34;----\\n\u0026#34;); node_up(); return 0; } void node_in(int n){ prt=(struct node *)malloc(sizeof(struct node)); prt-\u0026gt;ID=n; prt-\u0026gt;next=NULL; prt-\u0026gt;next=head-\u0026gt;next; head-\u0026gt;next=prt; printf(\u0026#34;p:%d\\n\u0026#34;,prt-\u0026gt;ID); } void node_up(){ struct node *current; current=head-\u0026gt;next; while (current != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;next; } } 結果\np:1 p:2 p:3 ---- p:3 p:2 p:1 第四個 改成雙向鏈結\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct node { struct node *Previous; int ID; struct node *next; }; void node_in(int n); void node_up(); struct node *head,*prt,*last; int main(){ head = (struct node *)malloc(sizeof(struct node)); head-\u0026gt;Previous=NULL; head-\u0026gt;next=NULL; last=head; for(int n=1;n\u0026lt;=3;n++){ node_in(n); } printf(\u0026#34;----\\n\u0026#34;); node_up(); return 0; } void node_in(int n){ prt=(struct node *)malloc(sizeof(struct node)); prt-\u0026gt;Previous=last; prt-\u0026gt;ID=n; prt-\u0026gt;next=NULL; last-\u0026gt;next=prt; last=prt; printf(\u0026#34;p:%d\\n\u0026#34;,prt-\u0026gt;ID); } void node_up(){ struct node *current; current=head-\u0026gt;next; while (current != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;next; } printf(\u0026#34;----\\n\u0026#34;); current=last; while (current-\u0026gt;Previous != NULL) { printf(\u0026#34;p:%d\\n\u0026#34;,current-\u0026gt;ID); current=current-\u0026gt;Previous; } } 結果\np:1 p:2 p:3 ---- p:1 p:2 p:3 ---- p:3 p:2 p:1 ","permalink":"https://tom8760925.github.io/tomku/c/no/11/","summary":"這篇是C的練習筆記第11篇","title":"C語言的練習-鏈結"},{"content":"input buffer 這篇是C的筆記第02篇\n在寫C語言的練習-練習實作04時，在使用scanf時，發現會因為input buffer，造成問題所以需要清掉。\n但需要確認放的位置，不然可能會多一次輸入。\n#include \u0026lt;stdio.h\u0026gt; int main(){ while ( (getchar()) != \u0026#39;\\n\u0026#39; ); return 0; } 參考資料:\n連結：Clearing The Input Buffer In C/C++網址：https://www.geeksforgeeks.org/clearing-the-input-buffer-in-cc/\n","permalink":"https://tom8760925.github.io/tomku/c/notes/02/","summary":"這篇是C的筆記第02篇","title":"C語言的筆記-input buffer"},{"content":"記憶體位置 這篇是C的筆記第01篇\n在寫C語言的練習-練習實作04時，發現到記憶體位置會干擾到值。\n如果使用test1宣告int和char，在輸入1時不會引響，但在輸入12就會影響a。\n經過測試因該是記憶體位置有關，因為test1在b輸入超過1bytes時，a的值就問題，改成test2就解決這個問題。\n#include \u0026lt;stdio.h\u0026gt; void test1(); void test2(); int main(){ printf(\u0026#34;test1\\n\u0026#34;); test1(); printf(\u0026#34;test2\\n\u0026#34;); test2(); return 0; } void test1(){ int a=0; char b[]=\u0026#34;\u0026#34;; printf(\u0026#34;a:%d\\n\u0026#34;,\u0026amp;a); printf(\u0026#34;b:%d\\n\u0026#34;,\u0026amp;b); printf(\u0026#34;p:%d\\n\u0026#34;,a); scanf(\u0026#34;%s\u0026#34;,b); printf(\u0026#34;p:%d\\n\u0026#34;,a); scanf(\u0026#34;%s\u0026#34;,b); printf(\u0026#34;p:%d\\n\u0026#34;,a); } void test2(){ char b[]=\u0026#34;\u0026#34;; int a=0; printf(\u0026#34;b:%d\\n\u0026#34;,\u0026amp;b); printf(\u0026#34;a:%d\\n\u0026#34;,\u0026amp;a); printf(\u0026#34;p:%d\\n\u0026#34;,a); scanf(\u0026#34;%s\u0026#34;,b); printf(\u0026#34;p:%d\\n\u0026#34;,a); scanf(\u0026#34;%s\u0026#34;,b); printf(\u0026#34;p:%d\\n\u0026#34;,a); } 結果\ntest1 a:1798009612 b:1798009611 p:0 1 p:0 12 p:50 test2 b:1798009615 a:1798009608 p:0 1 p:0 12 p:0 ","permalink":"https://tom8760925.github.io/tomku/c/notes/01/","summary":"這篇是C的筆記第01篇","title":"C語言的筆記-記憶體位置"},{"content":"student 這篇是C的練習實作第04篇\n更改迴圈的判斷、更改資料輸入方式、新增總成績、新增清input buffer\n#include \u0026lt;stdio.h\u0026gt;//載入指令 #include \u0026lt;stdbool.h\u0026gt;//載入指令 #include \u0026lt;stdlib.h\u0026gt;//載入指令 #include \u0026lt;ctype.h\u0026gt;//載入指令 #include \u0026lt;string.h\u0026gt;//載入指令 #ifndef MAX //定義 #define MAX 2 #endif struct student //結構宣告 { char name[50]; int no,score; }; void student_input(int n);//資料輸入 int student_score(int n);//總成績 void scanf_flush();//清input buffer struct student struct_student[MAX];//結構變數宣告 int main(){ char scanf_in[]=\u0026#34;\u0026#34;;//宣告 int scanf_number=0;//宣告 bool bool_n = true;//宣告 while (bool_n)//判斷是否結束迴圈 { printf(\u0026#34;輸入1輸入學生資料(最多輸入%d筆資料，現在已經輸入%d筆)\\n輸入2計算總成績\\n輸入3離開\\n請輸入1、2、3:\u0026#34;,(int)MAX,scanf_number);//顯示需要輸入的值 scanf(\u0026#34;%[1-3]s\u0026#34;,scanf_in);//輸入的值 switch (atoi(\u0026amp;scanf_in[0]))//判斷輸入的值 { case 1: if(scanf_number\u0026lt;MAX){//判斷輸入筆數 printf(\u0026#34;現在輸入的是第%d筆\\n\u0026#34;,scanf_number+1);//顯示筆數 student_input(scanf_number);//呼叫函數 scanf_number++;//筆數+1 } else{ printf(\u0026#34;現在已經輸入%d筆，結束輸入\\n\u0026#34;,scanf_number);//超過筆數強制結束 bool_n=false; } break; case 2: if(scanf_number\u0026gt;0){ printf(\u0026#34;總成績:%d\\n\u0026#34;,student_score(scanf_number));//總成績 } else{ printf(\u0026#34;並未輸入任何成績\\n\u0026#34;); } break; case 3: printf(\u0026#34;離開\\n\u0026#34;);//結束迴圈 bool_n=false; break; default: printf(\u0026#34;輸入錯誤\\n\u0026#34;);//輸入的值錯誤 break; } scanf_flush();//清input buffer } return 0; } void student_input(int n){ char *pr[]={\u0026#34;英文姓名\u0026#34;,\u0026#34;學號\u0026#34;,\u0026#34;成績\u0026#34;},*scanf_if[]={\u0026#34;char\u0026#34;,\u0026#34;int\u0026#34;,\u0026#34;int\u0026#34;};//宣告 struct student struct_student_input;//結構變數宣告 void *scanf_void[]={\u0026amp;struct_student_input.name,\u0026amp;struct_student_input.no,\u0026amp;struct_student_input.score};//宣告記憶體位置 for(int i=0;i\u0026lt;(int)(sizeof(pr)/sizeof(pr[0]));i++){//跑迴圈 scanf_flush();//清input buffer printf(\u0026#34;請輸入%s:\u0026#34;,pr[i]);//顯示需要輸入的值 if(strcmp(scanf_if[i],\u0026#34;char\u0026#34;)==0)//判斷輸入為字串或數值 { scanf(\u0026#34;%s\u0026#34;,(char *)scanf_void[i]);//輸入字串 printf(\u0026#34;%s:%s\\n\u0026#34;,pr[i],(char *)scanf_void[i]);//顯示數入值 } else { scanf(\u0026#34;%d\u0026#34;,(int *)scanf_void[i]);//輸入數值 printf(\u0026#34;%s:%d\\n\u0026#34;,pr[i],*(int *)scanf_void[i]);//顯示數入值 } } struct_student[n]=struct_student_input;//輸入資料 } int student_score(int n){ int return_score=0;//宣告 for(int i=0;i\u0026lt;n;i++){//回圈 return_score+=struct_student[n-1].score;//計算總和 } return return_score; } void scanf_flush(){ while ( (getchar()) != \u0026#39;\\n\u0026#39; ) continue; } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/04/","summary":"這篇是C的練習實作第04篇","title":"C語言的練習-練習實作04"},{"content":"student 這篇是C的練習實作第03篇\n練習陣列、指標、結構、預處理\n#include \u0026lt;stdio.h\u0026gt;//載入指令 #include \u0026lt;stdbool.h\u0026gt;//載入指令 #ifndef MAX //定義 #define MAX 2 #endif struct student //結構宣告 { char name[50]; int no,phone; }; struct student student_input();//函數宣告 struct student prin[MAX];//結構變數宣告 int main(){ int n=0,stin=0;//宣告 while (n != 2)//判斷是否結束迴圈 { printf(\u0026#34;輸入1輸入學生資料(最多輸入%d筆資料)\\n輸入2離開\\n請輸入1或2:\u0026#34;,(int)MAX);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);//輸入的值 switch (n)//判斷輸入的值 { case 1: if(stin\u0026lt;MAX){//判斷輸入筆數 printf(\u0026#34;現在輸入的是第%d筆\\n\u0026#34;,stin+1);//結束迴圈 prin[stin] = student_input();//呼叫函數 stin++;//筆數+1 } else{ printf(\u0026#34;現在已經輸入%d筆，結束輸入\\n\u0026#34;,stin);//超過筆數強制結束 n=2; } break; case 2: printf(\u0026#34;離開\\n\u0026#34;);//結束迴圈 break; default: printf(\u0026#34;輸入錯誤\\n\u0026#34;);//輸入的值錯誤 break; } } return 0; } struct student student_input(){ struct student prf;//結構變數宣告 char *pr[]={\u0026#34;姓名\u0026#34;,\u0026#34;學號\u0026#34;,\u0026#34;電話\u0026#34;};//宣告 printf(\u0026#34;請輸入%s:\u0026#34;,pr[0]);//顯示需要輸入的值 scanf(\u0026#34;%s\u0026#34;,prf.name);//輸入的值 printf(\u0026#34;%s:%s\\n\u0026#34;,pr[0],prf.name);//顯示輸入的值 printf(\u0026#34;請輸入%s:\u0026#34;,pr[1]);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;prf.no);//輸入的值 printf(\u0026#34;%s:%d\\n\u0026#34;,pr[1],prf.no);//顯示輸入的值 printf(\u0026#34;請輸入%s:\u0026#34;,pr[2]);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;prf.phone);//輸入的值 printf(\u0026#34;%s:%d\\n\u0026#34;,pr[2],prf.phone);//顯示輸入的值 return prf; } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/03/","summary":"這篇是C的練習實作第03篇","title":"C語言的練習-練習實作03"},{"content":"預處理 這篇是C的練習筆記第10篇\n指令 c在執行程式有預處理\n#include \u0026lt;stdio.h\u0026gt; #define MAX 2 #ifndef MAX//如果同樣定義，就不執行 #define MAX 3 #endif #ifdef MAX//如果同樣定義，就執行 #define NMAX 1 #endif #if (NMAX==1)//判斷 #define IFMAX 3 #elif (NMAX==2) #define IFMAX 2 #else #define IFMAX 1 #endif #if defined(NMAX)//判斷是有定義 #define IFDMAX 4 #endif int main(){ printf(\u0026#34;p:%d\\n\u0026#34;,MAX); printf(\u0026#34;p:%d\\n\u0026#34;,NMAX); printf(\u0026#34;p:%d\\n\u0026#34;,IFMAX); printf(\u0026#34;p:%d\\n\u0026#34;,IFDMAX); return 0; } 結果\np:2 p:1 p:3 p:4 參考資料:\n連結：前置處理器指示詞網址：https://learn.microsoft.com/zh-tw/cpp/preprocessor/preprocessor-directives?view=msvc-170\n連結：C 预处理器 | 菜鸟教程網址：https://www.runoob.com/cprogramming/c-preprocessors.html\n連結：C語言雜談01---如何理解條件編譯網址：https://ithelp.ithome.com.tw/articles/10283174\n","permalink":"https://tom8760925.github.io/tomku/c/no/10/","summary":"這篇是C的練習筆記第10篇","title":"C語言的練習-預處理"},{"content":"結構 這篇是C的練習筆記第09篇\n結構宣告 c的結構宣告是\n#include \u0026lt;stdio.h\u0026gt; struct a //第一種 { int aa; }; struct b //第二種 { char bb; } bs;//直接宣告結構變數名稱 int main(){ struct c//第三種 { int *cc; }; struct d//第四種 { char *dd; } ds; struct e //第五種 { char ee,ef[3]; } es={\u0026#39;b\u0026#39;,{\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;}};//宣告結構變數和設定初值 struct a as ={1};//宣告結構變數和設定初值 struct c cs;//宣告結構變數 bs.bb=\u0026#39;a\u0026#39;;//設定值 cs.cc=\u0026amp;as.aa;//設定值 ds.dd=\u0026amp;bs.bb;//設定值 printf(\u0026#34;p:%d\\n\u0026#34;,as.aa); printf(\u0026#34;p:%c\\n\u0026#34;,bs.bb); printf(\u0026#34;p:%d\\n\u0026#34;,*cs.cc); printf(\u0026#34;p:%c\\n\u0026#34;,*ds.dd); printf(\u0026#34;p:%c\\n\u0026#34;,es.ee); printf(\u0026#34;p:%c\\n\u0026#34;,es.ef[0]); return 0; } 結果\np:1 p:a p:1 p:a p:b p:c 結構的使用方法 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct a { int aa; }; struct b { struct a aa; char bb; }; void ra(struct a *ar); void ra2(struct a ar); struct a ra3(struct a ar); int main(){ struct a as ={1};//使用方法1 struct a *as2=\u0026amp;as;//使用方法1 struct a as3;//使用方法2 struct a as4={.aa=4};//使用方法5 struct b bs={//使用方法6 .aa={.aa=5}, .bb=\u0026#39;A\u0026#39; }; struct a as5[]={{.aa=1},{.aa=2},{.aa=3},{.aa=4},{.aa=5}};//使用方法7 struct a *as6 = malloc(sizeof(struct a));//使用方法8 struct a *as7 = malloc(5*sizeof(struct a));//使用方法9 printf(\u0026#34;使用方法1\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,as2-\u0026gt;aa); printf(\u0026#34;p:%d\\n\u0026#34;,(*as2).aa); printf(\u0026#34;使用方法2\\n\u0026#34;); ra(\u0026amp;as3); printf(\u0026#34;p:%d\\n\u0026#34;,as3.aa); printf(\u0026#34;使用方法3\\n\u0026#34;); ra2(as); printf(\u0026#34;使用方法4\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,ra3(as).aa); printf(\u0026#34;使用方法5\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,as4.aa); printf(\u0026#34;使用方法6\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,bs.aa.aa); printf(\u0026#34;p:%c\\n\u0026#34;,bs.bb); printf(\u0026#34;使用方法7\\n\u0026#34;); printf(\u0026#34;p:%d\\n\u0026#34;,as5[2].aa); printf(\u0026#34;使用方法8\\n\u0026#34;); (*as6).aa=1; printf(\u0026#34;p:%d\\n\u0026#34;,(*as6).aa); free(as6); printf(\u0026#34;使用方法9\\n\u0026#34;); as7[3].aa=3; printf(\u0026#34;p:%d\\n\u0026#34;,as7[3].aa); free(as7); return 0; } void ra(struct a *ar){//使用方法2 (*ar).aa=2; } void ra2(struct a ar){//使用方法3 printf(\u0026#34;p:%d\\n\u0026#34;,ar.aa); } struct a ra3(struct a ar){//使用方法4 struct a ar_n; ar_n.aa=ar.aa+2; return ar_n; } 結果\n使用方法1 p:1 p:1 使用方法2 p:2 使用方法3 p:1 使用方法4 p:3 使用方法5 p:4 使用方法6 p:5 p:A 使用方法7 p:3 使用方法8 p:1 使用方法9 p:3 ","permalink":"https://tom8760925.github.io/tomku/c/no/09/","summary":"這篇是C的練習筆記第09篇","title":"C語言的練習-結構"},{"content":"指標 這篇是C的練習筆記第08篇\n指標宣告 c的指標宣告有＊、＊＊，一個＊是數值或字串的指標、兩個＊＊是指標的指標。\nint main(){ int *a,**b; char *c,**d; void *e,**f; return 0; } 指標的使用 指標主要是儲存記憶體位址，一般的變數加上＆就會變成顯示記憶體位址，而指標在加上＊或＊＊就會顯示所儲存記憶體的儲存值。void只儲存記憶體位址，所以無法顯示所儲存記憶體的儲存值，需要先轉換數值或字串。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int **a,*b,c=1;//儲存數值的記憶體位址 char **d,*e,f=\u0026#39;A\u0026#39;;//儲存字串的記憶體位址 void **g,*h;//儲存任意的記憶體位址 //int b=\u0026amp;c;//b儲存c記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,*b); a=\u0026amp;b;//a儲存b記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,**a); //char e=\u0026amp;f;//e儲存f記憶體位址 printf(\u0026#34;p:%c\\n\u0026#34;,*e); d=\u0026amp;e;//d儲存e記憶體位址 printf(\u0026#34;p:%c\\n\u0026#34;,**d); //void h=\u0026amp;c;//h儲存c記憶體位址 g=\u0026amp;h;//g儲存h記憶體位址 h=\u0026amp;f;//h儲存f記憶體位址 g=\u0026amp;h;//g儲存h記憶體位址 return 0; } 指標的其他使用方式\n#include \u0026lt;stdio.h\u0026gt; int main(){ char a=\u0026#39;a\u0026#39;,b=\u0026#39;b\u0026#39;; int c[]={1,2,3,4,5}; printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;a); printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;b); printf(\u0026#34;p:%c\\n\u0026#34;,*(\u0026amp;b+1));//下一位的記憶體 printf(\u0026#34;p:%c\\n\u0026#34;,*(\u0026amp;a-1));//上一位的記憶體 printf(\u0026#34;p:%d\\n\u0026#34;,c);//陣列第一筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[0]);//第一筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[1]);//第二筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[2]);//第三筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[3]);//第四筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,\u0026amp;c[4]);//第五筆的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,(\u0026amp;c+1));//陣列下一個的記憶體位址 printf(\u0026#34;p:%d\\n\u0026#34;,*(\u0026amp;c+1)-c); /*用陣列下一個的記憶體位址，減掉陣列第一筆的記憶體位址。 要加上＊不然會有錯誤錯誤為int (*)[5]\u0026#39; and \u0026#39;int *\u0026#39; are not pointers to compatible types。*/ return 0; } 結果\np:1830138555 p:1830138554 p:a p:b p:1830138560 p:1830138560 p:1830138564 p:1830138568 p:1830138572 p:1830138576 p:1830138580 p:5 ","permalink":"https://tom8760925.github.io/tomku/c/no/08/","summary":"這篇是C的練習筆記第08篇","title":"C語言的練習-指標和記憶體位址"},{"content":"陣列 這篇是C的練習筆記第07篇\n一維陣列 c的數值陣列宣告\n#include \u0026lt;stdlib.h\u0026gt; int main(){ int a[50];//創建大小為50陣列 int b[50]={1,2,3,4};//創建大小為50陣列，並輸入值 int c[]={1,2,3,4};//依照輸入值的大小創建陣列 int d[]={};//創建依照輸入值的大小創建的陣列 int *e = (int *)malloc(10*sizeof(int));//創建10個空值陣列 int *f = (int *)calloc(10,sizeof(int));//創建10個為0的陣列 int g[] = {[0] = 1,[1] = 2,[2] = 3,[3] = 4,[4] = 5};//指定收尋值 return 0; } c的字串陣列宣告\n#include \u0026lt;stdlib.h\u0026gt; int main(){ char a[50];//創建大小為50陣列 char b[50]=\u0026#34;AAA\u0026#34;;//創建大小為50陣列，並輸入值 char c[]=\u0026#34;AAA\u0026#34;;//依照輸入值的大小創建陣列 char d[]=\u0026#34;\u0026#34;;//創建依照輸入值的大小創建的陣列 char *e = (char *)malloc(10*sizeof(char));//創建10個空值陣列 char *f = (char *)calloc(10,sizeof(char));//創建10個為空的陣列 char g[] = {[0] = \u0026#39;A\u0026#39;,[1] = \u0026#39;B\u0026#39;,[2] = \u0026#39;C\u0026#39;,[3] = \u0026#39;D\u0026#39;,[4] = \u0026#39;E\u0026#39;};//指定收尋值 return 0; } c的陣列顯示\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a[]={1,5,10,15}; printf(\u0026#34;p:%d\\n\u0026#34;,*a); printf(\u0026#34;p:%d\\n\u0026#34;,a[0]); printf(\u0026#34;p:%d\\n\u0026#34;,*(a+1));//a[1] return 0; } 結果\np:1 p:1 p:5 二維陣列 c的數值陣列宣告\n#include \u0026lt;stdlib.h\u0026gt; int main(){ int a[10][10];//創建大小為50陣列 int b[10][10]={{1,2},{3,4},{5,6},{7,8}};//創建大小為10*10陣列，並輸入值 int **e = (int **)malloc(10*sizeof(int));//創建10*10個空值陣列 for(int n = 0;n\u0026lt;10;n++){ e[n] = (int *)malloc(10*sizeof(int)); } int (*f)[10][10] = malloc(sizeof(*f));//創建10*10個空值陣列 int (*g)[10] = malloc(10*sizeof(*g));//創建10*10個空值陣列 int **h = (int **)calloc(10,sizeof(int));//創建10*10個為0的陣列 for(int n = 0;n\u0026lt;10;n++){ h[n] = (int *)calloc(10,sizeof(int)); } return 0; } c的字串陣列宣告\n#include \u0026lt;stdlib.h\u0026gt; int main(){ char a[50][50];//創建大小為50*50陣列 char b[50][50]={\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;};//創建大小為50*50陣列，並輸入值 char *c[2]={\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;};//依照輸入值的大小創建陣列 char *d[]={\u0026#34;AAA\u0026#34;,\u0026#34;BBB\u0026#34;};//依照輸入值的大小創建陣列 char **e = (char **)malloc(10*sizeof(char));//創建10*10個空值陣列 for(int n = 0;n\u0026lt;10;n++){ e[n] = (char *)malloc(10*sizeof(char)); } char (*f)[10][10] = malloc(sizeof(*f));//創建10*10個空值陣列 char (*g)[10] = malloc(10*sizeof(*g));//創建10*10個空值陣列 char **h = (char **)calloc(10,sizeof(char));//創建10*10個為0的陣列 for(int n = 0;n\u0026lt;10;n++){ h[n] = (char *)calloc(10,sizeof(char)); } return 0; } c的陣列顯示\n#include \u0026lt;stdio.h\u0026gt; int main(){ char *a[2]={\u0026#34;apple\u0026#34;,\u0026#34;banana\u0026#34;}; printf(\u0026#34;p:%s\\n\u0026#34;,a[0]); printf(\u0026#34;p:%s\\n\u0026#34;,a[1]); printf(\u0026#34;p:%c\\n\u0026#34;,a[0][0]); printf(\u0026#34;p:%c\\n\u0026#34;,a[1][0]); printf(\u0026#34;p:%s\\n\u0026#34;,*a);//a[0] printf(\u0026#34;p:%s\\n\u0026#34;,*(a+1));//a[1] printf(\u0026#34;p:%c\\n\u0026#34;,*a[0]);//a[0][0] printf(\u0026#34;p:%c\\n\u0026#34;,**a);//a[0][0] printf(\u0026#34;p:%c\\n\u0026#34;,*a[1]);//a[1][0] printf(\u0026#34;p:%c\\n\u0026#34;,**(a+1));//[1]][0] printf(\u0026#34;提取第三個字p和n\\n\u0026#34;); printf(\u0026#34;p:%c\\n\u0026#34;,a[0][2]); printf(\u0026#34;p:%c\\n\u0026#34;,a[1][2]); printf(\u0026#34;p:%c\\n\u0026#34;,*(*a+2));//a[0][2] printf(\u0026#34;p:%c\\n\u0026#34;,*(*(a+1)+2));//a[1][2] return 0; } 結果\np:apple p:banana p:a p:b p:apple p:banana p:a p:a p:b p:b 提取第三個字p和n p:p p:n p:p p:n 陣列大小 c找陣列大小方法\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; int main(){ int a[]={1,2,3,4,5}; size_t sa = sizeof(a)/sizeof(int); int ia = sizeof(a)/sizeof(int); size_t sa2 = sizeof(a)/sizeof(a[0]); int ia2 = sizeof(a)/sizeof(a[0]); int length = *(\u0026amp;a + 1) - a; return 0; } 改陣列大小 c找改陣列大小方法\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; int main(){ int *a; a = (int *)malloc(10*sizeof(int));//創建10個空值陣列 int *b; b = realloc(a,sizeof(int)*20);//更改陣列大小 if(b == NULL){//檢查是否為NULL，也可以使用!b等同於b == NULL free(b); } else{ a=b; free(b); } return 0; } 釋放記憶體 c沒有像其他語言有Garbage collection，所以有些情況需要對記憶體進行釋放，使用malloc和calloc在結束時要使用free()釋放記憶體。\n#include \u0026lt;stdlib.h\u0026gt; int main(){ int *a = (int *)malloc(10*sizeof(int));//創建10個空值陣列 free(a);//釋放記憶體 return 0; } 參考資料:\n連結：Days 9: 動態記憶體分配：malloc()、calloc()、realloc()、free()，內存洩露網址：https://ithelp.ithome.com.tw/articles/10204463\n連結：malloc、free、calloc 與 realloc網址：https://openhome.cc/Gossip/CGossip/MallocFree.html\n","permalink":"https://tom8760925.github.io/tomku/c/no/07/","summary":"這篇是C的練習筆記第07篇","title":"C語言的練習-陣列"},{"content":"student 這篇是C的練習實作第02篇\n練習使用迴圈、判斷式。\n#include \u0026lt;stdio.h\u0026gt;//載入指令 #include \u0026lt;stdbool.h\u0026gt;//載入指令 void student_input();//函數宣告 int main(){ int n=0;//宣告 while (n != 2)//判斷是否結束迴圈 { printf(\u0026#34;輸入1輸入學生資料\\n輸入2離開\\n請輸入1或2:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);//輸入的值 switch (n)//判斷輸入的值 { case 1: student_input();//呼叫函數 break; case 2: printf(\u0026#34;離開\\n\u0026#34;);//結束迴圈 break; default: printf(\u0026#34;輸入錯誤\\n\u0026#34;);//輸入的值錯誤 break; } } return 0; } void student_input(){ char name[]=\u0026#34;\u0026#34;; int no=0,phone=0; printf(\u0026#34;請輸入姓名:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%s\u0026#34;,name);//輸入的值 printf(\u0026#34;姓名:%s\\n\u0026#34;,name);//顯示輸入的值 printf(\u0026#34;請輸入學號:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;no);//輸入的值 printf(\u0026#34;學號:%d\\n\u0026#34;,no);//顯示輸入的值 printf(\u0026#34;請輸入電話:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;phone);//輸入的值 printf(\u0026#34;電話:%d\\n\u0026#34;,phone);//顯示輸入的值 } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/02/","summary":"這篇是C的練習實作第02篇","title":"C語言的練習-練習實作02"},{"content":"迴圈 這篇是C的練習筆記第06篇\nfor C的for寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ for(int n = 0;n\u0026lt;5;n++) { printf(\u0026#34;p:%d\\n\u0026#34;,n); } return 0; } 結果\np:0 p:1 p:2 p:3 p:4 for的參數可以簡化\n#include \u0026lt;stdio.h\u0026gt; int main(){ int n = 0; for(;n\u0026lt;2;) { printf(\u0026#34;p:%d\\n\u0026#34;,n); n++; } return 0; } 結果\np:0 p:1 while C的while寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ int n = 0; while (n\u0026lt;5) { printf(\u0026#34;p:%d\\n\u0026#34;,n); n++; } return 0; } 結果\np:0 p:1 p:2 p:3 p:4 do while C的do while寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ int n = 0; do{ printf(\u0026#34;p:%d\\n\u0026#34;,n); } while (n != 0); return 0; } break C的break寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ for(int n = 0;n\u0026lt;5;n++) { if(n == 2){ break; } printf(\u0026#34;p:%d\\n\u0026#34;,n); } return 0; } 結果\np:0 p:1 continue C的continue寫法是\n#include \u0026lt;stdio.h\u0026gt; int main(){ for(int n = 0;n\u0026lt;5;n++) { if(n == 2){ continue; } printf(\u0026#34;p:%d\\n\u0026#34;,n); } return 0; } 結果\np:0 p:1 p:3 p:4 for可以寫這樣\n#include \u0026lt;stdio.h\u0026gt; int main(){ for(int a = 1,b = 1;a\u0026lt;=9;a++,b++) { printf(\u0026#34;%d*%d=%d\\n\u0026#34;,a,b,a*b); } return 0; } 結果\n1*1=1 2*2=4 3*3=9 4*4=16 5*5=25 6*6=36 7*7=49 8*8=64 9*9=81 ","permalink":"https://tom8760925.github.io/tomku/c/no/06/","summary":"這篇是C的練習筆記第06篇","title":"C語言的練習-迴圈"},{"content":"student 這篇是C的練習實作第01篇\n練習使用函式宣告，輸入姓名、學號、電話，並顯示出來。\n#include \u0026lt;stdio.h\u0026gt;//載入指令 void student_input();//函數宣告 int main(){ student_input();//呼叫函數 return 0; } void student_input(){ char name[]=\u0026#34;\u0026#34;; int no=0,phone=0; printf(\u0026#34;請輸入姓名:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%s\u0026#34;,name);//輸入的值 printf(\u0026#34;姓名:%s\\n\u0026#34;,name);//顯示輸入的值 printf(\u0026#34;請輸入學號:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;no);//輸入的值 printf(\u0026#34;學號:%d\\n\u0026#34;,no);//顯示輸入的值 printf(\u0026#34;請輸入電話:\u0026#34;);//顯示需要輸入的值 scanf(\u0026#34;%d\u0026#34;,\u0026amp;phone);//輸入的值 printf(\u0026#34;電話:%d\\n\u0026#34;,phone);//顯示輸入的值 } 程式存放在github中連結:github\n","permalink":"https://tom8760925.github.io/tomku/c/practice/01/","summary":"這篇是C的練習實作第01篇","title":"C語言的練習-練習實作01"},{"content":"if 這篇是C的練習筆記第05篇\nC的if寫法是\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(){ bool p = true; if(p){ printf(\u0026#34;p:%s\\n\u0026#34;,p?\u0026#34;true\u0026#34;:\u0026#34;fales\u0026#34;); } else{ printf(\u0026#34;p:%s\\n\u0026#34;,p?\u0026#34;true\u0026#34;:\u0026#34;fales\u0026#34;); } return 0; } 結果\np:true if也可以寫成這樣\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(){ bool p = false; p = (2\u0026gt;1)?true:false; printf(\u0026#34;p:%s\\n\u0026#34;,p?\u0026#34;true\u0026#34;:\u0026#34;fales\u0026#34;); return 0; } 結果\np:true 多條件if\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a=1,b=2; if(a\u0026lt;b){ printf(\u0026#34;p:%d\u0026lt;%d\\n\u0026#34;,a,b); } else if(a\u0026gt;b) { printf(\u0026#34;p:%d\u0026gt;%d\\n\u0026#34;,a,b); } else{ printf(\u0026#34;p:%d=%d\\n\u0026#34;,a,b); } return 0; } 結果\np:1\u0026lt;2 多條件還有\n#include \u0026lt;stdio.h\u0026gt; int main(){ char n=\u0026#39;a\u0026#39;; switch (n) { case \u0026#39;a\u0026#39;: printf(\u0026#34;p:apple\\n\u0026#34;); break; case \u0026#39;b\u0026#39;: printf(\u0026#34;p:banana\\n\u0026#34;); break; default: printf(\u0026#34;p:error\\n\u0026#34;); break; } return 0; } 結果\np:apple ","permalink":"https://tom8760925.github.io/tomku/c/no/05/","summary":"這篇是C的練習筆記第05篇","title":"C語言的練習-if"},{"content":"printf 和 scanf 這篇是C的練習筆記第04篇\nc的輸入和輸出分別為scanf 和 printf\n要使用需要加上最上面\n#include \u0026lt;stdio.h\u0026gt; printf c輸出是使用printf，要使用printf也需要設定資料型態和變數。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a=1; printf(\u0026#34;p:%d\\n\u0026#34;,a); return 0; } 結果\np:1 型態 在使用printf時，需要設定資料型態，而型態有好幾種。\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;十進位:%d\\n\u0026#34;,16); printf(\u0026#34;十進制無符號:%u\\n\u0026#34;,16); printf(\u0026#34;十進位浮點數:%f\\n\u0026#34;,16.16); printf(\u0026#34;八進位:%o\\n\u0026#34;,16); printf(\u0026#34;十六進位:%x\\n\u0026#34;,16); printf(\u0026#34;十六進位浮點數:%a\\n\u0026#34;,16.16); printf(\u0026#34;指數:%e\\n\u0026#34;,16.16); printf(\u0026#34;判斷使用%%f和%%e，哪個以較短較精簡能夠輸出:%g\\n\u0026#34;,16.16); printf(\u0026#34;單一字元:%c\\n\u0026#34;,\u0026#39;A\u0026#39;); printf(\u0026#34;字串:%s\\n\u0026#34;,\u0026#34;AA\u0026#34;); char a[] = \u0026#34;AA\u0026#34;; printf(\u0026#34;記憶體位置:%p\\n\u0026#34;,a); printf(\u0026#34;專門是unsigned long:%lu\\n\u0026#34;,(unsigned long)16); printf(\u0026#34;專門是unsigned long long:%llu\\n\u0026#34;,(unsigned long long)16); printf(\u0026#34;%%:%%A\\n\u0026#34;); return 0; } 結果\n十進位:16 十進制無符號:16 十進位浮點數:16.160000 八進位:20 十六進位:10 十六進位浮點數:0x1.028f5c28f5c29p+4 指數:1.616000e+01 判斷使用%f和%e，哪個以較短較精簡能夠輸出:16.16 單一字元:A 字串:AA 記憶體位置:0x16fdff048 專門是unsigned long:16 專門是unsigned long long:16 %:%A printf設定 printf可以設定如何顯示\n#include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;加上.和要顯示第幾位，設定四捨五入:%.2f\\n\u0026#34;,16.1666); printf(\u0026#34;加上.和要顯示第幾位:%.2s\\n\u0026#34;,\u0026#34;AAA\u0026#34;); printf(\u0026#34;加上數字，預留字元有少就補空格:%3d\\n\u0026#34;,16);//預留３個字元 printf(\u0026#34;加上數字，預留字元有少就補空格:%10f\\n\u0026#34;,16.16);//預留10個字元 printf(\u0026#34;加上數字，預留字元有少就補空格:%2c\\n\u0026#34;,\u0026#39;A\u0026#39;);//預留2個字元 printf(\u0026#34;加上數字，預留字元有少就補空格:%3s\\n\u0026#34;,\u0026#34;AA\u0026#34;);//預留3個字元 printf(\u0026#34;加上0和數字，預留字元有少就補0:%03d\\n\u0026#34;,16); printf(\u0026#34;加上*，預留字元有少就補空格:%*d\\n\u0026#34;,3,16); printf(\u0026#34;加上*，預留字元有少就補空格:%*d|%*d\\n\u0026#34;,3,16,3,16); printf(\u0026#34;加上負號，在預留字元範圍內靠左對齊:%-3d\\n\u0026#34;,16); printf(\u0026#34;加上+，顯示正負號:%+3d\\n\u0026#34;,16); printf(\u0026#34;加上空格，在前面加上空格:% d\\n\u0026#34;,16); printf(\u0026#34;加上#，在x、o前面加上0x非0值情況時:%#x\\n\u0026#34;,16); return 0; } 結果\n加上.和要顯示第幾位，設定四捨五入:16.17 加上.和要顯示第幾位:AA 加上數字，預留字元有少就補空格: 16 加上數字，預留字元有少就補空格: 16.160000 加上數字，預留字元有少就補空格: A 加上數字，預留字元有少就補空格: AA 加上0和數字，預留字元有少就補0:016 加上*，預留字元有少就補空格: 16 加上*，預留字元有少就補空格: 16| 16 加上負號，在預留字元範圍內靠左對齊:16 加上+，顯示正負號:+16 加上空格，在前面加上空格: 16 加上#，在x、o前面加上0x非0值情況時:0x10 scenf c輸入是使用scenf，要使用scanf需要設定資料型態和變數記憶體位置。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a=0; printf(\u0026#34;s:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); printf(\u0026#34;s:%d\\n\u0026#34;,a); return 0; } 結果\ns:1 s:1 型態 在使用scanf時，需要設定資料型態，而型態有好幾種。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 0; unsigned int e = 0; float b = 0; double f = 0; char c = \u0026#39;A\u0026#39;; char d[] = \u0026#34;\u0026#34;; void *g = NULL; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a);//十進位 scanf(\u0026#34;%u\u0026#34;,\u0026amp;e);//十進制無符號 scanf(\u0026#34;%f\u0026#34;,\u0026amp;b);//十進位浮點數 scanf(\u0026#34;%lf\u0026#34;,\u0026amp;f);//十進位浮點數 scanf(\u0026#34;%o\u0026#34;,\u0026amp;a);//八進位 scanf(\u0026#34;%x\u0026#34;,\u0026amp;a);//十六進位 scanf(\u0026#34;%i\u0026#34;,\u0026amp;a);//十進位八進位十六進位 scanf(\u0026#34;%a\u0026#34;,\u0026amp;b);//浮點數 scanf(\u0026#34;%e\u0026#34;,\u0026amp;b);//指數 scanf(\u0026#34;%g\u0026#34;,\u0026amp;b);//判斷使用%%f和%%e，哪個比較短較精簡 scanf(\u0026#34;%c\u0026#34;,\u0026amp;c);//單一字元 scanf(\u0026#34;%s\u0026#34;,d);//字串 scanf(\u0026#34;%p\u0026#34;,\u0026amp;g);//記憶體位置 return 0; } scanf設定 scanf的輸入可以設定\n#include \u0026lt;stdio.h\u0026gt; int main(){ char a[] = \u0026#34;\u0026#34;,b[3],c,d; scanf(\u0026#34;%[1-5]\u0026#34;,a); //設定輸入範圍，這樣設定會限制只能輸入1到5，輸入136只接收13，但輸入1363只接收13 scanf(\u0026#34;%[^1-5]\u0026#34;,a); //加上^，改為排除 scanf(\u0026#34;%2s\u0026#34;,b);//限制輸入字元 scanf(\u0026#34;%c-%c\u0026#34;,c,d); //輸入多個值，需要設定字元中間的區隔，這裡使用-在輸入值時需要依照設定區隔，沒有設定也會自動區隔。 return 0; } 其他 除了使用scanf 和 printf，還有其他可以用\n#include \u0026lt;stdio.h\u0026gt; int main(){ char a[50]; getchar();//輸入字元並只傳出一個字元 fgets(a,sizeof(a),stdin);//輸入字串 putchar(\u0026#39;A\u0026#39;);//只能輸出字char putchar(65);//會轉換ASCII得到Ａ puts(\u0026#34;AAA\u0026#34;);//輸出字串 return 0; } 跳脫字元 #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;\\\\n:A\\n\u0026#34;);//換行 printf(\u0026#34;\\\\t:\\tA\\n\u0026#34;);//tab printf(\u0026#34;\\\\b:\\bA\\n\u0026#34;);//backspace printf(\u0026#34;\\\\r:\\rABC\\n\u0026#34;); printf(\u0026#34;\\\\f:\\fA\\n\u0026#34;);//跳到下一行 printf(\u0026#34;\\\\\u0026#39;:\\\u0026#39;A\\n\u0026#34;); printf(\u0026#34;\\\\\\\u0026#34;:\\\u0026#34;A\\n\u0026#34;); printf(\u0026#34;\\\\:\\\\A\\n\u0026#34;); return 0; } 結果\n\\n:A \\t:\tA \\bA ABC \\f: A \\\u0026#39;:\u0026#39;A \\\u0026#34;:\u0026#34;A \\:\\A 參考資料:\n連結：C 标准库 – | 菜鸟教程網址：https://www.runoob.com/cprogramming/c-standard-library-stdio-h.html\n","permalink":"https://tom8760925.github.io/tomku/c/no/04/","summary":"這篇是C的練習筆記第04篇","title":"C語言的練習-printf 和 scanf"},{"content":"第一個程式 這篇是C的練習筆記第03篇\n起始程式 C跟其他程式一樣都有起始程式\nint main(){ return 0; } 最前面是回傳的型態\n程式結束時需要回傳0代表程式正常結束\n函數 如果沒有要回傳函數，在回傳的型態使用void\n在使用函數前，C是需要在起始程式前加上函數宣告\n#include \u0026lt;stdio.h\u0026gt; int test(int n); int main(){ int a = 0; a = test(1); printf(\u0026#34;p:%d\\n\u0026#34;,a); return 0; } int test(int n){ return n; } 結果\np:1 這樣程式在執行程式就知道有test的函數\n遞迴 C也有遞迴，a會等於5\n#include \u0026lt;stdio.h\u0026gt; int test(int n); int main(){ int a = 0; a = test(0); printf(\u0026#34;p:%d\\n\u0026#34;,a); return 0; } int test(int n){ n++; if(n == 5){ return n; } else{ return test(n); } } 結果\np:5 ","permalink":"https://tom8760925.github.io/tomku/c/no/03/","summary":"這篇是C的練習筆記第03篇","title":"C語言的練習-第一個程式"},{"content":"型態 這篇是C的練習筆記第02篇 記錄C有哪些型態 在型態前面加上unsigned，會變強制沒有負號\n種類 名稱 記憶體空間 加unsigned 數值 int 4 Bytes 可 short 2 Bytes 可 long 4 Bytes 可 浮點數 float 4 Bytes 不可 double 8 Bytes 不可 字元 char 1 Bytes 可 C也有bool但要加上\n#include \u0026lt;stdbool.h\u0026gt; 才能使用bool\n但使用printf無法直接顯示ture 或 false，需要使用其他方法，而其中一個方法。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(){ bool p = true; printf(\u0026#34;p:%s\\n\u0026#34;,p?\u0026#34;true\u0026#34;:\u0026#34;fales\u0026#34;); return 0; } 結果\np:true c使用void其中一個方法是存放記憶體位置，p會存放a的記憶體位置。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a = 11; void *p; p = \u0026amp;a; printf(\u0026#34;p:%p\\n\u0026#34;,\u0026amp;a); printf(\u0026#34;p:%p\\n\u0026#34;,p); printf(\u0026#34;p:%p\\n\u0026#34;,\u0026amp;p); return 0; } 結果\np:0x16f37f2d8 p:0x16f37f2d8 p:0x16f37f2d0 ","permalink":"https://tom8760925.github.io/tomku/c/no/02/","summary":"這篇是C的練習筆記第02篇","title":"C語言的練習-型態"},{"content":"環境設置 這篇是C的練習筆記第01篇\n以下是在MAC進行操作執行\n安裝VSCODE 去以下網址下載VSCODE\nhttps://code.visualstudio.com/ 安裝VSCODE插建 安裝C的插件\nhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack 繁體插件\nhttps://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hant 起始設定 先在程式資料夾中新增檔案，名子隨意副檔名為.c\n點選新增的.C檔案，再點選右上角齒輪\nC/C++:clang 建置及偵錯使用中的檔案 就會新增2個json欓 接著在收尋欄輸入\n\u0026gt;c/c++:Edit Configurations(JSON) 點選後會新增一個JSON檔案\n啟動測試 接著就能執行程式偵錯 有兩個方式可以偵錯\n1.直接點上方的執行-\u0026gt;進行偵錯 但這個方法在使用scanf，輸入時會有問題，可以在launch.json裡面修改參數externalConsole改成true，就會額外乎叫終端機視窗。 2.點右邊上三角形下拉選點單，選CompileRun : Compile with default flags \u0026amp; Run with default arguments，就能直接在vscode裡的終端機進行操作，使用scanf輸入也不會有問題。 沒問題就能直接執行.C檔案\n有問題可能是因為.C檔案內沒有程式，可以先寫個起始程式，應該就能執行。\nint main(){ return 0; } 參考資料:\n連結：Configure VS Code for Clang/LLVM on macOS網址：https://code.visualstudio.com/docs/cpp/config-clang-mac\n","permalink":"https://tom8760925.github.io/tomku/c/no/01/","summary":"這篇是C的練習筆記第01篇","title":"C語言的練習-環境設置"}]